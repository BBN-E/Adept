/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef TokenService_H
#define TokenService_H

#include <thrift/TDispatchProcessor.h>
#include "common_types.h"
#include "ItemService.h"

namespace thrift { namespace adept { namespace common {

class TokenServiceIf : virtual public ItemServiceIf {
 public:
  virtual ~TokenServiceIf() {}
  virtual void getAudioOffset(AudioOffset& _return) = 0;
  virtual void getCharOffset(CharOffset& _return) = 0;
  virtual double getConfidence() = 0;
  virtual void getLemma(std::string& _return) = 0;
  virtual int64_t getSequenceId() = 0;
  virtual TokenType::type getTokenType() = 0;
  virtual void setAudioOffset(const AudioOffset& audioOffset) = 0;
  virtual void setConfidence(const double confidence) = 0;
  virtual void setLemma(const std::string& lemma) = 0;
  virtual void setTokenType(const TokenType::type tokentype) = 0;
};

class TokenServiceIfFactory : virtual public ItemServiceIfFactory {
 public:
  typedef TokenServiceIf Handler;

  virtual ~TokenServiceIfFactory() {}

  virtual TokenServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ItemServiceIf* /* handler */) = 0;
};

class TokenServiceIfSingletonFactory : virtual public TokenServiceIfFactory {
 public:
  TokenServiceIfSingletonFactory(const boost::shared_ptr<TokenServiceIf>& iface) : iface_(iface) {}
  virtual ~TokenServiceIfSingletonFactory() {}

  virtual TokenServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ItemServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<TokenServiceIf> iface_;
};

class TokenServiceNull : virtual public TokenServiceIf , virtual public ItemServiceNull {
 public:
  virtual ~TokenServiceNull() {}
  void getAudioOffset(AudioOffset& /* _return */) {
    return;
  }
  void getCharOffset(CharOffset& /* _return */) {
    return;
  }
  double getConfidence() {
    double _return = (double)0;
    return _return;
  }
  void getLemma(std::string& /* _return */) {
    return;
  }
  int64_t getSequenceId() {
    int64_t _return = 0;
    return _return;
  }
  TokenType::type getTokenType() {
    TokenType::type _return = (TokenType::type)0;
    return _return;
  }
  void setAudioOffset(const AudioOffset& /* audioOffset */) {
    return;
  }
  void setConfidence(const double /* confidence */) {
    return;
  }
  void setLemma(const std::string& /* lemma */) {
    return;
  }
  void setTokenType(const TokenType::type /* tokentype */) {
    return;
  }
};


class TokenService_getAudioOffset_args {
 public:

  TokenService_getAudioOffset_args() {
  }

  virtual ~TokenService_getAudioOffset_args() throw() {}


  bool operator == (const TokenService_getAudioOffset_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_getAudioOffset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getAudioOffset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_getAudioOffset_pargs {
 public:


  virtual ~TokenService_getAudioOffset_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getAudioOffset_result__isset {
  _TokenService_getAudioOffset_result__isset() : success(false) {}
  bool success;
} _TokenService_getAudioOffset_result__isset;

class TokenService_getAudioOffset_result {
 public:

  TokenService_getAudioOffset_result() {
  }

  virtual ~TokenService_getAudioOffset_result() throw() {}

  AudioOffset success;

  _TokenService_getAudioOffset_result__isset __isset;

  void __set_success(const AudioOffset& val) {
    success = val;
  }

  bool operator == (const TokenService_getAudioOffset_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const TokenService_getAudioOffset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getAudioOffset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getAudioOffset_presult__isset {
  _TokenService_getAudioOffset_presult__isset() : success(false) {}
  bool success;
} _TokenService_getAudioOffset_presult__isset;

class TokenService_getAudioOffset_presult {
 public:


  virtual ~TokenService_getAudioOffset_presult() throw() {}

  AudioOffset* success;

  _TokenService_getAudioOffset_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class TokenService_getCharOffset_args {
 public:

  TokenService_getCharOffset_args() {
  }

  virtual ~TokenService_getCharOffset_args() throw() {}


  bool operator == (const TokenService_getCharOffset_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_getCharOffset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getCharOffset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_getCharOffset_pargs {
 public:


  virtual ~TokenService_getCharOffset_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getCharOffset_result__isset {
  _TokenService_getCharOffset_result__isset() : success(false) {}
  bool success;
} _TokenService_getCharOffset_result__isset;

class TokenService_getCharOffset_result {
 public:

  TokenService_getCharOffset_result() {
  }

  virtual ~TokenService_getCharOffset_result() throw() {}

  CharOffset success;

  _TokenService_getCharOffset_result__isset __isset;

  void __set_success(const CharOffset& val) {
    success = val;
  }

  bool operator == (const TokenService_getCharOffset_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const TokenService_getCharOffset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getCharOffset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getCharOffset_presult__isset {
  _TokenService_getCharOffset_presult__isset() : success(false) {}
  bool success;
} _TokenService_getCharOffset_presult__isset;

class TokenService_getCharOffset_presult {
 public:


  virtual ~TokenService_getCharOffset_presult() throw() {}

  CharOffset* success;

  _TokenService_getCharOffset_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class TokenService_getConfidence_args {
 public:

  TokenService_getConfidence_args() {
  }

  virtual ~TokenService_getConfidence_args() throw() {}


  bool operator == (const TokenService_getConfidence_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_getConfidence_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getConfidence_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_getConfidence_pargs {
 public:


  virtual ~TokenService_getConfidence_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getConfidence_result__isset {
  _TokenService_getConfidence_result__isset() : success(false) {}
  bool success;
} _TokenService_getConfidence_result__isset;

class TokenService_getConfidence_result {
 public:

  TokenService_getConfidence_result() : success(0) {
  }

  virtual ~TokenService_getConfidence_result() throw() {}

  double success;

  _TokenService_getConfidence_result__isset __isset;

  void __set_success(const double val) {
    success = val;
  }

  bool operator == (const TokenService_getConfidence_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const TokenService_getConfidence_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getConfidence_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getConfidence_presult__isset {
  _TokenService_getConfidence_presult__isset() : success(false) {}
  bool success;
} _TokenService_getConfidence_presult__isset;

class TokenService_getConfidence_presult {
 public:


  virtual ~TokenService_getConfidence_presult() throw() {}

  double* success;

  _TokenService_getConfidence_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class TokenService_getLemma_args {
 public:

  TokenService_getLemma_args() {
  }

  virtual ~TokenService_getLemma_args() throw() {}


  bool operator == (const TokenService_getLemma_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_getLemma_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getLemma_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_getLemma_pargs {
 public:


  virtual ~TokenService_getLemma_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getLemma_result__isset {
  _TokenService_getLemma_result__isset() : success(false) {}
  bool success;
} _TokenService_getLemma_result__isset;

class TokenService_getLemma_result {
 public:

  TokenService_getLemma_result() : success() {
  }

  virtual ~TokenService_getLemma_result() throw() {}

  std::string success;

  _TokenService_getLemma_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const TokenService_getLemma_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const TokenService_getLemma_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getLemma_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getLemma_presult__isset {
  _TokenService_getLemma_presult__isset() : success(false) {}
  bool success;
} _TokenService_getLemma_presult__isset;

class TokenService_getLemma_presult {
 public:


  virtual ~TokenService_getLemma_presult() throw() {}

  std::string* success;

  _TokenService_getLemma_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class TokenService_getSequenceId_args {
 public:

  TokenService_getSequenceId_args() {
  }

  virtual ~TokenService_getSequenceId_args() throw() {}


  bool operator == (const TokenService_getSequenceId_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_getSequenceId_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getSequenceId_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_getSequenceId_pargs {
 public:


  virtual ~TokenService_getSequenceId_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getSequenceId_result__isset {
  _TokenService_getSequenceId_result__isset() : success(false) {}
  bool success;
} _TokenService_getSequenceId_result__isset;

class TokenService_getSequenceId_result {
 public:

  TokenService_getSequenceId_result() : success(0) {
  }

  virtual ~TokenService_getSequenceId_result() throw() {}

  int64_t success;

  _TokenService_getSequenceId_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  bool operator == (const TokenService_getSequenceId_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const TokenService_getSequenceId_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getSequenceId_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getSequenceId_presult__isset {
  _TokenService_getSequenceId_presult__isset() : success(false) {}
  bool success;
} _TokenService_getSequenceId_presult__isset;

class TokenService_getSequenceId_presult {
 public:


  virtual ~TokenService_getSequenceId_presult() throw() {}

  int64_t* success;

  _TokenService_getSequenceId_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class TokenService_getTokenType_args {
 public:

  TokenService_getTokenType_args() {
  }

  virtual ~TokenService_getTokenType_args() throw() {}


  bool operator == (const TokenService_getTokenType_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_getTokenType_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getTokenType_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_getTokenType_pargs {
 public:


  virtual ~TokenService_getTokenType_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getTokenType_result__isset {
  _TokenService_getTokenType_result__isset() : success(false) {}
  bool success;
} _TokenService_getTokenType_result__isset;

class TokenService_getTokenType_result {
 public:

  TokenService_getTokenType_result() : success((TokenType::type)0) {
  }

  virtual ~TokenService_getTokenType_result() throw() {}

  TokenType::type success;

  _TokenService_getTokenType_result__isset __isset;

  void __set_success(const TokenType::type val) {
    success = val;
  }

  bool operator == (const TokenService_getTokenType_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const TokenService_getTokenType_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_getTokenType_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _TokenService_getTokenType_presult__isset {
  _TokenService_getTokenType_presult__isset() : success(false) {}
  bool success;
} _TokenService_getTokenType_presult__isset;

class TokenService_getTokenType_presult {
 public:


  virtual ~TokenService_getTokenType_presult() throw() {}

  TokenType::type* success;

  _TokenService_getTokenType_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TokenService_setAudioOffset_args__isset {
  _TokenService_setAudioOffset_args__isset() : audioOffset(false) {}
  bool audioOffset;
} _TokenService_setAudioOffset_args__isset;

class TokenService_setAudioOffset_args {
 public:

  TokenService_setAudioOffset_args() {
  }

  virtual ~TokenService_setAudioOffset_args() throw() {}

  AudioOffset audioOffset;

  _TokenService_setAudioOffset_args__isset __isset;

  void __set_audioOffset(const AudioOffset& val) {
    audioOffset = val;
  }

  bool operator == (const TokenService_setAudioOffset_args & rhs) const
  {
    if (!(audioOffset == rhs.audioOffset))
      return false;
    return true;
  }
  bool operator != (const TokenService_setAudioOffset_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setAudioOffset_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setAudioOffset_pargs {
 public:


  virtual ~TokenService_setAudioOffset_pargs() throw() {}

  const AudioOffset* audioOffset;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setAudioOffset_result {
 public:

  TokenService_setAudioOffset_result() {
  }

  virtual ~TokenService_setAudioOffset_result() throw() {}


  bool operator == (const TokenService_setAudioOffset_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_setAudioOffset_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setAudioOffset_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setAudioOffset_presult {
 public:


  virtual ~TokenService_setAudioOffset_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TokenService_setConfidence_args__isset {
  _TokenService_setConfidence_args__isset() : confidence(false) {}
  bool confidence;
} _TokenService_setConfidence_args__isset;

class TokenService_setConfidence_args {
 public:

  TokenService_setConfidence_args() : confidence(0) {
  }

  virtual ~TokenService_setConfidence_args() throw() {}

  double confidence;

  _TokenService_setConfidence_args__isset __isset;

  void __set_confidence(const double val) {
    confidence = val;
  }

  bool operator == (const TokenService_setConfidence_args & rhs) const
  {
    if (!(confidence == rhs.confidence))
      return false;
    return true;
  }
  bool operator != (const TokenService_setConfidence_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setConfidence_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setConfidence_pargs {
 public:


  virtual ~TokenService_setConfidence_pargs() throw() {}

  const double* confidence;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setConfidence_result {
 public:

  TokenService_setConfidence_result() {
  }

  virtual ~TokenService_setConfidence_result() throw() {}


  bool operator == (const TokenService_setConfidence_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_setConfidence_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setConfidence_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setConfidence_presult {
 public:


  virtual ~TokenService_setConfidence_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TokenService_setLemma_args__isset {
  _TokenService_setLemma_args__isset() : lemma(false) {}
  bool lemma;
} _TokenService_setLemma_args__isset;

class TokenService_setLemma_args {
 public:

  TokenService_setLemma_args() : lemma() {
  }

  virtual ~TokenService_setLemma_args() throw() {}

  std::string lemma;

  _TokenService_setLemma_args__isset __isset;

  void __set_lemma(const std::string& val) {
    lemma = val;
  }

  bool operator == (const TokenService_setLemma_args & rhs) const
  {
    if (!(lemma == rhs.lemma))
      return false;
    return true;
  }
  bool operator != (const TokenService_setLemma_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setLemma_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setLemma_pargs {
 public:


  virtual ~TokenService_setLemma_pargs() throw() {}

  const std::string* lemma;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setLemma_result {
 public:

  TokenService_setLemma_result() {
  }

  virtual ~TokenService_setLemma_result() throw() {}


  bool operator == (const TokenService_setLemma_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_setLemma_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setLemma_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setLemma_presult {
 public:


  virtual ~TokenService_setLemma_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _TokenService_setTokenType_args__isset {
  _TokenService_setTokenType_args__isset() : tokentype(false) {}
  bool tokentype;
} _TokenService_setTokenType_args__isset;

class TokenService_setTokenType_args {
 public:

  TokenService_setTokenType_args() : tokentype((TokenType::type)0) {
  }

  virtual ~TokenService_setTokenType_args() throw() {}

  TokenType::type tokentype;

  _TokenService_setTokenType_args__isset __isset;

  void __set_tokentype(const TokenType::type val) {
    tokentype = val;
  }

  bool operator == (const TokenService_setTokenType_args & rhs) const
  {
    if (!(tokentype == rhs.tokentype))
      return false;
    return true;
  }
  bool operator != (const TokenService_setTokenType_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setTokenType_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setTokenType_pargs {
 public:


  virtual ~TokenService_setTokenType_pargs() throw() {}

  const TokenType::type* tokentype;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setTokenType_result {
 public:

  TokenService_setTokenType_result() {
  }

  virtual ~TokenService_setTokenType_result() throw() {}


  bool operator == (const TokenService_setTokenType_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TokenService_setTokenType_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenService_setTokenType_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class TokenService_setTokenType_presult {
 public:


  virtual ~TokenService_setTokenType_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class TokenServiceClient : virtual public TokenServiceIf, public ItemServiceClient {
 public:
  TokenServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    ItemServiceClient(prot, prot) {}
  TokenServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    ItemServiceClient(iprot, oprot) {}
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void getAudioOffset(AudioOffset& _return);
  void send_getAudioOffset();
  void recv_getAudioOffset(AudioOffset& _return);
  void getCharOffset(CharOffset& _return);
  void send_getCharOffset();
  void recv_getCharOffset(CharOffset& _return);
  double getConfidence();
  void send_getConfidence();
  double recv_getConfidence();
  void getLemma(std::string& _return);
  void send_getLemma();
  void recv_getLemma(std::string& _return);
  int64_t getSequenceId();
  void send_getSequenceId();
  int64_t recv_getSequenceId();
  TokenType::type getTokenType();
  void send_getTokenType();
  TokenType::type recv_getTokenType();
  void setAudioOffset(const AudioOffset& audioOffset);
  void send_setAudioOffset(const AudioOffset& audioOffset);
  void recv_setAudioOffset();
  void setConfidence(const double confidence);
  void send_setConfidence(const double confidence);
  void recv_setConfidence();
  void setLemma(const std::string& lemma);
  void send_setLemma(const std::string& lemma);
  void recv_setLemma();
  void setTokenType(const TokenType::type tokentype);
  void send_setTokenType(const TokenType::type tokentype);
  void recv_setTokenType();
};

class TokenServiceProcessor : public ItemServiceProcessor {
 protected:
  boost::shared_ptr<TokenServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (TokenServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_getAudioOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getCharOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getConfidence(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getLemma(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getSequenceId(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTokenType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setAudioOffset(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setConfidence(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setLemma(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setTokenType(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  TokenServiceProcessor(boost::shared_ptr<TokenServiceIf> iface) :
    ItemServiceProcessor(iface),
    iface_(iface) {
    processMap_["getAudioOffset"] = &TokenServiceProcessor::process_getAudioOffset;
    processMap_["getCharOffset"] = &TokenServiceProcessor::process_getCharOffset;
    processMap_["getConfidence"] = &TokenServiceProcessor::process_getConfidence;
    processMap_["getLemma"] = &TokenServiceProcessor::process_getLemma;
    processMap_["getSequenceId"] = &TokenServiceProcessor::process_getSequenceId;
    processMap_["getTokenType"] = &TokenServiceProcessor::process_getTokenType;
    processMap_["setAudioOffset"] = &TokenServiceProcessor::process_setAudioOffset;
    processMap_["setConfidence"] = &TokenServiceProcessor::process_setConfidence;
    processMap_["setLemma"] = &TokenServiceProcessor::process_setLemma;
    processMap_["setTokenType"] = &TokenServiceProcessor::process_setTokenType;
  }

  virtual ~TokenServiceProcessor() {}
};

class TokenServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  TokenServiceProcessorFactory(const ::boost::shared_ptr< TokenServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< TokenServiceIfFactory > handlerFactory_;
};

class TokenServiceMultiface : virtual public TokenServiceIf, public ItemServiceMultiface {
 public:
  TokenServiceMultiface(std::vector<boost::shared_ptr<TokenServiceIf> >& ifaces) : ifaces_(ifaces) {
    std::vector<boost::shared_ptr<TokenServiceIf> >::iterator iter;
    for (iter = ifaces.begin(); iter != ifaces.end(); ++iter) {
      ItemServiceMultiface::add(*iter);
    }
  }
  virtual ~TokenServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<TokenServiceIf> > ifaces_;
  TokenServiceMultiface() {}
  void add(boost::shared_ptr<TokenServiceIf> iface) {
    ItemServiceMultiface::add(iface);
    ifaces_.push_back(iface);
  }
 public:
  void getAudioOffset(AudioOffset& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getAudioOffset(_return);
    }
    ifaces_[i]->getAudioOffset(_return);
    return;
  }

  void getCharOffset(CharOffset& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getCharOffset(_return);
    }
    ifaces_[i]->getCharOffset(_return);
    return;
  }

  double getConfidence() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getConfidence();
    }
    return ifaces_[i]->getConfidence();
  }

  void getLemma(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getLemma(_return);
    }
    ifaces_[i]->getLemma(_return);
    return;
  }

  int64_t getSequenceId() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getSequenceId();
    }
    return ifaces_[i]->getSequenceId();
  }

  TokenType::type getTokenType() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTokenType();
    }
    return ifaces_[i]->getTokenType();
  }

  void setAudioOffset(const AudioOffset& audioOffset) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setAudioOffset(audioOffset);
    }
    ifaces_[i]->setAudioOffset(audioOffset);
  }

  void setConfidence(const double confidence) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setConfidence(confidence);
    }
    ifaces_[i]->setConfidence(confidence);
  }

  void setLemma(const std::string& lemma) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setLemma(lemma);
    }
    ifaces_[i]->setLemma(lemma);
  }

  void setTokenType(const TokenType::type tokentype) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setTokenType(tokentype);
    }
    ifaces_[i]->setTokenType(tokentype);
  }

};

}}} // namespace

#endif