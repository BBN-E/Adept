/*******************************************************************************
 * Raytheon BBN Technologies Corp., December 2014
 * 
 * THIS CODE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * Copyright 2014 Raytheon BBN Technologies Corp.  All Rights Reserved.
 ******************************************************************************/
/**
 * 
 */

/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef io_TYPES_H
#define io_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "common_types.h"


namespace thrift { namespace adept { namespace io {

typedef struct _EREDocument__isset {
  _EREDocument__isset() : document(false), charMapping(false), charToTokenOffset(false), startIndices(false), endIndices(false), entityMentionsById(false), canonicalEntityMentionsById(false), isProxy(false), eventsById(false) {}
  bool document;
  bool charMapping;
  bool charToTokenOffset;
  bool startIndices;
  bool endIndices;
  bool entityMentionsById;
  bool canonicalEntityMentionsById;
  bool isProxy;
  bool eventsById;
} _EREDocument__isset;

class EREDocument {
 public:

  static const char* ascii_fingerprint; // = "20590C88CFB1BE03A1F6EBBDAA4F87F3";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x59,0x0C,0x88,0xCF,0xB1,0xBE,0x03,0xA1,0xF6,0xEB,0xBD,0xAA,0x4F,0x87,0xF3};

  EREDocument() : fullText(), isProxy(0) {
  }

  virtual ~EREDocument() throw() {}

  std::string fullText;
   ::thrift::adept::common::Document document;
  std::map<int64_t, int64_t>  charMapping;
  std::map<int64_t, int64_t>  charToTokenOffset;
  std::vector<int32_t>  startIndices;
  std::vector<int32_t>  endIndices;
  std::map<int64_t,  ::thrift::adept::common::EntityMention>  entityMentionsById;
  std::map<int64_t,  ::thrift::adept::common::EntityMention>  canonicalEntityMentionsById;
  bool isProxy;
  std::map<int64_t, std::vector< ::thrift::adept::common::Event> >  eventsById;

  _EREDocument__isset __isset;

  void __set_fullText(const std::string& val) {
    fullText = val;
  }

  void __set_document(const  ::thrift::adept::common::Document& val) {
    document = val;
  }

  void __set_charMapping(const std::map<int64_t, int64_t> & val) {
    charMapping = val;
  }

  void __set_charToTokenOffset(const std::map<int64_t, int64_t> & val) {
    charToTokenOffset = val;
  }

  void __set_startIndices(const std::vector<int32_t> & val) {
    startIndices = val;
  }

  void __set_endIndices(const std::vector<int32_t> & val) {
    endIndices = val;
  }

  void __set_entityMentionsById(const std::map<int64_t,  ::thrift::adept::common::EntityMention> & val) {
    entityMentionsById = val;
  }

  void __set_canonicalEntityMentionsById(const std::map<int64_t,  ::thrift::adept::common::EntityMention> & val) {
    canonicalEntityMentionsById = val;
  }

  void __set_isProxy(const bool val) {
    isProxy = val;
  }

  void __set_eventsById(const std::map<int64_t, std::vector< ::thrift::adept::common::Event> > & val) {
    eventsById = val;
  }

  bool operator == (const EREDocument & rhs) const
  {
    if (!(fullText == rhs.fullText))
      return false;
    if (!(document == rhs.document))
      return false;
    if (!(charMapping == rhs.charMapping))
      return false;
    if (!(charToTokenOffset == rhs.charToTokenOffset))
      return false;
    if (!(startIndices == rhs.startIndices))
      return false;
    if (!(endIndices == rhs.endIndices))
      return false;
    if (!(entityMentionsById == rhs.entityMentionsById))
      return false;
    if (!(canonicalEntityMentionsById == rhs.canonicalEntityMentionsById))
      return false;
    if (!(isProxy == rhs.isProxy))
      return false;
    if (!(eventsById == rhs.eventsById))
      return false;
    return true;
  }
  bool operator != (const EREDocument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EREDocument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EREDocument &a, EREDocument &b);

typedef struct _CoNLLDocument__isset {
  _CoNLLDocument__isset() : document(false), wordNums(false), tokens(false), POSs(false), namedEntities(false), corefs(false), tokensToPOSs(false) {}
  bool document;
  bool wordNums;
  bool tokens;
  bool POSs;
  bool namedEntities;
  bool corefs;
  bool tokensToPOSs;
} _CoNLLDocument__isset;

class CoNLLDocument {
 public:

  static const char* ascii_fingerprint; // = "689DB8F9C69E647441881CA05C60E136";
  static const uint8_t binary_fingerprint[16]; // = {0x68,0x9D,0xB8,0xF9,0xC6,0x9E,0x64,0x74,0x41,0x88,0x1C,0xA0,0x5C,0x60,0xE1,0x36};

  CoNLLDocument() : fullText() {
  }

  virtual ~CoNLLDocument() throw() {}

  std::string fullText;
   ::thrift::adept::common::Document document;
  std::vector<std::vector<int32_t> >  wordNums;
  std::vector<std::vector<std::string> >  tokens;
  std::vector<std::vector<std::string> >  POSs;
  std::vector<std::map<std::string, int64_t> >  namedEntities;
  std::vector<std::vector<std::vector<int64_t> > >  corefs;
  std::map< ::thrift::adept::common::Token, std::string>  tokensToPOSs;

  _CoNLLDocument__isset __isset;

  void __set_fullText(const std::string& val) {
    fullText = val;
  }

  void __set_document(const  ::thrift::adept::common::Document& val) {
    document = val;
  }

  void __set_wordNums(const std::vector<std::vector<int32_t> > & val) {
    wordNums = val;
  }

  void __set_tokens(const std::vector<std::vector<std::string> > & val) {
    tokens = val;
  }

  void __set_POSs(const std::vector<std::vector<std::string> > & val) {
    POSs = val;
  }

  void __set_namedEntities(const std::vector<std::map<std::string, int64_t> > & val) {
    namedEntities = val;
  }

  void __set_corefs(const std::vector<std::vector<std::vector<int64_t> > > & val) {
    corefs = val;
  }

  void __set_tokensToPOSs(const std::map< ::thrift::adept::common::Token, std::string> & val) {
    tokensToPOSs = val;
  }

  bool operator == (const CoNLLDocument & rhs) const
  {
    if (!(fullText == rhs.fullText))
      return false;
    if (!(document == rhs.document))
      return false;
    if (!(wordNums == rhs.wordNums))
      return false;
    if (!(tokens == rhs.tokens))
      return false;
    if (!(POSs == rhs.POSs))
      return false;
    if (!(namedEntities == rhs.namedEntities))
      return false;
    if (!(corefs == rhs.corefs))
      return false;
    if (!(tokensToPOSs == rhs.tokensToPOSs))
      return false;
    return true;
  }
  bool operator != (const CoNLLDocument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CoNLLDocument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CoNLLDocument &a, CoNLLDocument &b);

}}} // namespace

#endif
