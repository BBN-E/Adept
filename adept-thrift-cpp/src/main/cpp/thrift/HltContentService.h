/*******************************************************************************
 * Raytheon BBN Technologies Corp., December 2014
 * 
 * THIS CODE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * Copyright 2014 Raytheon BBN Technologies Corp.  All Rights Reserved.
 ******************************************************************************/
/**
 * 
 */

/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef HltContentService_H
#define HltContentService_H

#include <thrift/TDispatchProcessor.h>
#include "common_types.h"
#include "ItemService.h"

namespace thrift { namespace adept { namespace common {

class HltContentServiceIf : virtual public ItemServiceIf {
 public:
  virtual ~HltContentServiceIf() {}
};

class HltContentServiceIfFactory : virtual public ItemServiceIfFactory {
 public:
  typedef HltContentServiceIf Handler;

  virtual ~HltContentServiceIfFactory() {}

  virtual HltContentServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ItemServiceIf* /* handler */) = 0;
};

class HltContentServiceIfSingletonFactory : virtual public HltContentServiceIfFactory {
 public:
  HltContentServiceIfSingletonFactory(const boost::shared_ptr<HltContentServiceIf>& iface) : iface_(iface) {}
  virtual ~HltContentServiceIfSingletonFactory() {}

  virtual HltContentServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ItemServiceIf* /* handler */) {}

 protected:
  boost::shared_ptr<HltContentServiceIf> iface_;
};

class HltContentServiceNull : virtual public HltContentServiceIf , virtual public ItemServiceNull {
 public:
  virtual ~HltContentServiceNull() {}
};

class HltContentServiceClient : virtual public HltContentServiceIf, public ItemServiceClient {
 public:
  HltContentServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    ItemServiceClient(prot, prot) {}
  HltContentServiceClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    ItemServiceClient(iprot, oprot) {}
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
};

class HltContentServiceProcessor : public ItemServiceProcessor {
 protected:
  boost::shared_ptr<HltContentServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (HltContentServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
 public:
  HltContentServiceProcessor(boost::shared_ptr<HltContentServiceIf> iface) :
    ItemServiceProcessor(iface),
    iface_(iface) {
  }

  virtual ~HltContentServiceProcessor() {}
};

class HltContentServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HltContentServiceProcessorFactory(const ::boost::shared_ptr< HltContentServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< HltContentServiceIfFactory > handlerFactory_;
};

class HltContentServiceMultiface : virtual public HltContentServiceIf, public ItemServiceMultiface {
 public:
  HltContentServiceMultiface(std::vector<boost::shared_ptr<HltContentServiceIf> >& ifaces) : ifaces_(ifaces) {
    std::vector<boost::shared_ptr<HltContentServiceIf> >::iterator iter;
    for (iter = ifaces.begin(); iter != ifaces.end(); ++iter) {
      ItemServiceMultiface::add(*iter);
    }
  }
  virtual ~HltContentServiceMultiface() {}
 protected:
  std::vector<boost::shared_ptr<HltContentServiceIf> > ifaces_;
  HltContentServiceMultiface() {}
  void add(boost::shared_ptr<HltContentServiceIf> iface) {
    ItemServiceMultiface::add(iface);
    ifaces_.push_back(iface);
  }
 public:
};

}}} // namespace

#endif
