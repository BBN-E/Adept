/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef common_TYPES_H
#define common_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>



namespace thrift { namespace adept { namespace common {

struct Polarity {
  enum type {
    POSITIVE = 0,
    NEGATIVE = 1,
    NEUTRAL = 2
  };
};

extern const std::map<int, const char*> _Polarity_VALUES_TO_NAMES;

struct TopicPolarity {
  enum type {
    POSITIVE = 0,
    NEGATIVE = 1,
    NONE = 2
  };
};

extern const std::map<int, const char*> _TopicPolarity_VALUES_TO_NAMES;

struct AsrName {
  enum type {
    NONE = 0,
    LDC = 1,
    BBN = 2
  };
};

extern const std::map<int, const char*> _AsrName_VALUES_TO_NAMES;

struct AudioFileType {
  enum type {
    WAV = 0,
    MP3 = 1,
    SPH = 2
  };
};

extern const std::map<int, const char*> _AudioFileType_VALUES_TO_NAMES;

struct ChannelName {
  enum type {
    NONE = 0,
    LEFT_STEREO = 1,
    RIGHT_STEREO = 2,
    MONO = 3
  };
};

extern const std::map<int, const char*> _ChannelName_VALUES_TO_NAMES;

struct ContentType {
  enum type {
    TEXT = 0,
    SPEECH = 1
  };
};

extern const std::map<int, const char*> _ContentType_VALUES_TO_NAMES;

struct EntailmentJudgment {
  enum type {
    ENTAILS = 0,
    CONTRADICTS = 1,
    NOT_RELATED = 2
  };
};

extern const std::map<int, const char*> _EntailmentJudgment_VALUES_TO_NAMES;

struct Modality {
  enum type {
    ABILITY = 0,
    EFFORT = 1,
    INTENTION = 2,
    SUCCESS = 3,
    WANT = 4,
    COMMITTED_BELIEF = 5,
    NON_COMMITTED_BELIEF = 6,
    NON_ATTRIBUTABLE_BELIEF = 7
  };
};

extern const std::map<int, const char*> _Modality_VALUES_TO_NAMES;

struct SarcasmJudgment {
  enum type {
    POSITIVE = 0,
    NEGATIVE = 1,
    NONE = 2
  };
};

extern const std::map<int, const char*> _SarcasmJudgment_VALUES_TO_NAMES;

struct SentenceType {
  enum type {
    NONE = 0,
    STATEMENT = 1,
    QUESTION = 2,
    INCOMPLETE = 3,
    CLAUSE = 4
  };
};

extern const std::map<int, const char*> _SentenceType_VALUES_TO_NAMES;

struct SpeechUnit {
  enum type {
    NONE = 0,
    WORD = 1,
    PHONEME = 2
  };
};

extern const std::map<int, const char*> _SpeechUnit_VALUES_TO_NAMES;

struct Subjectivity {
  enum type {
    SUBJECTIVE = 0,
    OBJECTIVE = 1,
    NONE = 2
  };
};

extern const std::map<int, const char*> _Subjectivity_VALUES_TO_NAMES;

struct TokenType {
  enum type {
    WORD = 0,
    PUNCTUATION = 1,
    GARBAGE = 2,
    LEXEME = 3,
    PAUSE_FILLER = 4,
    LAUGHTER = 5,
    SILENCE = 6,
    MUSIC = 7,
    TAG = 8,
    OTHER = 9
  };
};

extern const std::map<int, const char*> _TokenType_VALUES_TO_NAMES;

struct TokenizerType {
  enum type {
    ADEPT = 0,
    STANFORD_CORENLP = 1,
    UMASS = 2,
    WHITESPACE = 3,
    OTHER = 4
  };
};

extern const std::map<int, const char*> _TokenizerType_VALUES_TO_NAMES;

struct TranscriptType {
  enum type {
    SOURCE = 0,
    TRANSLATION = 1
  };
};

extern const std::map<int, const char*> _TranscriptType_VALUES_TO_NAMES;

struct TranslatorName {
  enum type {
    NONE = 0,
    SDL_LW = 1
  };
};

extern const std::map<int, const char*> _TranslatorName_VALUES_TO_NAMES;

struct TranslatorType {
  enum type {
    NONE = 0,
    SDL_LW = 1
  };
};

extern const std::map<int, const char*> _TranslatorType_VALUES_TO_NAMES;

typedef struct _EmailAddress__isset {
  _EmailAddress__isset() : address(false), displayName(false) {}
  bool address;
  bool displayName;
} _EmailAddress__isset;

class EmailAddress {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  EmailAddress() : address(), displayName() {
  }

  virtual ~EmailAddress() throw() {}

  std::string address;
  std::string displayName;

  _EmailAddress__isset __isset;

  void __set_address(const std::string& val) {
    address = val;
  }

  void __set_displayName(const std::string& val) {
    displayName = val;
  }

  bool operator == (const EmailAddress & rhs) const
  {
    if (!(address == rhs.address))
      return false;
    if (!(displayName == rhs.displayName))
      return false;
    return true;
  }
  bool operator != (const EmailAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EmailAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EmailAddress &a, EmailAddress &b);

typedef struct _ID__isset {
  _ID__isset() : id(false), idStr(false), MAX_ID(false), MIN_ID(false) {}
  bool id;
  bool idStr;
  bool MAX_ID;
  bool MIN_ID;
} _ID__isset;

class ID {
 public:

  static const char* ascii_fingerprint; // = "50272E49E7C02012722B8F62131C940B";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x27,0x2E,0x49,0xE7,0xC0,0x20,0x12,0x72,0x2B,0x8F,0x62,0x13,0x1C,0x94,0x0B};

  ID() : id(), idStr(), MAX_ID(0), MIN_ID(0) {
  }

  virtual ~ID() throw() {}

  std::string id;
  std::string idStr;
  int64_t MAX_ID;
  int64_t MIN_ID;

  _ID__isset __isset;

  void __set_id(const std::string& val) {
    id = val;
  }

  void __set_idStr(const std::string& val) {
    idStr = val;
  }

  void __set_MAX_ID(const int64_t val) {
    MAX_ID = val;
  }

  void __set_MIN_ID(const int64_t val) {
    MIN_ID = val;
  }

  bool operator == (const ID & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(idStr == rhs.idStr))
      return false;
    if (!(MAX_ID == rhs.MAX_ID))
      return false;
    if (!(MIN_ID == rhs.MIN_ID))
      return false;
    return true;
  }
  bool operator != (const ID &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ID & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ID &a, ID &b);

typedef struct _LanguageIdentification__isset {
  _LanguageIdentification__isset() : languageProbabilityDistribution(false), id(false), value(false) {}
  bool languageProbabilityDistribution;
  bool id;
  bool value;
} _LanguageIdentification__isset;

class LanguageIdentification {
 public:

  static const char* ascii_fingerprint; // = "3A0A4D3F88A437AC8F1C7B1E5645D2ED";
  static const uint8_t binary_fingerprint[16]; // = {0x3A,0x0A,0x4D,0x3F,0x88,0xA4,0x37,0xAC,0x8F,0x1C,0x7B,0x1E,0x56,0x45,0xD2,0xED};

  LanguageIdentification() : value() {
  }

  virtual ~LanguageIdentification() throw() {}

  std::map<std::string, double>  languageProbabilityDistribution;
  ID id;
  std::string value;

  _LanguageIdentification__isset __isset;

  void __set_languageProbabilityDistribution(const std::map<std::string, double> & val) {
    languageProbabilityDistribution = val;
  }

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const LanguageIdentification & rhs) const
  {
    if (!(languageProbabilityDistribution == rhs.languageProbabilityDistribution))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const LanguageIdentification &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LanguageIdentification & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LanguageIdentification &a, LanguageIdentification &b);

typedef struct _Item__isset {
  _Item__isset() : id(false), value(false) {}
  bool id;
  bool value;
} _Item__isset;

class Item {
 public:

  static const char* ascii_fingerprint; // = "B4C8E7B3C61A8F148CF6AE923592490C";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0xC8,0xE7,0xB3,0xC6,0x1A,0x8F,0x14,0x8C,0xF6,0xAE,0x92,0x35,0x92,0x49,0x0C};

  Item() : value() {
  }

  virtual ~Item() throw() {}

  ID id;
  std::string value;

  _Item__isset __isset;

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const Item & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Item &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Item & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Item &a, Item &b);


class TokenOffset {
 public:

  static const char* ascii_fingerprint; // = "F33135321253DAEB67B0E79E416CA831";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

  TokenOffset() : beginIndex(0), endIndex(0) {
  }

  virtual ~TokenOffset() throw() {}

  int64_t beginIndex;
  int64_t endIndex;

  void __set_beginIndex(const int64_t val) {
    beginIndex = val;
  }

  void __set_endIndex(const int64_t val) {
    endIndex = val;
  }

  bool operator == (const TokenOffset & rhs) const
  {
    if (!(beginIndex == rhs.beginIndex))
      return false;
    if (!(endIndex == rhs.endIndex))
      return false;
    return true;
  }
  bool operator != (const TokenOffset &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenOffset & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TokenOffset &a, TokenOffset &b);

typedef struct _TokenOffsetObject__isset {
  _TokenOffsetObject__isset() : tokenOffset(false) {}
  bool tokenOffset;
} _TokenOffsetObject__isset;

class TokenOffsetObject {
 public:

  static const char* ascii_fingerprint; // = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

  TokenOffsetObject() {
  }

  virtual ~TokenOffsetObject() throw() {}

  TokenOffset tokenOffset;

  _TokenOffsetObject__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  bool operator == (const TokenOffsetObject & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    return true;
  }
  bool operator != (const TokenOffsetObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenOffsetObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TokenOffsetObject &a, TokenOffsetObject &b);

typedef struct _Corpus__isset {
  _Corpus__isset() : id(false) {}
  bool id;
} _Corpus__isset;

class Corpus {
 public:

  static const char* ascii_fingerprint; // = "099833CCB2DCA3002B546E64AE341C2F";
  static const uint8_t binary_fingerprint[16]; // = {0x09,0x98,0x33,0xCC,0xB2,0xDC,0xA3,0x00,0x2B,0x54,0x6E,0x64,0xAE,0x34,0x1C,0x2F};

  Corpus() : corpusId(), type(), name(), uri() {
  }

  virtual ~Corpus() throw() {}

  std::string corpusId;
  std::string type;
  std::string name;
  std::string uri;
  ID id;

  _Corpus__isset __isset;

  void __set_corpusId(const std::string& val) {
    corpusId = val;
  }

  void __set_type(const std::string& val) {
    type = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_uri(const std::string& val) {
    uri = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  bool operator == (const Corpus & rhs) const
  {
    if (!(corpusId == rhs.corpusId))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(uri == rhs.uri))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Corpus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Corpus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Corpus &a, Corpus &b);

typedef struct _Document__isset {
  _Document__isset() : audioUri(false), genre(false), headline(false), id(false), value(false) {}
  bool audioUri;
  bool genre;
  bool headline;
  bool id;
  bool value;
} _Document__isset;

class Document {
 public:

  static const char* ascii_fingerprint; // = "3E3409FCC20AAA11F5A77574D10F1BC1";
  static const uint8_t binary_fingerprint[16]; // = {0x3E,0x34,0x09,0xFC,0xC2,0x0A,0xAA,0x11,0xF5,0xA7,0x75,0x74,0xD1,0x0F,0x1B,0xC1};

  Document() : docId(), docType(), uri(), language(), audioUri(), genre(), headline(), value() {
  }

  virtual ~Document() throw() {}

  std::string docId;
  Corpus corpus;
  std::string docType;
  std::string uri;
  std::string language;
  std::string audioUri;
  std::string genre;
  std::string headline;
  ID id;
  std::string value;

  _Document__isset __isset;

  void __set_docId(const std::string& val) {
    docId = val;
  }

  void __set_corpus(const Corpus& val) {
    corpus = val;
  }

  void __set_docType(const std::string& val) {
    docType = val;
  }

  void __set_uri(const std::string& val) {
    uri = val;
  }

  void __set_language(const std::string& val) {
    language = val;
  }

  void __set_audioUri(const std::string& val) {
    audioUri = val;
    __isset.audioUri = true;
  }

  void __set_genre(const std::string& val) {
    genre = val;
    __isset.genre = true;
  }

  void __set_headline(const std::string& val) {
    headline = val;
    __isset.headline = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const Document & rhs) const
  {
    if (!(docId == rhs.docId))
      return false;
    if (!(corpus == rhs.corpus))
      return false;
    if (!(docType == rhs.docType))
      return false;
    if (!(uri == rhs.uri))
      return false;
    if (!(language == rhs.language))
      return false;
    if (__isset.audioUri != rhs.__isset.audioUri)
      return false;
    else if (__isset.audioUri && !(audioUri == rhs.audioUri))
      return false;
    if (__isset.genre != rhs.__isset.genre)
      return false;
    else if (__isset.genre && !(genre == rhs.genre))
      return false;
    if (__isset.headline != rhs.__isset.headline)
      return false;
    else if (__isset.headline && !(headline == rhs.headline))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Document &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Document & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Document &a, Document &b);

typedef struct _DocumentList__isset {
  _DocumentList__isset() : id(false), serialVersionUID(true) {}
  bool id;
  bool serialVersionUID;
} _DocumentList__isset;

class DocumentList {
 public:

  static const char* ascii_fingerprint; // = "B2B923FC6CA362F42AA820E6B5B95B7E";
  static const uint8_t binary_fingerprint[16]; // = {0xB2,0xB9,0x23,0xFC,0x6C,0xA3,0x62,0xF4,0x2A,0xA8,0x20,0xE6,0xB5,0xB9,0x5B,0x7E};

  DocumentList() : serialVersionUID(651655831447893195LL) {
  }

  virtual ~DocumentList() throw() {}

  ID id;
  int64_t serialVersionUID;

  _DocumentList__isset __isset;

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_serialVersionUID(const int64_t val) {
    serialVersionUID = val;
  }

  bool operator == (const DocumentList & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(serialVersionUID == rhs.serialVersionUID))
      return false;
    return true;
  }
  bool operator != (const DocumentList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DocumentList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DocumentList &a, DocumentList &b);


class AudioOffset {
 public:

  static const char* ascii_fingerprint; // = "EA2086D2BB14222991D7B0497DE7B58B";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x20,0x86,0xD2,0xBB,0x14,0x22,0x29,0x91,0xD7,0xB0,0x49,0x7D,0xE7,0xB5,0x8B};

  AudioOffset() : beginIndex(0), endIndex(0) {
  }

  virtual ~AudioOffset() throw() {}

  double beginIndex;
  double endIndex;

  void __set_beginIndex(const double val) {
    beginIndex = val;
  }

  void __set_endIndex(const double val) {
    endIndex = val;
  }

  bool operator == (const AudioOffset & rhs) const
  {
    if (!(beginIndex == rhs.beginIndex))
      return false;
    if (!(endIndex == rhs.endIndex))
      return false;
    return true;
  }
  bool operator != (const AudioOffset &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AudioOffset & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AudioOffset &a, AudioOffset &b);

typedef struct _Audio__isset {
  _Audio__isset() : uri(false), audioBuffer(false), audioType(false), timeSpan(false) {}
  bool uri;
  bool audioBuffer;
  bool audioType;
  bool timeSpan;
} _Audio__isset;

class Audio {
 public:

  static const char* ascii_fingerprint; // = "FE1D49D498DAE06E02274F9D1F519995";
  static const uint8_t binary_fingerprint[16]; // = {0xFE,0x1D,0x49,0xD4,0x98,0xDA,0xE0,0x6E,0x02,0x27,0x4F,0x9D,0x1F,0x51,0x99,0x95};

  Audio() : uri(), audioBuffer(), audioType((AudioFileType::type)0) {
  }

  virtual ~Audio() throw() {}

  std::string uri;
  std::string audioBuffer;
  AudioFileType::type audioType;
  AudioOffset timeSpan;

  _Audio__isset __isset;

  void __set_uri(const std::string& val) {
    uri = val;
  }

  void __set_audioBuffer(const std::string& val) {
    audioBuffer = val;
  }

  void __set_audioType(const AudioFileType::type val) {
    audioType = val;
  }

  void __set_timeSpan(const AudioOffset& val) {
    timeSpan = val;
  }

  bool operator == (const Audio & rhs) const
  {
    if (!(uri == rhs.uri))
      return false;
    if (!(audioBuffer == rhs.audioBuffer))
      return false;
    if (!(audioType == rhs.audioType))
      return false;
    if (!(timeSpan == rhs.timeSpan))
      return false;
    return true;
  }
  bool operator != (const Audio &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Audio & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Audio &a, Audio &b);


class CharOffset {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  CharOffset() : beginIndex(0), endIndex(0) {
  }

  virtual ~CharOffset() throw() {}

  int32_t beginIndex;
  int32_t endIndex;

  void __set_beginIndex(const int32_t val) {
    beginIndex = val;
  }

  void __set_endIndex(const int32_t val) {
    endIndex = val;
  }

  bool operator == (const CharOffset & rhs) const
  {
    if (!(beginIndex == rhs.beginIndex))
      return false;
    if (!(endIndex == rhs.endIndex))
      return false;
    return true;
  }
  bool operator != (const CharOffset &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CharOffset & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CharOffset &a, CharOffset &b);

typedef struct _Token__isset {
  _Token__isset() : audioOffset(false), confidence(false), lemma(false), tokenType(false), id(false) {}
  bool audioOffset;
  bool confidence;
  bool lemma;
  bool tokenType;
  bool id;
} _Token__isset;

class Token {
 public:

  static const char* ascii_fingerprint; // = "B4F83E4C381C4B9785883D4072CF552B";
  static const uint8_t binary_fingerprint[16]; // = {0xB4,0xF8,0x3E,0x4C,0x38,0x1C,0x4B,0x97,0x85,0x88,0x3D,0x40,0x72,0xCF,0x55,0x2B};

  Token() : sequenceId(0), value(), confidence(0), lemma(), tokenType((TokenType::type)0) {
  }

  virtual ~Token() throw() {}

  int64_t sequenceId;
  CharOffset charOffset;
  std::string value;
  AudioOffset audioOffset;
  double confidence;
  std::string lemma;
  TokenType::type tokenType;
  ID id;

  _Token__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_audioOffset(const AudioOffset& val) {
    audioOffset = val;
    __isset.audioOffset = true;
  }

  void __set_confidence(const double val) {
    confidence = val;
    __isset.confidence = true;
  }

  void __set_lemma(const std::string& val) {
    lemma = val;
    __isset.lemma = true;
  }

  void __set_tokenType(const TokenType::type val) {
    tokenType = val;
    __isset.tokenType = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  bool operator == (const Token & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(charOffset == rhs.charOffset))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.audioOffset != rhs.__isset.audioOffset)
      return false;
    else if (__isset.audioOffset && !(audioOffset == rhs.audioOffset))
      return false;
    if (__isset.confidence != rhs.__isset.confidence)
      return false;
    else if (__isset.confidence && !(confidence == rhs.confidence))
      return false;
    if (__isset.lemma != rhs.__isset.lemma)
      return false;
    else if (__isset.lemma && !(lemma == rhs.lemma))
      return false;
    if (__isset.tokenType != rhs.__isset.tokenType)
      return false;
    else if (__isset.tokenType && !(tokenType == rhs.tokenType))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Token &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Token & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Token &a, Token &b);


class Tag {
 public:

  static const char* ascii_fingerprint; // = "85A7790D72F1BC675F7124B6C1C15D82";
  static const uint8_t binary_fingerprint[16]; // = {0x85,0xA7,0x79,0x0D,0x72,0xF1,0xBC,0x67,0x5F,0x71,0x24,0xB6,0xC1,0xC1,0x5D,0x82};

  Tag() : tagName() {
  }

  virtual ~Tag() throw() {}

  std::string tagName;
  std::map<std::string, Token>  attributes;
  CharOffset charOffset;

  void __set_tagName(const std::string& val) {
    tagName = val;
  }

  void __set_attributes(const std::map<std::string, Token> & val) {
    attributes = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
  }

  bool operator == (const Tag & rhs) const
  {
    if (!(tagName == rhs.tagName))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    if (!(charOffset == rhs.charOffset))
      return false;
    return true;
  }
  bool operator != (const Tag &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tag & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Tag &a, Tag &b);

typedef struct _TokenStream__isset {
  _TokenStream__isset() : asrName(false), document(false), serialVersionUID(true), speechUnit(false), translatorName(false), tokenList(false) {}
  bool asrName;
  bool document;
  bool serialVersionUID;
  bool speechUnit;
  bool translatorName;
  bool tokenList;
} _TokenStream__isset;

class TokenStream {
 public:

  static const char* ascii_fingerprint; // = "664C4D2BE01E88B4A9D98E2757EDACB0";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0x4C,0x4D,0x2B,0xE0,0x1E,0x88,0xB4,0xA9,0xD9,0x8E,0x27,0x57,0xED,0xAC,0xB0};

  TokenStream() : tokenizerType((TokenizerType::type)0), transcriptType((TranscriptType::type)0), language(), channelName((ChannelName::type)0), contentType((ContentType::type)0), textValue(), asrName((AsrName::type)0), serialVersionUID(2407040331925099456LL), speechUnit((SpeechUnit::type)0), translatorName((TranslatorName::type)0) {
  }

  virtual ~TokenStream() throw() {}

  TokenizerType::type tokenizerType;
  TranscriptType::type transcriptType;
  std::string language;
  ChannelName::type channelName;
  ContentType::type contentType;
  std::string textValue;
  AsrName::type asrName;
  Document document;
  int64_t serialVersionUID;
  SpeechUnit::type speechUnit;
  TranslatorName::type translatorName;
  std::vector<Token>  tokenList;

  _TokenStream__isset __isset;

  void __set_tokenizerType(const TokenizerType::type val) {
    tokenizerType = val;
  }

  void __set_transcriptType(const TranscriptType::type val) {
    transcriptType = val;
  }

  void __set_language(const std::string& val) {
    language = val;
  }

  void __set_channelName(const ChannelName::type val) {
    channelName = val;
  }

  void __set_contentType(const ContentType::type val) {
    contentType = val;
  }

  void __set_textValue(const std::string& val) {
    textValue = val;
  }

  void __set_asrName(const AsrName::type val) {
    asrName = val;
    __isset.asrName = true;
  }

  void __set_document(const Document& val) {
    document = val;
    __isset.document = true;
  }

  void __set_serialVersionUID(const int64_t val) {
    serialVersionUID = val;
    __isset.serialVersionUID = true;
  }

  void __set_speechUnit(const SpeechUnit::type val) {
    speechUnit = val;
    __isset.speechUnit = true;
  }

  void __set_translatorName(const TranslatorName::type val) {
    translatorName = val;
    __isset.translatorName = true;
  }

  void __set_tokenList(const std::vector<Token> & val) {
    tokenList = val;
    __isset.tokenList = true;
  }

  bool operator == (const TokenStream & rhs) const
  {
    if (!(tokenizerType == rhs.tokenizerType))
      return false;
    if (!(transcriptType == rhs.transcriptType))
      return false;
    if (!(language == rhs.language))
      return false;
    if (!(channelName == rhs.channelName))
      return false;
    if (!(contentType == rhs.contentType))
      return false;
    if (!(textValue == rhs.textValue))
      return false;
    if (__isset.asrName != rhs.__isset.asrName)
      return false;
    else if (__isset.asrName && !(asrName == rhs.asrName))
      return false;
    if (__isset.document != rhs.__isset.document)
      return false;
    else if (__isset.document && !(document == rhs.document))
      return false;
    if (__isset.serialVersionUID != rhs.__isset.serialVersionUID)
      return false;
    else if (__isset.serialVersionUID && !(serialVersionUID == rhs.serialVersionUID))
      return false;
    if (__isset.speechUnit != rhs.__isset.speechUnit)
      return false;
    else if (__isset.speechUnit && !(speechUnit == rhs.speechUnit))
      return false;
    if (__isset.translatorName != rhs.__isset.translatorName)
      return false;
    else if (__isset.translatorName && !(translatorName == rhs.translatorName))
      return false;
    if (__isset.tokenList != rhs.__isset.tokenList)
      return false;
    else if (__isset.tokenList && !(tokenList == rhs.tokenList))
      return false;
    return true;
  }
  bool operator != (const TokenStream &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenStream & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TokenStream &a, TokenStream &b);

typedef struct _Arc__isset {
  _Arc__isset() : source(false), destination(false), token(false), weight(false) {}
  bool source;
  bool destination;
  bool token;
  bool weight;
} _Arc__isset;

class Arc {
 public:

  static const char* ascii_fingerprint; // = "FBD83E72059D3D39148456E9B8B7F463";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0xD8,0x3E,0x72,0x05,0x9D,0x3D,0x39,0x14,0x84,0x56,0xE9,0xB8,0xB7,0xF4,0x63};

  Arc() : source(0), destination(0), weight(0) {
  }

  virtual ~Arc() throw() {}

  int32_t source;
  int32_t destination;
  Token token;
  double weight;

  _Arc__isset __isset;

  void __set_source(const int32_t val) {
    source = val;
  }

  void __set_destination(const int32_t val) {
    destination = val;
  }

  void __set_token(const Token& val) {
    token = val;
  }

  void __set_weight(const double val) {
    weight = val;
  }

  bool operator == (const Arc & rhs) const
  {
    if (!(source == rhs.source))
      return false;
    if (!(destination == rhs.destination))
      return false;
    if (!(token == rhs.token))
      return false;
    if (!(weight == rhs.weight))
      return false;
    return true;
  }
  bool operator != (const Arc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Arc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Arc &a, Arc &b);

typedef struct _TokenLattice__isset {
  _TokenLattice__isset() : startState(false), endState(false), arcs(false) {}
  bool startState;
  bool endState;
  bool arcs;
} _TokenLattice__isset;

class TokenLattice {
 public:

  static const char* ascii_fingerprint; // = "5C1B78F96829EE68180F1FD0485EEEC8";
  static const uint8_t binary_fingerprint[16]; // = {0x5C,0x1B,0x78,0xF9,0x68,0x29,0xEE,0x68,0x18,0x0F,0x1F,0xD0,0x48,0x5E,0xEE,0xC8};

  TokenLattice() : startState(0), endState(0) {
  }

  virtual ~TokenLattice() throw() {}

  int32_t startState;
  int32_t endState;
  std::vector<Arc>  arcs;

  _TokenLattice__isset __isset;

  void __set_startState(const int32_t val) {
    startState = val;
  }

  void __set_endState(const int32_t val) {
    endState = val;
  }

  void __set_arcs(const std::vector<Arc> & val) {
    arcs = val;
  }

  bool operator == (const TokenLattice & rhs) const
  {
    if (!(startState == rhs.startState))
      return false;
    if (!(endState == rhs.endState))
      return false;
    if (!(arcs == rhs.arcs))
      return false;
    return true;
  }
  bool operator != (const TokenLattice &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenLattice & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TokenLattice &a, TokenLattice &b);

typedef struct _Chunk__isset {
  _Chunk__isset() : id(false), value(false), algorithmName(false) {}
  bool id;
  bool value;
  bool algorithmName;
} _Chunk__isset;

class Chunk {
 public:

  static const char* ascii_fingerprint; // = "119BA4322A23950A1A1CF6A2CE800503";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x9B,0xA4,0x32,0x2A,0x23,0x95,0x0A,0x1A,0x1C,0xF6,0xA2,0xCE,0x80,0x05,0x03};

  Chunk() : value(), algorithmName() {
  }

  virtual ~Chunk() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  ID id;
  std::string value;
  std::string algorithmName;

  _Chunk__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Chunk & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Chunk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Chunk & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Chunk &a, Chunk &b);

typedef struct _AdeptException__isset {
  _AdeptException__isset() : serialVersionUID(true) {}
  bool serialVersionUID;
} _AdeptException__isset;

class AdeptException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  AdeptException() : serialVersionUID(1LL) {
  }

  virtual ~AdeptException() throw() {}

  int64_t serialVersionUID;

  _AdeptException__isset __isset;

  void __set_serialVersionUID(const int64_t val) {
    serialVersionUID = val;
  }

  bool operator == (const AdeptException & rhs) const
  {
    if (!(serialVersionUID == rhs.serialVersionUID))
      return false;
    return true;
  }
  bool operator != (const AdeptException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AdeptException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AdeptException &a, AdeptException &b);

typedef struct _AnomalousText__isset {
  _AnomalousText__isset() : explanation(false), id(false), value(false), algorithmName(false) {}
  bool explanation;
  bool id;
  bool value;
  bool algorithmName;
} _AnomalousText__isset;

class AnomalousText {
 public:

  static const char* ascii_fingerprint; // = "3553379BE997F185411FB39D97CB88A0";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0x53,0x37,0x9B,0xE9,0x97,0xF1,0x85,0x41,0x1F,0xB3,0x9D,0x97,0xCB,0x88,0xA0};

  AnomalousText() : confidence(0), explanation(), value(), algorithmName() {
  }

  virtual ~AnomalousText() throw() {}

  double confidence;
  Document document;
  std::string explanation;
  ID id;
  std::string value;
  std::string algorithmName;

  _AnomalousText__isset __isset;

  void __set_confidence(const double val) {
    confidence = val;
  }

  void __set_document(const Document& val) {
    document = val;
  }

  void __set_explanation(const std::string& val) {
    explanation = val;
    __isset.explanation = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const AnomalousText & rhs) const
  {
    if (!(confidence == rhs.confidence))
      return false;
    if (!(document == rhs.document))
      return false;
    if (__isset.explanation != rhs.__isset.explanation)
      return false;
    else if (__isset.explanation && !(explanation == rhs.explanation))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const AnomalousText &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AnomalousText & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(AnomalousText &a, AnomalousText &b);


class Type {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Type() : type() {
  }

  virtual ~Type() throw() {}

  std::string type;

  void __set_type(const std::string& val) {
    type = val;
  }

  bool operator == (const Type & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Type &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Type & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Type &a, Type &b);

typedef struct _CommittedBelief__isset {
  _CommittedBelief__isset() : charOffset(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _CommittedBelief__isset;

class CommittedBelief {
 public:

  static const char* ascii_fingerprint; // = "8A4D67CBA5CDECF7CCADB0869709400D";
  static const uint8_t binary_fingerprint[16]; // = {0x8A,0x4D,0x67,0xCB,0xA5,0xCD,0xEC,0xF7,0xCC,0xAD,0xB0,0x86,0x97,0x09,0x40,0x0D};

  CommittedBelief() : sequenceId(0), modality((Modality::type)0), value(), algorithmName() {
  }

  virtual ~CommittedBelief() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  Modality::type modality;
  ID id;
  std::string value;
  std::string algorithmName;

  _CommittedBelief__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_modality(const Modality::type val) {
    modality = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const CommittedBelief & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(modality == rhs.modality))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const CommittedBelief &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CommittedBelief & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CommittedBelief &a, CommittedBelief &b);

typedef struct _EntityMention__isset {
  _EntityMention__isset() : charOffset(false), entityIdDistribution(false), entityType(false), mentionType(false), context(false), contextSize(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool entityIdDistribution;
  bool entityType;
  bool mentionType;
  bool context;
  bool contextSize;
  bool id;
  bool value;
  bool algorithmName;
} _EntityMention__isset;

class EntityMention {
 public:

  static const char* ascii_fingerprint; // = "F687548AF097E3BE0870F4F1440025A4";
  static const uint8_t binary_fingerprint[16]; // = {0xF6,0x87,0x54,0x8A,0xF0,0x97,0xE3,0xBE,0x08,0x70,0xF4,0xF1,0x44,0x00,0x25,0xA4};

  EntityMention() : sequenceId(0), context(), contextSize(0), value(), algorithmName() {
  }

  virtual ~EntityMention() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  std::map<int64_t, double>  entityIdDistribution;
  Type entityType;
  Type mentionType;
  std::string context;
  int32_t contextSize;
  ID id;
  std::string value;
  std::string algorithmName;

  _EntityMention__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_entityIdDistribution(const std::map<int64_t, double> & val) {
    entityIdDistribution = val;
    __isset.entityIdDistribution = true;
  }

  void __set_entityType(const Type& val) {
    entityType = val;
    __isset.entityType = true;
  }

  void __set_mentionType(const Type& val) {
    mentionType = val;
    __isset.mentionType = true;
  }

  void __set_context(const std::string& val) {
    context = val;
    __isset.context = true;
  }

  void __set_contextSize(const int32_t val) {
    contextSize = val;
    __isset.contextSize = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const EntityMention & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.entityIdDistribution != rhs.__isset.entityIdDistribution)
      return false;
    else if (__isset.entityIdDistribution && !(entityIdDistribution == rhs.entityIdDistribution))
      return false;
    if (__isset.entityType != rhs.__isset.entityType)
      return false;
    else if (__isset.entityType && !(entityType == rhs.entityType))
      return false;
    if (__isset.mentionType != rhs.__isset.mentionType)
      return false;
    else if (__isset.mentionType && !(mentionType == rhs.mentionType))
      return false;
    if (__isset.context != rhs.__isset.context)
      return false;
    else if (__isset.context && !(context == rhs.context))
      return false;
    if (__isset.contextSize != rhs.__isset.contextSize)
      return false;
    else if (__isset.contextSize && !(contextSize == rhs.contextSize))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const EntityMention &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EntityMention & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EntityMention &a, EntityMention &b);

typedef struct _Entity__isset {
  _Entity__isset() : canonicalMention(false), id(false), value(false), algorithmName(false) {}
  bool canonicalMention;
  bool id;
  bool value;
  bool algorithmName;
} _Entity__isset;

class Entity {
 public:

  static const char* ascii_fingerprint; // = "F38F0B1DB4EE5A0B3A5F350B127EB0FB";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x8F,0x0B,0x1D,0xB4,0xEE,0x5A,0x0B,0x3A,0x5F,0x35,0x0B,0x12,0x7E,0xB0,0xFB};

  Entity() : entityId(0), value(), algorithmName() {
  }

  virtual ~Entity() throw() {}

  int64_t entityId;
  Type entityType;
  EntityMention canonicalMention;
  ID id;
  std::string value;
  std::string algorithmName;

  _Entity__isset __isset;

  void __set_entityId(const int64_t val) {
    entityId = val;
  }

  void __set_entityType(const Type& val) {
    entityType = val;
  }

  void __set_canonicalMention(const EntityMention& val) {
    canonicalMention = val;
    __isset.canonicalMention = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Entity & rhs) const
  {
    if (!(entityId == rhs.entityId))
      return false;
    if (!(entityType == rhs.entityType))
      return false;
    if (__isset.canonicalMention != rhs.__isset.canonicalMention)
      return false;
    else if (__isset.canonicalMention && !(canonicalMention == rhs.canonicalMention))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Entity &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Entity & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Entity &a, Entity &b);

typedef struct _EntityObject__isset {
  _EntityObject__isset() : entity(false) {}
  bool entity;
} _EntityObject__isset;

class EntityObject {
 public:

  static const char* ascii_fingerprint; // = "6776C0CBAADECB6EE6FB96E6C8AF02A1";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x76,0xC0,0xCB,0xAA,0xDE,0xCB,0x6E,0xE6,0xFB,0x96,0xE6,0xC8,0xAF,0x02,0xA1};

  EntityObject() {
  }

  virtual ~EntityObject() throw() {}

  Entity entity;

  _EntityObject__isset __isset;

  void __set_entity(const Entity& val) {
    entity = val;
  }

  bool operator == (const EntityObject & rhs) const
  {
    if (!(entity == rhs.entity))
      return false;
    return true;
  }
  bool operator != (const EntityObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EntityObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EntityObject &a, EntityObject &b);

typedef struct _Coreference__isset {
  _Coreference__isset() : entities(false), resolvedEntityMentions(false), id(false), value(false), algorithmName(false) {}
  bool entities;
  bool resolvedEntityMentions;
  bool id;
  bool value;
  bool algorithmName;
} _Coreference__isset;

class Coreference {
 public:

  static const char* ascii_fingerprint; // = "6FC5DFAF04BF0A5F0029E38C1ADF1096";
  static const uint8_t binary_fingerprint[16]; // = {0x6F,0xC5,0xDF,0xAF,0x04,0xBF,0x0A,0x5F,0x00,0x29,0xE3,0x8C,0x1A,0xDF,0x10,0x96};

  Coreference() : coreferenceId(0), value(), algorithmName() {
  }

  virtual ~Coreference() throw() {}

  int64_t coreferenceId;
  std::vector<Entity>  entities;
  std::vector<EntityMention>  resolvedEntityMentions;
  ID id;
  std::string value;
  std::string algorithmName;

  _Coreference__isset __isset;

  void __set_coreferenceId(const int64_t val) {
    coreferenceId = val;
  }

  void __set_entities(const std::vector<Entity> & val) {
    entities = val;
    __isset.entities = true;
  }

  void __set_resolvedEntityMentions(const std::vector<EntityMention> & val) {
    resolvedEntityMentions = val;
    __isset.resolvedEntityMentions = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Coreference & rhs) const
  {
    if (!(coreferenceId == rhs.coreferenceId))
      return false;
    if (__isset.entities != rhs.__isset.entities)
      return false;
    else if (__isset.entities && !(entities == rhs.entities))
      return false;
    if (__isset.resolvedEntityMentions != rhs.__isset.resolvedEntityMentions)
      return false;
    else if (__isset.resolvedEntityMentions && !(resolvedEntityMentions == rhs.resolvedEntityMentions))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Coreference &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Coreference & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Coreference &a, Coreference &b);

typedef struct _DiscourseUnit__isset {
  _DiscourseUnit__isset() : charOffset(false), noveltyConfidence(false), uncertaintyConfidence(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool noveltyConfidence;
  bool uncertaintyConfidence;
  bool id;
  bool value;
  bool algorithmName;
} _DiscourseUnit__isset;

class DiscourseUnit {
 public:

  static const char* ascii_fingerprint; // = "66FA40A3D781ED3795E5793ABC3280EC";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xFA,0x40,0xA3,0xD7,0x81,0xED,0x37,0x95,0xE5,0x79,0x3A,0xBC,0x32,0x80,0xEC};

  DiscourseUnit() : sequenceId(0), discourceType(), noveltyConfidence(0), uncertaintyConfidence(0), value(), algorithmName() {
  }

  virtual ~DiscourseUnit() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  int64_t sequenceId;
  std::string discourceType;
  double noveltyConfidence;
  double uncertaintyConfidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _DiscourseUnit__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_discourceType(const std::string& val) {
    discourceType = val;
  }

  void __set_noveltyConfidence(const double val) {
    noveltyConfidence = val;
    __isset.noveltyConfidence = true;
  }

  void __set_uncertaintyConfidence(const double val) {
    uncertaintyConfidence = val;
    __isset.uncertaintyConfidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const DiscourseUnit & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(discourceType == rhs.discourceType))
      return false;
    if (__isset.noveltyConfidence != rhs.__isset.noveltyConfidence)
      return false;
    else if (__isset.noveltyConfidence && !(noveltyConfidence == rhs.noveltyConfidence))
      return false;
    if (__isset.uncertaintyConfidence != rhs.__isset.uncertaintyConfidence)
      return false;
    else if (__isset.uncertaintyConfidence && !(uncertaintyConfidence == rhs.uncertaintyConfidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const DiscourseUnit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DiscourseUnit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DiscourseUnit &a, DiscourseUnit &b);

typedef struct _Passage__isset {
  _Passage__isset() : charOffset(false), contentType(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool contentType;
  bool id;
  bool value;
  bool algorithmName;
} _Passage__isset;

class Passage {
 public:

  static const char* ascii_fingerprint; // = "0B1DE46BCF4B6AFE1E4056463BCA189C";
  static const uint8_t binary_fingerprint[16]; // = {0x0B,0x1D,0xE4,0x6B,0xCF,0x4B,0x6A,0xFE,0x1E,0x40,0x56,0x46,0x3B,0xCA,0x18,0x9C};

  Passage() : sequenceId(0), contentType(), value(), algorithmName() {
  }

  virtual ~Passage() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  std::string contentType;
  ID id;
  std::string value;
  std::string algorithmName;

  _Passage__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_contentType(const std::string& val) {
    contentType = val;
    __isset.contentType = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Passage & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.contentType != rhs.__isset.contentType)
      return false;
    else if (__isset.contentType && !(contentType == rhs.contentType))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Passage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Passage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Passage &a, Passage &b);

typedef struct _Message__isset {
  _Message__isset() : sender(false), recipients(false), ccRecipients(false), bccRecipients(false), sentDate(false), priority(false), subject(false), contentType(false), messageId(false), userAgent(false), inReplyTo(false), reference(false), returnPathAddress(false), id(false), value(false) {}
  bool sender;
  bool recipients;
  bool ccRecipients;
  bool bccRecipients;
  bool sentDate;
  bool priority;
  bool subject;
  bool contentType;
  bool messageId;
  bool userAgent;
  bool inReplyTo;
  bool reference;
  bool returnPathAddress;
  bool id;
  bool value;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "8ED8D8576C0EB7956DAEF370F45FBF82";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0xD8,0xD8,0x57,0x6C,0x0E,0xB7,0x95,0x6D,0xAE,0xF3,0x70,0xF4,0x5F,0xBF,0x82};

  Message() : sequenceId(0), sentDate(), priority(), subject(), contentType(), messageId(), userAgent(), value() {
  }

  virtual ~Message() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  EmailAddress sender;
  std::vector<EmailAddress>  recipients;
  std::vector<EmailAddress>  ccRecipients;
  std::vector<EmailAddress>  bccRecipients;
  std::string sentDate;
  std::string priority;
  std::string subject;
  std::string contentType;
  std::string messageId;
  std::string userAgent;
  std::vector<std::string>  inReplyTo;
  std::vector<std::string>  reference;
  EmailAddress returnPathAddress;
  ID id;
  std::string value;

  _Message__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_sender(const EmailAddress& val) {
    sender = val;
    __isset.sender = true;
  }

  void __set_recipients(const std::vector<EmailAddress> & val) {
    recipients = val;
    __isset.recipients = true;
  }

  void __set_ccRecipients(const std::vector<EmailAddress> & val) {
    ccRecipients = val;
    __isset.ccRecipients = true;
  }

  void __set_bccRecipients(const std::vector<EmailAddress> & val) {
    bccRecipients = val;
    __isset.bccRecipients = true;
  }

  void __set_sentDate(const std::string& val) {
    sentDate = val;
    __isset.sentDate = true;
  }

  void __set_priority(const std::string& val) {
    priority = val;
    __isset.priority = true;
  }

  void __set_subject(const std::string& val) {
    subject = val;
    __isset.subject = true;
  }

  void __set_contentType(const std::string& val) {
    contentType = val;
    __isset.contentType = true;
  }

  void __set_messageId(const std::string& val) {
    messageId = val;
    __isset.messageId = true;
  }

  void __set_userAgent(const std::string& val) {
    userAgent = val;
    __isset.userAgent = true;
  }

  void __set_inReplyTo(const std::vector<std::string> & val) {
    inReplyTo = val;
    __isset.inReplyTo = true;
  }

  void __set_reference(const std::vector<std::string> & val) {
    reference = val;
    __isset.reference = true;
  }

  void __set_returnPathAddress(const EmailAddress& val) {
    returnPathAddress = val;
    __isset.returnPathAddress = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const Message & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.sender != rhs.__isset.sender)
      return false;
    else if (__isset.sender && !(sender == rhs.sender))
      return false;
    if (__isset.recipients != rhs.__isset.recipients)
      return false;
    else if (__isset.recipients && !(recipients == rhs.recipients))
      return false;
    if (__isset.ccRecipients != rhs.__isset.ccRecipients)
      return false;
    else if (__isset.ccRecipients && !(ccRecipients == rhs.ccRecipients))
      return false;
    if (__isset.bccRecipients != rhs.__isset.bccRecipients)
      return false;
    else if (__isset.bccRecipients && !(bccRecipients == rhs.bccRecipients))
      return false;
    if (__isset.sentDate != rhs.__isset.sentDate)
      return false;
    else if (__isset.sentDate && !(sentDate == rhs.sentDate))
      return false;
    if (__isset.priority != rhs.__isset.priority)
      return false;
    else if (__isset.priority && !(priority == rhs.priority))
      return false;
    if (__isset.subject != rhs.__isset.subject)
      return false;
    else if (__isset.subject && !(subject == rhs.subject))
      return false;
    if (__isset.contentType != rhs.__isset.contentType)
      return false;
    else if (__isset.contentType && !(contentType == rhs.contentType))
      return false;
    if (__isset.messageId != rhs.__isset.messageId)
      return false;
    else if (__isset.messageId && !(messageId == rhs.messageId))
      return false;
    if (__isset.userAgent != rhs.__isset.userAgent)
      return false;
    else if (__isset.userAgent && !(userAgent == rhs.userAgent))
      return false;
    if (__isset.inReplyTo != rhs.__isset.inReplyTo)
      return false;
    else if (__isset.inReplyTo && !(inReplyTo == rhs.inReplyTo))
      return false;
    if (__isset.reference != rhs.__isset.reference)
      return false;
    else if (__isset.reference && !(reference == rhs.reference))
      return false;
    if (__isset.returnPathAddress != rhs.__isset.returnPathAddress)
      return false;
    else if (__isset.returnPathAddress && !(returnPathAddress == rhs.returnPathAddress))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Message &a, Message &b);

typedef struct _Entailment__isset {
  _Entailment__isset() : hypothesis(false), judgmentDistribution(false), text(false), id(false), value(false), algorithmName(false) {}
  bool hypothesis;
  bool judgmentDistribution;
  bool text;
  bool id;
  bool value;
  bool algorithmName;
} _Entailment__isset;

class Entailment {
 public:

  static const char* ascii_fingerprint; // = "4D8BD83EDFFA9D4EB7ACC8C41225F9BC";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0x8B,0xD8,0x3E,0xDF,0xFA,0x9D,0x4E,0xB7,0xAC,0xC8,0xC4,0x12,0x25,0xF9,0xBC};

  Entailment() : entailmentId(0), value(), algorithmName() {
  }

  virtual ~Entailment() throw() {}

  int64_t entailmentId;
  Passage hypothesis;
  std::map<EntailmentJudgment::type, double>  judgmentDistribution;
  Passage text;
  ID id;
  std::string value;
  std::string algorithmName;

  _Entailment__isset __isset;

  void __set_entailmentId(const int64_t val) {
    entailmentId = val;
  }

  void __set_hypothesis(const Passage& val) {
    hypothesis = val;
    __isset.hypothesis = true;
  }

  void __set_judgmentDistribution(const std::map<EntailmentJudgment::type, double> & val) {
    judgmentDistribution = val;
    __isset.judgmentDistribution = true;
  }

  void __set_text(const Passage& val) {
    text = val;
    __isset.text = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Entailment & rhs) const
  {
    if (!(entailmentId == rhs.entailmentId))
      return false;
    if (__isset.hypothesis != rhs.__isset.hypothesis)
      return false;
    else if (__isset.hypothesis && !(hypothesis == rhs.hypothesis))
      return false;
    if (__isset.judgmentDistribution != rhs.__isset.judgmentDistribution)
      return false;
    else if (__isset.judgmentDistribution && !(judgmentDistribution == rhs.judgmentDistribution))
      return false;
    if (__isset.text != rhs.__isset.text)
      return false;
    else if (__isset.text && !(text == rhs.text))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Entailment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Entailment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Entailment &a, Entailment &b);

typedef struct _HltContent__isset {
  _HltContent__isset() : id(false), value(false), algorithmName(false) {}
  bool id;
  bool value;
  bool algorithmName;
} _HltContent__isset;

class HltContent {
 public:

  static const char* ascii_fingerprint; // = "20C06E79BA52E52B07B09C122C971051";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0xC0,0x6E,0x79,0xBA,0x52,0xE5,0x2B,0x07,0xB0,0x9C,0x12,0x2C,0x97,0x10,0x51};

  HltContent() : value(), algorithmName() {
  }

  virtual ~HltContent() throw() {}

  ID id;
  std::string value;
  std::string algorithmName;

  _HltContent__isset __isset;

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const HltContent & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const HltContent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HltContent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HltContent &a, HltContent &b);

typedef struct _InterPausalUnit__isset {
  _InterPausalUnit__isset() : acousticFeatures(false), id(false), value(false), algorithmName(false) {}
  bool acousticFeatures;
  bool id;
  bool value;
  bool algorithmName;
} _InterPausalUnit__isset;

class InterPausalUnit {
 public:

  static const char* ascii_fingerprint; // = "73CF609B7073880A17EBC2A2015F91E7";
  static const uint8_t binary_fingerprint[16]; // = {0x73,0xCF,0x60,0x9B,0x70,0x73,0x88,0x0A,0x17,0xEB,0xC2,0xA2,0x01,0x5F,0x91,0xE7};

  InterPausalUnit() : sequenceId(0), value(), algorithmName() {
  }

  virtual ~InterPausalUnit() throw() {}

  int64_t sequenceId;
  AudioOffset ipuAudioOffset;
  std::map<std::string, double>  acousticFeatures;
  ID id;
  std::string value;
  std::string algorithmName;

  _InterPausalUnit__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_ipuAudioOffset(const AudioOffset& val) {
    ipuAudioOffset = val;
  }

  void __set_acousticFeatures(const std::map<std::string, double> & val) {
    acousticFeatures = val;
    __isset.acousticFeatures = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const InterPausalUnit & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(ipuAudioOffset == rhs.ipuAudioOffset))
      return false;
    if (__isset.acousticFeatures != rhs.__isset.acousticFeatures)
      return false;
    else if (__isset.acousticFeatures && !(acousticFeatures == rhs.acousticFeatures))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const InterPausalUnit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterPausalUnit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(InterPausalUnit &a, InterPausalUnit &b);

typedef struct _Opinion__isset {
  _Opinion__isset() : charOffset(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _Opinion__isset;

class Opinion {
 public:

  static const char* ascii_fingerprint; // = "946874239DB6BB1145787D5B49C7E945";
  static const uint8_t binary_fingerprint[16]; // = {0x94,0x68,0x74,0x23,0x9D,0xB6,0xBB,0x11,0x45,0x78,0x7D,0x5B,0x49,0xC7,0xE9,0x45};

  Opinion() : subjectivity((Subjectivity::type)0), polarity((Polarity::type)0), value(), algorithmName() {
  }

  virtual ~Opinion() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  Subjectivity::type subjectivity;
  Polarity::type polarity;
  ID id;
  std::string value;
  std::string algorithmName;

  _Opinion__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_subjectivity(const Subjectivity::type val) {
    subjectivity = val;
  }

  void __set_polarity(const Polarity::type val) {
    polarity = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Opinion & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(subjectivity == rhs.subjectivity))
      return false;
    if (!(polarity == rhs.polarity))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Opinion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Opinion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Opinion &a, Opinion &b);

typedef struct _Paraphrase__isset {
  _Paraphrase__isset() : posTag(false), id(false), algorithmName(false) {}
  bool posTag;
  bool id;
  bool algorithmName;
} _Paraphrase__isset;

class Paraphrase {
 public:

  static const char* ascii_fingerprint; // = "6A2B2C2C95937C9BFB10479B15C22F85";
  static const uint8_t binary_fingerprint[16]; // = {0x6A,0x2B,0x2C,0x2C,0x95,0x93,0x7C,0x9B,0xFB,0x10,0x47,0x9B,0x15,0xC2,0x2F,0x85};

  Paraphrase() : value(), confidence(0), algorithmName() {
  }

  virtual ~Paraphrase() throw() {}

  std::string value;
  double confidence;
  Type posTag;
  ID id;
  std::string algorithmName;

  _Paraphrase__isset __isset;

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_confidence(const double val) {
    confidence = val;
  }

  void __set_posTag(const Type& val) {
    posTag = val;
    __isset.posTag = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Paraphrase & rhs) const
  {
    if (!(value == rhs.value))
      return false;
    if (!(confidence == rhs.confidence))
      return false;
    if (__isset.posTag != rhs.__isset.posTag)
      return false;
    else if (__isset.posTag && !(posTag == rhs.posTag))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Paraphrase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Paraphrase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Paraphrase &a, Paraphrase &b);

typedef struct _PartOfSpeech__isset {
  _PartOfSpeech__isset() : charOffset(false), posTag(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool posTag;
  bool id;
  bool value;
  bool algorithmName;
} _PartOfSpeech__isset;

class PartOfSpeech {
 public:

  static const char* ascii_fingerprint; // = "612203E8AE490B29F72EDAA8D39FAC91";
  static const uint8_t binary_fingerprint[16]; // = {0x61,0x22,0x03,0xE8,0xAE,0x49,0x0B,0x29,0xF7,0x2E,0xDA,0xA8,0xD3,0x9F,0xAC,0x91};

  PartOfSpeech() : sequenceId(0), value(), algorithmName() {
  }

  virtual ~PartOfSpeech() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  Type posTag;
  ID id;
  std::string value;
  std::string algorithmName;

  _PartOfSpeech__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_posTag(const Type& val) {
    posTag = val;
    __isset.posTag = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const PartOfSpeech & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.posTag != rhs.__isset.posTag)
      return false;
    else if (__isset.posTag && !(posTag == rhs.posTag))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const PartOfSpeech &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PartOfSpeech & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PartOfSpeech &a, PartOfSpeech &b);

typedef struct _PostQuote__isset {
  _PostQuote__isset() : subQuotes(false), charOffset(false), postId(false), id(false), value(false), algorithmName(false) {}
  bool subQuotes;
  bool charOffset;
  bool postId;
  bool id;
  bool value;
  bool algorithmName;
} _PostQuote__isset;

class Post;

class PostQuote {
 public:

  static const char* ascii_fingerprint; // = "7722AA25C655F5E635CDB65F6AB60000";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x22,0xAA,0x25,0xC6,0x55,0xF5,0xE6,0x35,0xCD,0xB6,0x5F,0x6A,0xB6,0x00,0x00};

  PostQuote() : sequenceId(0), postId(), value(), algorithmName() {
  }

  virtual ~PostQuote() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  Tag openTag;
  Tag closeTag;
  std::vector<int32_t>  subQuotes;
  CharOffset charOffset;
  std::string postId;
  ID id;
  std::string value;
  std::string algorithmName;

  _PostQuote__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_openTag(const Tag& val) {
    openTag = val;
  }

  void __set_closeTag(const Tag& val) {
    closeTag = val;
  }

  void __set_subQuotes(const std::vector<int32_t> & val) {
    subQuotes = val;
    __isset.subQuotes = true;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_postId(const std::string& val) {
    postId = val;
    __isset.postId = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const PostQuote & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (!(openTag == rhs.openTag))
      return false;
    if (!(closeTag == rhs.closeTag))
      return false;
    if (__isset.subQuotes != rhs.__isset.subQuotes)
      return false;
    else if (__isset.subQuotes && !(subQuotes == rhs.subQuotes))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.postId != rhs.__isset.postId)
      return false;
    else if (__isset.postId && !(postId == rhs.postId))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const PostQuote &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PostQuote & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  std::string getTopLevelContent(const Post post, const int32_t index);
  CharOffset getTopLevelOffset(const Post post, const int32_t index);

};

void swap(PostQuote &a, PostQuote &b);

typedef struct _Post__isset {
  _Post__isset() : quotes(false), allSubQuotes(false), charOffset(false), id(false), value(false), algorithmName(false) {}
  bool quotes;
  bool allSubQuotes;
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _Post__isset;

class Post {
 public:

  static const char* ascii_fingerprint; // = "F87028720B1AE2F879CD8E198A913FDF";
  static const uint8_t binary_fingerprint[16]; // = {0xF8,0x70,0x28,0x72,0x0B,0x1A,0xE2,0xF8,0x79,0xCD,0x8E,0x19,0x8A,0x91,0x3F,0xDF};

  Post() : sequenceId(0), value(), algorithmName() {
  }

  virtual ~Post() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  Tag openTag;
  Tag closeTag;
  std::vector<int32_t>  quotes;
  std::vector<PostQuote>  allSubQuotes;
  CharOffset charOffset;
  ID id;
  std::string value;
  std::string algorithmName;

  _Post__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_openTag(const Tag& val) {
    openTag = val;
  }

  void __set_closeTag(const Tag& val) {
    closeTag = val;
  }

  void __set_quotes(const std::vector<int32_t> & val) {
    quotes = val;
    __isset.quotes = true;
  }

  void __set_allSubQuotes(const std::vector<PostQuote> & val) {
    allSubQuotes = val;
    __isset.allSubQuotes = true;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Post & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (!(openTag == rhs.openTag))
      return false;
    if (!(closeTag == rhs.closeTag))
      return false;
    if (__isset.quotes != rhs.__isset.quotes)
      return false;
    else if (__isset.quotes && !(quotes == rhs.quotes))
      return false;
    if (__isset.allSubQuotes != rhs.__isset.allSubQuotes)
      return false;
    else if (__isset.allSubQuotes && !(allSubQuotes == rhs.allSubQuotes))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Post &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Post & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  CharOffset getTopLevelOffset(const int32_t index) {
    if (index == 0) {
      if (quotes.size() == 0) {
	CharOffset charOffset;
	charOffset.beginIndex = openTag.charOffset.endIndex;
	charOffset.endIndex = closeTag.charOffset.beginIndex;
        return charOffset;
      } else {
	int32_t subQuoteIndex = quotes[index];
	CharOffset charOffset;
	charOffset.beginIndex = openTag.charOffset.endIndex;
	charOffset.endIndex = allSubQuotes[subQuoteIndex].openTag.charOffset.beginIndex;
        return charOffset;
      }
    } else if (index < quotes.size()) {
      int32_t firstIndex = quotes[index - 1];
      int32_t secondIndex = quotes[index];
      CharOffset charOffset;
      charOffset.beginIndex = allSubQuotes[firstIndex].closeTag.charOffset.endIndex;
      charOffset.endIndex = allSubQuotes[secondIndex].openTag.charOffset.beginIndex;
      return charOffset;
    } else if (index == quotes.size()) {
      int32_t subQuoteIndex = quotes[index - 1];
      CharOffset charOffset;
      charOffset.beginIndex = allSubQuotes[subQuoteIndex].closeTag.charOffset.endIndex;
      charOffset.endIndex = closeTag.charOffset.beginIndex;
      return charOffset;
    } else {
      std::cout << "Post content index out of range";
      throw 10;
    }

  }

  std::string getTopLevelContent(const int32_t index) {
    CharOffset charOffset = getTopLevelOffset(index);
    int32_t length = charOffset.endIndex - charOffset.beginIndex;
    int32_t beginPos = charOffset.beginIndex - openTag.charOffset.beginIndex;
    std::string contentValue = value.substr(beginPos, length);
    return contentValue;
  }

};

void swap(Post &a, Post &b);

typedef struct _ProsodicPhrase__isset {
  _ProsodicPhrase__isset() : charOffset(false), confidence(false), noveltyConfidence(false), type(false), uncertaintyConfidence(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool confidence;
  bool noveltyConfidence;
  bool type;
  bool uncertaintyConfidence;
  bool id;
  bool value;
  bool algorithmName;
} _ProsodicPhrase__isset;

class ProsodicPhrase {
 public:

  static const char* ascii_fingerprint; // = "154DE8E5D003001C4800E5CAD63BDBFC";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x4D,0xE8,0xE5,0xD0,0x03,0x00,0x1C,0x48,0x00,0xE5,0xCA,0xD6,0x3B,0xDB,0xFC};

  ProsodicPhrase() : sequenceId(0), confidence(0), noveltyConfidence(0), type(), uncertaintyConfidence(0), value(), algorithmName() {
  }

  virtual ~ProsodicPhrase() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  int64_t sequenceId;
  double confidence;
  double noveltyConfidence;
  std::string type;
  double uncertaintyConfidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _ProsodicPhrase__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_confidence(const double val) {
    confidence = val;
    __isset.confidence = true;
  }

  void __set_noveltyConfidence(const double val) {
    noveltyConfidence = val;
    __isset.noveltyConfidence = true;
  }

  void __set_type(const std::string& val) {
    type = val;
    __isset.type = true;
  }

  void __set_uncertaintyConfidence(const double val) {
    uncertaintyConfidence = val;
    __isset.uncertaintyConfidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const ProsodicPhrase & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (__isset.confidence != rhs.__isset.confidence)
      return false;
    else if (__isset.confidence && !(confidence == rhs.confidence))
      return false;
    if (__isset.noveltyConfidence != rhs.__isset.noveltyConfidence)
      return false;
    else if (__isset.noveltyConfidence && !(noveltyConfidence == rhs.noveltyConfidence))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.uncertaintyConfidence != rhs.__isset.uncertaintyConfidence)
      return false;
    else if (__isset.uncertaintyConfidence && !(uncertaintyConfidence == rhs.uncertaintyConfidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const ProsodicPhrase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProsodicPhrase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ProsodicPhrase &a, ProsodicPhrase &b);

typedef struct _Sarcasm__isset {
  _Sarcasm__isset() : charOffset(false), confidence(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool confidence;
  bool id;
  bool value;
  bool algorithmName;
} _Sarcasm__isset;

class Sarcasm {
 public:

  static const char* ascii_fingerprint; // = "987A6F73FA0D3BB10B3944817D1959B8";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x7A,0x6F,0x73,0xFA,0x0D,0x3B,0xB1,0x0B,0x39,0x44,0x81,0x7D,0x19,0x59,0xB8};

  Sarcasm() : sarcasmId(0), judgment((SarcasmJudgment::type)0), confidence(0), value(), algorithmName() {
  }

  virtual ~Sarcasm() throw() {}

  int64_t sarcasmId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  SarcasmJudgment::type judgment;
  double confidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _Sarcasm__isset __isset;

  void __set_sarcasmId(const int64_t val) {
    sarcasmId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_judgment(const SarcasmJudgment::type val) {
    judgment = val;
  }

  void __set_confidence(const double val) {
    confidence = val;
    __isset.confidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Sarcasm & rhs) const
  {
    if (!(sarcasmId == rhs.sarcasmId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(judgment == rhs.judgment))
      return false;
    if (__isset.confidence != rhs.__isset.confidence)
      return false;
    else if (__isset.confidence && !(confidence == rhs.confidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Sarcasm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Sarcasm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Sarcasm &a, Sarcasm &b);

typedef struct _Sentence__isset {
  _Sentence__isset() : charOffset(false), noveltyConfidence(false), punctuation(false), type(false), uncertaintyConfidence(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool noveltyConfidence;
  bool punctuation;
  bool type;
  bool uncertaintyConfidence;
  bool id;
  bool value;
  bool algorithmName;
} _Sentence__isset;

class Sentence {
 public:

  static const char* ascii_fingerprint; // = "993B39586AC05763F2E1EE150686008D";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x3B,0x39,0x58,0x6A,0xC0,0x57,0x63,0xF2,0xE1,0xEE,0x15,0x06,0x86,0x00,0x8D};

  Sentence() : sequenceId(0), noveltyConfidence(0), punctuation(), type((SentenceType::type)0), uncertaintyConfidence(0), value(), algorithmName() {
  }

  virtual ~Sentence() throw() {}

  int64_t sequenceId;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  double noveltyConfidence;
  std::string punctuation;
  SentenceType::type type;
  double uncertaintyConfidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _Sentence__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_noveltyConfidence(const double val) {
    noveltyConfidence = val;
    __isset.noveltyConfidence = true;
  }

  void __set_punctuation(const std::string& val) {
    punctuation = val;
    __isset.punctuation = true;
  }

  void __set_type(const SentenceType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_uncertaintyConfidence(const double val) {
    uncertaintyConfidence = val;
    __isset.uncertaintyConfidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Sentence & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.noveltyConfidence != rhs.__isset.noveltyConfidence)
      return false;
    else if (__isset.noveltyConfidence && !(noveltyConfidence == rhs.noveltyConfidence))
      return false;
    if (__isset.punctuation != rhs.__isset.punctuation)
      return false;
    else if (__isset.punctuation && !(punctuation == rhs.punctuation))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.uncertaintyConfidence != rhs.__isset.uncertaintyConfidence)
      return false;
    else if (__isset.uncertaintyConfidence && !(uncertaintyConfidence == rhs.uncertaintyConfidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Sentence &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Sentence & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Sentence &a, Sentence &b);

typedef struct _Session__isset {
  _Session__isset() : charOffset(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _Session__isset;

class Session {
 public:

  static const char* ascii_fingerprint; // = "189CF08E06776A5B7B6D1D6F6E6FF6F1";
  static const uint8_t binary_fingerprint[16]; // = {0x18,0x9C,0xF0,0x8E,0x06,0x77,0x6A,0x5B,0x7B,0x6D,0x1D,0x6F,0x6E,0x6F,0xF6,0xF1};

  Session() : sequenceId(0), contentType(), value(), algorithmName() {
  }

  virtual ~Session() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  int64_t sequenceId;
  std::string contentType;
  std::vector<Sentence>  sentences;
  CharOffset charOffset;
  ID id;
  std::string value;
  std::string algorithmName;

  _Session__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_contentType(const std::string& val) {
    contentType = val;
  }

  void __set_sentences(const std::vector<Sentence> & val) {
    sentences = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Session & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(contentType == rhs.contentType))
      return false;
    if (!(sentences == rhs.sentences))
      return false;
    if (!(charOffset == rhs.charOffset))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Session &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Session & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Session &a, Session &b);

typedef struct _SentenceSimilarity__isset {
  _SentenceSimilarity__isset() : id(false), value(false), algorithmName(false) {}
  bool id;
  bool value;
  bool algorithmName;
} _SentenceSimilarity__isset;

class SentenceSimilarity {
 public:

  static const char* ascii_fingerprint; // = "E4D4A2DB16AA59AD45605F4EF5D88A05";
  static const uint8_t binary_fingerprint[16]; // = {0xE4,0xD4,0xA2,0xDB,0x16,0xAA,0x59,0xAD,0x45,0x60,0x5F,0x4E,0xF5,0xD8,0x8A,0x05};

  SentenceSimilarity() : similarity(0), value(), algorithmName() {
  }

  virtual ~SentenceSimilarity() throw() {}

  double similarity;
  Sentence sentence1;
  Sentence sentence2;
  ID id;
  std::string value;
  std::string algorithmName;

  _SentenceSimilarity__isset __isset;

  void __set_similarity(const double val) {
    similarity = val;
  }

  void __set_sentence1(const Sentence& val) {
    sentence1 = val;
  }

  void __set_sentence2(const Sentence& val) {
    sentence2 = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const SentenceSimilarity & rhs) const
  {
    if (!(similarity == rhs.similarity))
      return false;
    if (!(sentence1 == rhs.sentence1))
      return false;
    if (!(sentence2 == rhs.sentence2))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const SentenceSimilarity &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SentenceSimilarity & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SentenceSimilarity &a, SentenceSimilarity &b);


class Slot {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  Slot() : slotId(0) {
  }

  virtual ~Slot() throw() {}

  int64_t slotId;

  void __set_slotId(const int64_t val) {
    slotId = val;
  }

  bool operator == (const Slot & rhs) const
  {
    if (!(slotId == rhs.slotId))
      return false;
    return true;
  }
  bool operator != (const Slot &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Slot & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Slot &a, Slot &b);

typedef struct _Story__isset {
  _Story__isset() : charOffset(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _Story__isset;

class Story {
 public:

  static const char* ascii_fingerprint; // = "D70E12EA7998E4CFCCBBCFE197839151";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0x0E,0x12,0xEA,0x79,0x98,0xE4,0xCF,0xCC,0xBB,0xCF,0xE1,0x97,0x83,0x91,0x51};

  Story() : sequenceId(0), value(), algorithmName() {
  }

  virtual ~Story() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  int64_t sequenceId;
  std::vector<std::string>  topicLabels;
  ID id;
  std::string value;
  std::string algorithmName;

  _Story__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_topicLabels(const std::vector<std::string> & val) {
    topicLabels = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Story & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(topicLabels == rhs.topicLabels))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Story &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Story & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Story &a, Story &b);

typedef struct _SyntacticChunk__isset {
  _SyntacticChunk__isset() : charOffset(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _SyntacticChunk__isset;

class SyntacticChunk {
 public:

  static const char* ascii_fingerprint; // = "AA567E4ED40368AD43D87BB4871B7438";
  static const uint8_t binary_fingerprint[16]; // = {0xAA,0x56,0x7E,0x4E,0xD4,0x03,0x68,0xAD,0x43,0xD8,0x7B,0xB4,0x87,0x1B,0x74,0x38};

  SyntacticChunk() : sequenceId(0), value(), algorithmName() {
  }

  virtual ~SyntacticChunk() throw() {}

  int64_t sequenceId;
  Type scType;
  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  ID id;
  std::string value;
  std::string algorithmName;

  _SyntacticChunk__isset __isset;

  void __set_sequenceId(const int64_t val) {
    sequenceId = val;
  }

  void __set_scType(const Type& val) {
    scType = val;
  }

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const SyntacticChunk & rhs) const
  {
    if (!(sequenceId == rhs.sequenceId))
      return false;
    if (!(scType == rhs.scType))
      return false;
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const SyntacticChunk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SyntacticChunk & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SyntacticChunk &a, SyntacticChunk &b);

typedef struct _TokenStreamList__isset {
  _TokenStreamList__isset() : tokenStreamList(false) {}
  bool tokenStreamList;
} _TokenStreamList__isset;

class TokenStreamList {
 public:

  static const char* ascii_fingerprint; // = "4ACF9A2B729628F23759F4764DA95264";
  static const uint8_t binary_fingerprint[16]; // = {0x4A,0xCF,0x9A,0x2B,0x72,0x96,0x28,0xF2,0x37,0x59,0xF4,0x76,0x4D,0xA9,0x52,0x64};

  TokenStreamList() {
  }

  virtual ~TokenStreamList() throw() {}

  std::vector<TokenStream>  tokenStreamList;

  _TokenStreamList__isset __isset;

  void __set_tokenStreamList(const std::vector<TokenStream> & val) {
    tokenStreamList = val;
  }

  bool operator == (const TokenStreamList & rhs) const
  {
    if (!(tokenStreamList == rhs.tokenStreamList))
      return false;
    return true;
  }
  bool operator != (const TokenStreamList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TokenStreamList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TokenStreamList &a, TokenStreamList &b);


class Viewpoint {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  Viewpoint() : speakerId(), belief() {
  }

  virtual ~Viewpoint() throw() {}

  std::string speakerId;
  std::string belief;

  void __set_speakerId(const std::string& val) {
    speakerId = val;
  }

  void __set_belief(const std::string& val) {
    belief = val;
  }

  bool operator == (const Viewpoint & rhs) const
  {
    if (!(speakerId == rhs.speakerId))
      return false;
    if (!(belief == rhs.belief))
      return false;
    return true;
  }
  bool operator != (const Viewpoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Viewpoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Viewpoint &a, Viewpoint &b);

typedef struct _Topic__isset {
  _Topic__isset() : belief(false), polarity(false), viewpoints(false) {}
  bool belief;
  bool polarity;
  bool viewpoints;
} _Topic__isset;

class Topic {
 public:

  static const char* ascii_fingerprint; // = "945A09935A3A03061DD330F93CC56143";
  static const uint8_t binary_fingerprint[16]; // = {0x94,0x5A,0x09,0x93,0x5A,0x3A,0x03,0x06,0x1D,0xD3,0x30,0xF9,0x3C,0xC5,0x61,0x43};

  Topic() : topicId(0), name(), belief(), polarity((TopicPolarity::type)0) {
  }

  virtual ~Topic() throw() {}

  int64_t topicId;
  std::string name;
  std::string belief;
  TopicPolarity::type polarity;
  std::vector<Viewpoint>  viewpoints;

  _Topic__isset __isset;

  void __set_topicId(const int64_t val) {
    topicId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_belief(const std::string& val) {
    belief = val;
    __isset.belief = true;
  }

  void __set_polarity(const TopicPolarity::type val) {
    polarity = val;
    __isset.polarity = true;
  }

  void __set_viewpoints(const std::vector<Viewpoint> & val) {
    viewpoints = val;
    __isset.viewpoints = true;
  }

  bool operator == (const Topic & rhs) const
  {
    if (!(topicId == rhs.topicId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.belief != rhs.__isset.belief)
      return false;
    else if (__isset.belief && !(belief == rhs.belief))
      return false;
    if (__isset.polarity != rhs.__isset.polarity)
      return false;
    else if (__isset.polarity && !(polarity == rhs.polarity))
      return false;
    if (__isset.viewpoints != rhs.__isset.viewpoints)
      return false;
    else if (__isset.viewpoints && !(viewpoints == rhs.viewpoints))
      return false;
    return true;
  }
  bool operator != (const Topic &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Topic & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Topic &a, Topic &b);


class Value {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  Value() : valueId(0) {
  }

  virtual ~Value() throw() {}

  int64_t valueId;

  void __set_valueId(const int64_t val) {
    valueId = val;
  }

  bool operator == (const Value & rhs) const
  {
    if (!(valueId == rhs.valueId))
      return false;
    return true;
  }
  bool operator != (const Value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Value &a, Value &b);


class Triple {
 public:

  static const char* ascii_fingerprint; // = "37F932D049A8D2B3AE7D1ED8E4475F7A";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0xF9,0x32,0xD0,0x49,0xA8,0xD2,0xB3,0xAE,0x7D,0x1E,0xD8,0xE4,0x47,0x5F,0x7A};

  Triple() : value() {
  }

  virtual ~Triple() throw() {}

  Entity entity;
  Slot slot;
  std::string value;

  void __set_entity(const Entity& val) {
    entity = val;
  }

  void __set_slot(const Slot& val) {
    slot = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const Triple & rhs) const
  {
    if (!(entity == rhs.entity))
      return false;
    if (!(slot == rhs.slot))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Triple &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Triple & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Triple &a, Triple &b);

typedef struct _Utterance__isset {
  _Utterance__isset() : charOffset(false), id(false), value(false), algorithmName(false) {}
  bool charOffset;
  bool id;
  bool value;
  bool algorithmName;
} _Utterance__isset;

class Utterance {
 public:

  static const char* ascii_fingerprint; // = "8970DFAB68B818864BC9B61CDC4B80C4";
  static const uint8_t binary_fingerprint[16]; // = {0x89,0x70,0xDF,0xAB,0x68,0xB8,0x18,0x86,0x4B,0xC9,0xB6,0x1C,0xDC,0x4B,0x80,0xC4};

  Utterance() : utteranceId(0), speakerId(0), annotation(), value(), algorithmName() {
  }

  virtual ~Utterance() throw() {}

  TokenOffset tokenOffset;
  TokenStream tokenStream;
  CharOffset charOffset;
  int64_t utteranceId;
  int64_t speakerId;
  std::string annotation;
  ID id;
  std::string value;
  std::string algorithmName;

  _Utterance__isset __isset;

  void __set_tokenOffset(const TokenOffset& val) {
    tokenOffset = val;
  }

  void __set_tokenStream(const TokenStream& val) {
    tokenStream = val;
  }

  void __set_charOffset(const CharOffset& val) {
    charOffset = val;
    __isset.charOffset = true;
  }

  void __set_utteranceId(const int64_t val) {
    utteranceId = val;
  }

  void __set_speakerId(const int64_t val) {
    speakerId = val;
  }

  void __set_annotation(const std::string& val) {
    annotation = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Utterance & rhs) const
  {
    if (!(tokenOffset == rhs.tokenOffset))
      return false;
    if (!(tokenStream == rhs.tokenStream))
      return false;
    if (__isset.charOffset != rhs.__isset.charOffset)
      return false;
    else if (__isset.charOffset && !(charOffset == rhs.charOffset))
      return false;
    if (!(utteranceId == rhs.utteranceId))
      return false;
    if (!(speakerId == rhs.speakerId))
      return false;
    if (!(annotation == rhs.annotation))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Utterance &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Utterance & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Utterance &a, Utterance &b);

typedef struct _Conversation__isset {
  _Conversation__isset() : oneSided(false), topics(false), utterances(false), id(false), value(false) {}
  bool oneSided;
  bool topics;
  bool utterances;
  bool id;
  bool value;
} _Conversation__isset;

class Conversation {
 public:

  static const char* ascii_fingerprint; // = "9FE2CF826285CBC522199F2A36997319";
  static const uint8_t binary_fingerprint[16]; // = {0x9F,0xE2,0xCF,0x82,0x62,0x85,0xCB,0xC5,0x22,0x19,0x9F,0x2A,0x36,0x99,0x73,0x19};

  Conversation() : conversationId(0), name(), oneSided(0), value() {
  }

  virtual ~Conversation() throw() {}

  int64_t conversationId;
  std::string name;
  bool oneSided;
  std::vector<Topic>  topics;
  std::vector<Utterance>  utterances;
  ID id;
  std::string value;

  _Conversation__isset __isset;

  void __set_conversationId(const int64_t val) {
    conversationId = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_oneSided(const bool val) {
    oneSided = val;
    __isset.oneSided = true;
  }

  void __set_topics(const std::vector<Topic> & val) {
    topics = val;
    __isset.topics = true;
  }

  void __set_utterances(const std::vector<Utterance> & val) {
    utterances = val;
    __isset.utterances = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const Conversation & rhs) const
  {
    if (!(conversationId == rhs.conversationId))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.oneSided != rhs.__isset.oneSided)
      return false;
    else if (__isset.oneSided && !(oneSided == rhs.oneSided))
      return false;
    if (__isset.topics != rhs.__isset.topics)
      return false;
    else if (__isset.topics && !(topics == rhs.topics))
      return false;
    if (__isset.utterances != rhs.__isset.utterances)
      return false;
    else if (__isset.utterances && !(utterances == rhs.utterances))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Conversation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Conversation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Conversation &a, Conversation &b);

typedef struct _ChunkUnion__isset {
  _ChunkUnion__isset() : committedBelief(false), discourseUnit(false), entityMention(false), opinion(false), partOfSpeech(false), passage(false), prosodicPhrase(false), sarcasm(false), sentence(false), story(false), syntacticChunk(false), utterance(false), chunk(false) {}
  bool committedBelief;
  bool discourseUnit;
  bool entityMention;
  bool opinion;
  bool partOfSpeech;
  bool passage;
  bool prosodicPhrase;
  bool sarcasm;
  bool sentence;
  bool story;
  bool syntacticChunk;
  bool utterance;
  bool chunk;
} _ChunkUnion__isset;

class ChunkUnion {
 public:

  static const char* ascii_fingerprint; // = "7E487971266C23A0B729BD7BCFE341CA";
  static const uint8_t binary_fingerprint[16]; // = {0x7E,0x48,0x79,0x71,0x26,0x6C,0x23,0xA0,0xB7,0x29,0xBD,0x7B,0xCF,0xE3,0x41,0xCA};

  ChunkUnion() {
  }

  virtual ~ChunkUnion() throw() {}

  CommittedBelief committedBelief;
  DiscourseUnit discourseUnit;
  EntityMention entityMention;
  Opinion opinion;
  PartOfSpeech partOfSpeech;
  Passage passage;
  ProsodicPhrase prosodicPhrase;
  Sarcasm sarcasm;
  Sentence sentence;
  Story story;
  SyntacticChunk syntacticChunk;
  Utterance utterance;
  Chunk chunk;

  _ChunkUnion__isset __isset;

  void __set_committedBelief(const CommittedBelief& val) {
    committedBelief = val;
  }

  void __set_discourseUnit(const DiscourseUnit& val) {
    discourseUnit = val;
  }

  void __set_entityMention(const EntityMention& val) {
    entityMention = val;
  }

  void __set_opinion(const Opinion& val) {
    opinion = val;
  }

  void __set_partOfSpeech(const PartOfSpeech& val) {
    partOfSpeech = val;
  }

  void __set_passage(const Passage& val) {
    passage = val;
  }

  void __set_prosodicPhrase(const ProsodicPhrase& val) {
    prosodicPhrase = val;
  }

  void __set_sarcasm(const Sarcasm& val) {
    sarcasm = val;
  }

  void __set_sentence(const Sentence& val) {
    sentence = val;
  }

  void __set_story(const Story& val) {
    story = val;
  }

  void __set_syntacticChunk(const SyntacticChunk& val) {
    syntacticChunk = val;
  }

  void __set_utterance(const Utterance& val) {
    utterance = val;
  }

  void __set_chunk(const Chunk& val) {
    chunk = val;
  }

  bool operator == (const ChunkUnion & rhs) const
  {
    if (!(committedBelief == rhs.committedBelief))
      return false;
    if (!(discourseUnit == rhs.discourseUnit))
      return false;
    if (!(entityMention == rhs.entityMention))
      return false;
    if (!(opinion == rhs.opinion))
      return false;
    if (!(partOfSpeech == rhs.partOfSpeech))
      return false;
    if (!(passage == rhs.passage))
      return false;
    if (!(prosodicPhrase == rhs.prosodicPhrase))
      return false;
    if (!(sarcasm == rhs.sarcasm))
      return false;
    if (!(sentence == rhs.sentence))
      return false;
    if (!(story == rhs.story))
      return false;
    if (!(syntacticChunk == rhs.syntacticChunk))
      return false;
    if (!(utterance == rhs.utterance))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    return true;
  }
  bool operator != (const ChunkUnion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChunkUnion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ChunkUnion &a, ChunkUnion &b);

typedef struct _Argument__isset {
  _Argument__isset() : argumentDistribution(false), id(false), value(false), algorithmName(false) {}
  bool argumentDistribution;
  bool id;
  bool value;
  bool algorithmName;
} _Argument__isset;

class Argument {
 public:

  static const char* ascii_fingerprint; // = "D4A064B4B18C6503982CDE34B3E19ED3";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0xA0,0x64,0xB4,0xB1,0x8C,0x65,0x03,0x98,0x2C,0xDE,0x34,0xB3,0xE1,0x9E,0xD3};

  Argument() : value(), algorithmName() {
  }

  virtual ~Argument() throw() {}

  Type argumentType;
  std::map<ChunkUnion, double>  argumentDistribution;
  ID id;
  std::string value;
  std::string algorithmName;

  _Argument__isset __isset;

  void __set_argumentType(const Type& val) {
    argumentType = val;
  }

  void __set_argumentDistribution(const std::map<ChunkUnion, double> & val) {
    argumentDistribution = val;
    __isset.argumentDistribution = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Argument & rhs) const
  {
    if (!(argumentType == rhs.argumentType))
      return false;
    if (__isset.argumentDistribution != rhs.__isset.argumentDistribution)
      return false;
    else if (__isset.argumentDistribution && !(argumentDistribution == rhs.argumentDistribution))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Argument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Argument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Argument &a, Argument &b);

typedef struct _ArgumentTuple__isset {
  _ArgumentTuple__isset() : attributes(false), arguments(false), confidence(false), id(false), value(false), algorithmName(false) {}
  bool attributes;
  bool arguments;
  bool confidence;
  bool id;
  bool value;
  bool algorithmName;
} _ArgumentTuple__isset;

class ArgumentTuple {
 public:

  static const char* ascii_fingerprint; // = "E5A7781E14F42BF82F70332761202623";
  static const uint8_t binary_fingerprint[16]; // = {0xE5,0xA7,0x78,0x1E,0x14,0xF4,0x2B,0xF8,0x2F,0x70,0x33,0x27,0x61,0x20,0x26,0x23};

  ArgumentTuple() : confidence(0), value(), algorithmName() {
  }

  virtual ~ArgumentTuple() throw() {}

  Type tupleType;
  std::vector<Type>  attributes;
  std::vector<Argument>  arguments;
  double confidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _ArgumentTuple__isset __isset;

  void __set_tupleType(const Type& val) {
    tupleType = val;
  }

  void __set_attributes(const std::vector<Type> & val) {
    attributes = val;
    __isset.attributes = true;
  }

  void __set_arguments(const std::vector<Argument> & val) {
    arguments = val;
    __isset.arguments = true;
  }

  void __set_confidence(const double val) {
    confidence = val;
    __isset.confidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const ArgumentTuple & rhs) const
  {
    if (!(tupleType == rhs.tupleType))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.arguments != rhs.__isset.arguments)
      return false;
    else if (__isset.arguments && !(arguments == rhs.arguments))
      return false;
    if (__isset.confidence != rhs.__isset.confidence)
      return false;
    else if (__isset.confidence && !(confidence == rhs.confidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const ArgumentTuple &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ArgumentTuple & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ArgumentTuple &a, ArgumentTuple &b);

typedef struct _Event__isset {
  _Event__isset() : attributes(false), arguments(false), confidence(false), id(false), value(false), algorithmName(false) {}
  bool attributes;
  bool arguments;
  bool confidence;
  bool id;
  bool value;
  bool algorithmName;
} _Event__isset;

class Event {
 public:

  static const char* ascii_fingerprint; // = "3774A49C3C66335C3F98ED2611B7F073";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x74,0xA4,0x9C,0x3C,0x66,0x33,0x5C,0x3F,0x98,0xED,0x26,0x11,0xB7,0xF0,0x73};

  Event() : eventId(0), confidence(0), value(), algorithmName() {
  }

  virtual ~Event() throw() {}

  int64_t eventId;
  Type eventType;
  std::vector<Type>  attributes;
  std::vector<Argument>  arguments;
  double confidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _Event__isset __isset;

  void __set_eventId(const int64_t val) {
    eventId = val;
  }

  void __set_eventType(const Type& val) {
    eventType = val;
  }

  void __set_attributes(const std::vector<Type> & val) {
    attributes = val;
    __isset.attributes = true;
  }

  void __set_arguments(const std::vector<Argument> & val) {
    arguments = val;
    __isset.arguments = true;
  }

  void __set_confidence(const double val) {
    confidence = val;
    __isset.confidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Event & rhs) const
  {
    if (!(eventId == rhs.eventId))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.arguments != rhs.__isset.arguments)
      return false;
    else if (__isset.arguments && !(arguments == rhs.arguments))
      return false;
    if (__isset.confidence != rhs.__isset.confidence)
      return false;
    else if (__isset.confidence && !(confidence == rhs.confidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Event &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Event & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Event &a, Event &b);

typedef struct _EventRelations__isset {
  _EventRelations__isset() : coreferences(false) {}
  bool coreferences;
} _EventRelations__isset;

class EventRelations {
 public:

  static const char* ascii_fingerprint; // = "2EF78D2801D61A5B0489A85763967963";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0xF7,0x8D,0x28,0x01,0xD6,0x1A,0x5B,0x04,0x89,0xA8,0x57,0x63,0x96,0x79,0x63};

  EventRelations() {
  }

  virtual ~EventRelations() throw() {}

  std::vector<Event>  coreferences;

  _EventRelations__isset __isset;

  void __set_coreferences(const std::vector<Event> & val) {
    coreferences = val;
    __isset.coreferences = true;
  }

  bool operator == (const EventRelations & rhs) const
  {
    if (__isset.coreferences != rhs.__isset.coreferences)
      return false;
    else if (__isset.coreferences && !(coreferences == rhs.coreferences))
      return false;
    return true;
  }
  bool operator != (const EventRelations &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EventRelations & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EventRelations &a, EventRelations &b);

typedef struct _Relation__isset {
  _Relation__isset() : arguments(false), confidence(false), id(false), value(false), algorithmName(false) {}
  bool arguments;
  bool confidence;
  bool id;
  bool value;
  bool algorithmName;
} _Relation__isset;

class Relation {
 public:

  static const char* ascii_fingerprint; // = "A1FC45A85F65C78E854DEEA1DBC11A49";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0xFC,0x45,0xA8,0x5F,0x65,0xC7,0x8E,0x85,0x4D,0xEE,0xA1,0xDB,0xC1,0x1A,0x49};

  Relation() : relationId(0), confidence(0), value(), algorithmName() {
  }

  virtual ~Relation() throw() {}

  int64_t relationId;
  Type type;
  std::vector<Argument>  arguments;
  double confidence;
  ID id;
  std::string value;
  std::string algorithmName;

  _Relation__isset __isset;

  void __set_relationId(const int64_t val) {
    relationId = val;
  }

  void __set_type(const Type& val) {
    type = val;
  }

  void __set_arguments(const std::vector<Argument> & val) {
    arguments = val;
    __isset.arguments = true;
  }

  void __set_confidence(const double val) {
    confidence = val;
    __isset.confidence = true;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Relation & rhs) const
  {
    if (!(relationId == rhs.relationId))
      return false;
    if (!(type == rhs.type))
      return false;
    if (__isset.arguments != rhs.__isset.arguments)
      return false;
    else if (__isset.arguments && !(arguments == rhs.arguments))
      return false;
    if (__isset.confidence != rhs.__isset.confidence)
      return false;
    else if (__isset.confidence && !(confidence == rhs.confidence))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Relation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Relation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Relation &a, Relation &b);

typedef struct _JointRelationCoreference__isset {
  _JointRelationCoreference__isset() : coreference(false), relations(false), id(false), value(false), algorithmName(false) {}
  bool coreference;
  bool relations;
  bool id;
  bool value;
  bool algorithmName;
} _JointRelationCoreference__isset;

class JointRelationCoreference {
 public:

  static const char* ascii_fingerprint; // = "BD65783B66CEE8EA919F153DA617E4F1";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0x65,0x78,0x3B,0x66,0xCE,0xE8,0xEA,0x91,0x9F,0x15,0x3D,0xA6,0x17,0xE4,0xF1};

  JointRelationCoreference() : value(), algorithmName() {
  }

  virtual ~JointRelationCoreference() throw() {}

  Coreference coreference;
  std::vector<Relation>  relations;
  ID id;
  std::string value;
  std::string algorithmName;

  _JointRelationCoreference__isset __isset;

  void __set_coreference(const Coreference& val) {
    coreference = val;
  }

  void __set_relations(const std::vector<Relation> & val) {
    relations = val;
  }

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const JointRelationCoreference & rhs) const
  {
    if (!(coreference == rhs.coreference))
      return false;
    if (!(relations == rhs.relations))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const JointRelationCoreference &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JointRelationCoreference & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JointRelationCoreference &a, JointRelationCoreference &b);

typedef struct _Dependency__isset {
  _Dependency__isset() : id(false), value(false), algorithmName(false) {}
  bool id;
  bool value;
  bool algorithmName;
} _Dependency__isset;

class Dependency {
 public:

  static const char* ascii_fingerprint; // = "D210DC09F016E0023337E60891B77C75";
  static const uint8_t binary_fingerprint[16]; // = {0xD2,0x10,0xDC,0x09,0xF0,0x16,0xE0,0x02,0x33,0x37,0xE6,0x08,0x91,0xB7,0x7C,0x75};

  Dependency() : dependencyType(), value(), algorithmName() {
  }

  virtual ~Dependency() throw() {}

  ChunkUnion governor;
  ChunkUnion dependent;
  std::string dependencyType;
  ID id;
  std::string value;
  std::string algorithmName;

  _Dependency__isset __isset;

  void __set_governor(const ChunkUnion& val) {
    governor = val;
  }

  void __set_dependent(const ChunkUnion& val) {
    dependent = val;
  }

  void __set_dependencyType(const std::string& val) {
    dependencyType = val;
  }

  void __set_id(const ID& val) {
    id = val;
    __isset.id = true;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const Dependency & rhs) const
  {
    if (!(governor == rhs.governor))
      return false;
    if (!(dependent == rhs.dependent))
      return false;
    if (!(dependencyType == rhs.dependencyType))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const Dependency &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Dependency & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Dependency &a, Dependency &b);

typedef struct _HltContentContainer__isset {
  _HltContentContainer__isset() : committedBeliefs(false), coreferences(false), dependencies(false), entityMentions(false), jointRelationCoreferences(false), namedEntities(false), opinions(false), partOfSpeechs(false), passages(false), posts(false), prosodicPhrases(false), relations(false), sarcasms(false), sentences(false), syntacticChunks(false), sessions(false), utterances(false), messages(false), interPausalUnits(false), events(false), eventRelations(false), id(false), value(false), algorithmName(false) {}
  bool committedBeliefs;
  bool coreferences;
  bool dependencies;
  bool entityMentions;
  bool jointRelationCoreferences;
  bool namedEntities;
  bool opinions;
  bool partOfSpeechs;
  bool passages;
  bool posts;
  bool prosodicPhrases;
  bool relations;
  bool sarcasms;
  bool sentences;
  bool syntacticChunks;
  bool sessions;
  bool utterances;
  bool messages;
  bool interPausalUnits;
  bool events;
  bool eventRelations;
  bool id;
  bool value;
  bool algorithmName;
} _HltContentContainer__isset;

class HltContentContainer {
 public:

  static const char* ascii_fingerprint; // = "727E762FDA75DF72AACA2A07FAD05EB3";
  static const uint8_t binary_fingerprint[16]; // = {0x72,0x7E,0x76,0x2F,0xDA,0x75,0xDF,0x72,0xAA,0xCA,0x2A,0x07,0xFA,0xD0,0x5E,0xB3};

  HltContentContainer() : value(), algorithmName() {
  }

  virtual ~HltContentContainer() throw() {}

  std::vector<CommittedBelief>  committedBeliefs;
  std::vector<Coreference>  coreferences;
  std::vector<Dependency>  dependencies;
  std::vector<EntityMention>  entityMentions;
  std::vector<JointRelationCoreference>  jointRelationCoreferences;
  std::vector<EntityMention>  namedEntities;
  std::vector<Opinion>  opinions;
  std::vector<PartOfSpeech>  partOfSpeechs;
  std::vector<Passage>  passages;
  std::vector<Post>  posts;
  std::vector<ProsodicPhrase>  prosodicPhrases;
  std::vector<Relation>  relations;
  std::vector<Sarcasm>  sarcasms;
  std::vector<Sentence>  sentences;
  std::vector<SyntacticChunk>  syntacticChunks;
  std::vector<Session>  sessions;
  std::vector<Utterance>  utterances;
  std::vector<Message>  messages;
  std::vector<InterPausalUnit>  interPausalUnits;
  std::vector<Event>  events;
  std::vector<EventRelations>  eventRelations;
  ID id;
  std::string value;
  std::string algorithmName;

  _HltContentContainer__isset __isset;

  void __set_committedBeliefs(const std::vector<CommittedBelief> & val) {
    committedBeliefs = val;
  }

  void __set_coreferences(const std::vector<Coreference> & val) {
    coreferences = val;
  }

  void __set_dependencies(const std::vector<Dependency> & val) {
    dependencies = val;
  }

  void __set_entityMentions(const std::vector<EntityMention> & val) {
    entityMentions = val;
  }

  void __set_jointRelationCoreferences(const std::vector<JointRelationCoreference> & val) {
    jointRelationCoreferences = val;
  }

  void __set_namedEntities(const std::vector<EntityMention> & val) {
    namedEntities = val;
  }

  void __set_opinions(const std::vector<Opinion> & val) {
    opinions = val;
  }

  void __set_partOfSpeechs(const std::vector<PartOfSpeech> & val) {
    partOfSpeechs = val;
  }

  void __set_passages(const std::vector<Passage> & val) {
    passages = val;
  }

  void __set_posts(const std::vector<Post> & val) {
    posts = val;
  }

  void __set_prosodicPhrases(const std::vector<ProsodicPhrase> & val) {
    prosodicPhrases = val;
  }

  void __set_relations(const std::vector<Relation> & val) {
    relations = val;
  }

  void __set_sarcasms(const std::vector<Sarcasm> & val) {
    sarcasms = val;
  }

  void __set_sentences(const std::vector<Sentence> & val) {
    sentences = val;
  }

  void __set_syntacticChunks(const std::vector<SyntacticChunk> & val) {
    syntacticChunks = val;
  }

  void __set_sessions(const std::vector<Session> & val) {
    sessions = val;
  }

  void __set_utterances(const std::vector<Utterance> & val) {
    utterances = val;
  }

  void __set_messages(const std::vector<Message> & val) {
    messages = val;
  }

  void __set_interPausalUnits(const std::vector<InterPausalUnit> & val) {
    interPausalUnits = val;
  }

  void __set_events(const std::vector<Event> & val) {
    events = val;
  }

  void __set_eventRelations(const std::vector<EventRelations> & val) {
    eventRelations = val;
  }

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  void __set_algorithmName(const std::string& val) {
    algorithmName = val;
    __isset.algorithmName = true;
  }

  bool operator == (const HltContentContainer & rhs) const
  {
    if (!(committedBeliefs == rhs.committedBeliefs))
      return false;
    if (!(coreferences == rhs.coreferences))
      return false;
    if (!(dependencies == rhs.dependencies))
      return false;
    if (!(entityMentions == rhs.entityMentions))
      return false;
    if (!(jointRelationCoreferences == rhs.jointRelationCoreferences))
      return false;
    if (!(namedEntities == rhs.namedEntities))
      return false;
    if (!(opinions == rhs.opinions))
      return false;
    if (!(partOfSpeechs == rhs.partOfSpeechs))
      return false;
    if (!(passages == rhs.passages))
      return false;
    if (!(posts == rhs.posts))
      return false;
    if (!(prosodicPhrases == rhs.prosodicPhrases))
      return false;
    if (!(relations == rhs.relations))
      return false;
    if (!(sarcasms == rhs.sarcasms))
      return false;
    if (!(sentences == rhs.sentences))
      return false;
    if (!(syntacticChunks == rhs.syntacticChunks))
      return false;
    if (!(sessions == rhs.sessions))
      return false;
    if (!(utterances == rhs.utterances))
      return false;
    if (!(messages == rhs.messages))
      return false;
    if (!(interPausalUnits == rhs.interPausalUnits))
      return false;
    if (!(events == rhs.events))
      return false;
    if (!(eventRelations == rhs.eventRelations))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.algorithmName != rhs.__isset.algorithmName)
      return false;
    else if (__isset.algorithmName && !(algorithmName == rhs.algorithmName))
      return false;
    return true;
  }
  bool operator != (const HltContentContainer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HltContentContainer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HltContentContainer &a, HltContentContainer &b);

typedef struct _HltContentContainerList__isset {
  _HltContentContainerList__isset() : id(false), serialVersionUID(true), hltContentContainerList(false) {}
  bool id;
  bool serialVersionUID;
  bool hltContentContainerList;
} _HltContentContainerList__isset;

class HltContentContainerList {
 public:

  static const char* ascii_fingerprint; // = "0C96E79CBA6E7B14C41A80C4360A82A4";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0x96,0xE7,0x9C,0xBA,0x6E,0x7B,0x14,0xC4,0x1A,0x80,0xC4,0x36,0x0A,0x82,0xA4};

  HltContentContainerList() : serialVersionUID(651655831447893195LL) {
  }

  virtual ~HltContentContainerList() throw() {}

  ID id;
  int64_t serialVersionUID;
  std::vector<HltContentContainer>  hltContentContainerList;

  _HltContentContainerList__isset __isset;

  void __set_id(const ID& val) {
    id = val;
  }

  void __set_serialVersionUID(const int64_t val) {
    serialVersionUID = val;
  }

  void __set_hltContentContainerList(const std::vector<HltContentContainer> & val) {
    hltContentContainerList = val;
  }

  bool operator == (const HltContentContainerList & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(serialVersionUID == rhs.serialVersionUID))
      return false;
    if (!(hltContentContainerList == rhs.hltContentContainerList))
      return false;
    return true;
  }
  bool operator != (const HltContentContainerList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HltContentContainerList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HltContentContainerList &a, HltContentContainerList &b);


class Translation {
 public:

  static const char* ascii_fingerprint; // = "3E53EF97BB298040F03E900E2BE663F0";
  static const uint8_t binary_fingerprint[16]; // = {0x3E,0x53,0xEF,0x97,0xBB,0x29,0x80,0x40,0xF0,0x3E,0x90,0x0E,0x2B,0xE6,0x63,0xF0};

  Translation() {
  }

  virtual ~Translation() throw() {}

  ChunkUnion sourceChunk;
  ChunkUnion targetChunk;

  void __set_sourceChunk(const ChunkUnion& val) {
    sourceChunk = val;
  }

  void __set_targetChunk(const ChunkUnion& val) {
    targetChunk = val;
  }

  bool operator == (const Translation & rhs) const
  {
    if (!(sourceChunk == rhs.sourceChunk))
      return false;
    if (!(targetChunk == rhs.targetChunk))
      return false;
    return true;
  }
  bool operator != (const Translation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Translation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Translation &a, Translation &b);

typedef struct _HltContentUnion__isset {
  _HltContentUnion__isset() : anomalousText(false), argument(false), chunk(false), committedBelief(false), discourseUnit(false), entityMention(false), opinion(false), partOfSpeech(false), passage(false), prosodicPhrase(false), sarcasm(false), sentence(false), story(false), syntacticChunk(false), utterance(false), coreference(false), dependency(false), entity(false), hltContentContainer(false), interPausalUnit(false), jointRelationCoreference(false), paraphrase(false), relation(false), sentenceSimilarity(false), chunkUnion(false) {}
  bool anomalousText;
  bool argument;
  bool chunk;
  bool committedBelief;
  bool discourseUnit;
  bool entityMention;
  bool opinion;
  bool partOfSpeech;
  bool passage;
  bool prosodicPhrase;
  bool sarcasm;
  bool sentence;
  bool story;
  bool syntacticChunk;
  bool utterance;
  bool coreference;
  bool dependency;
  bool entity;
  bool hltContentContainer;
  bool interPausalUnit;
  bool jointRelationCoreference;
  bool paraphrase;
  bool relation;
  bool sentenceSimilarity;
  bool chunkUnion;
} _HltContentUnion__isset;

class HltContentUnion {
 public:

  static const char* ascii_fingerprint; // = "344AB6F24EE4EADE7F4019847C9FA0A7";
  static const uint8_t binary_fingerprint[16]; // = {0x34,0x4A,0xB6,0xF2,0x4E,0xE4,0xEA,0xDE,0x7F,0x40,0x19,0x84,0x7C,0x9F,0xA0,0xA7};

  HltContentUnion() {
  }

  virtual ~HltContentUnion() throw() {}

  AnomalousText anomalousText;
  Argument argument;
  Chunk chunk;
  CommittedBelief committedBelief;
  DiscourseUnit discourseUnit;
  EntityMention entityMention;
  Opinion opinion;
  PartOfSpeech partOfSpeech;
  Passage passage;
  ProsodicPhrase prosodicPhrase;
  Sarcasm sarcasm;
  Sentence sentence;
  Story story;
  SyntacticChunk syntacticChunk;
  Utterance utterance;
  Coreference coreference;
  Dependency dependency;
  Entity entity;
  HltContentContainer hltContentContainer;
  InterPausalUnit interPausalUnit;
  JointRelationCoreference jointRelationCoreference;
  Paraphrase paraphrase;
  Relation relation;
  SentenceSimilarity sentenceSimilarity;
  ChunkUnion chunkUnion;

  _HltContentUnion__isset __isset;

  void __set_anomalousText(const AnomalousText& val) {
    anomalousText = val;
  }

  void __set_argument(const Argument& val) {
    argument = val;
  }

  void __set_chunk(const Chunk& val) {
    chunk = val;
  }

  void __set_committedBelief(const CommittedBelief& val) {
    committedBelief = val;
  }

  void __set_discourseUnit(const DiscourseUnit& val) {
    discourseUnit = val;
  }

  void __set_entityMention(const EntityMention& val) {
    entityMention = val;
  }

  void __set_opinion(const Opinion& val) {
    opinion = val;
  }

  void __set_partOfSpeech(const PartOfSpeech& val) {
    partOfSpeech = val;
  }

  void __set_passage(const Passage& val) {
    passage = val;
  }

  void __set_prosodicPhrase(const ProsodicPhrase& val) {
    prosodicPhrase = val;
  }

  void __set_sarcasm(const Sarcasm& val) {
    sarcasm = val;
  }

  void __set_sentence(const Sentence& val) {
    sentence = val;
  }

  void __set_story(const Story& val) {
    story = val;
  }

  void __set_syntacticChunk(const SyntacticChunk& val) {
    syntacticChunk = val;
  }

  void __set_utterance(const Utterance& val) {
    utterance = val;
  }

  void __set_coreference(const Coreference& val) {
    coreference = val;
  }

  void __set_dependency(const Dependency& val) {
    dependency = val;
  }

  void __set_entity(const Entity& val) {
    entity = val;
  }

  void __set_hltContentContainer(const HltContentContainer& val) {
    hltContentContainer = val;
  }

  void __set_interPausalUnit(const InterPausalUnit& val) {
    interPausalUnit = val;
  }

  void __set_jointRelationCoreference(const JointRelationCoreference& val) {
    jointRelationCoreference = val;
  }

  void __set_paraphrase(const Paraphrase& val) {
    paraphrase = val;
  }

  void __set_relation(const Relation& val) {
    relation = val;
  }

  void __set_sentenceSimilarity(const SentenceSimilarity& val) {
    sentenceSimilarity = val;
  }

  void __set_chunkUnion(const ChunkUnion& val) {
    chunkUnion = val;
  }

  bool operator == (const HltContentUnion & rhs) const
  {
    if (!(anomalousText == rhs.anomalousText))
      return false;
    if (!(argument == rhs.argument))
      return false;
    if (!(chunk == rhs.chunk))
      return false;
    if (!(committedBelief == rhs.committedBelief))
      return false;
    if (!(discourseUnit == rhs.discourseUnit))
      return false;
    if (!(entityMention == rhs.entityMention))
      return false;
    if (!(opinion == rhs.opinion))
      return false;
    if (!(partOfSpeech == rhs.partOfSpeech))
      return false;
    if (!(passage == rhs.passage))
      return false;
    if (!(prosodicPhrase == rhs.prosodicPhrase))
      return false;
    if (!(sarcasm == rhs.sarcasm))
      return false;
    if (!(sentence == rhs.sentence))
      return false;
    if (!(story == rhs.story))
      return false;
    if (!(syntacticChunk == rhs.syntacticChunk))
      return false;
    if (!(utterance == rhs.utterance))
      return false;
    if (!(coreference == rhs.coreference))
      return false;
    if (!(dependency == rhs.dependency))
      return false;
    if (!(entity == rhs.entity))
      return false;
    if (!(hltContentContainer == rhs.hltContentContainer))
      return false;
    if (!(interPausalUnit == rhs.interPausalUnit))
      return false;
    if (!(jointRelationCoreference == rhs.jointRelationCoreference))
      return false;
    if (!(paraphrase == rhs.paraphrase))
      return false;
    if (!(relation == rhs.relation))
      return false;
    if (!(sentenceSimilarity == rhs.sentenceSimilarity))
      return false;
    if (!(chunkUnion == rhs.chunkUnion))
      return false;
    return true;
  }
  bool operator != (const HltContentUnion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HltContentUnion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(HltContentUnion &a, HltContentUnion &b);

}}} // namespace

#endif
