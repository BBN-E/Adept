#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::io::Types;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::io::Reader_readConversationFile_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readConversationFile_args->mk_accessors( qw( path utterances speakers title ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{path} = undef;
  $self->{utterances} = undef;
  $self->{speakers} = undef;
  $self->{title} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{utterances}) {
      $self->{utterances} = $vals->{utterances};
    }
    if (defined $vals->{speakers}) {
      $self->{speakers} = $vals->{speakers};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readConversationFile_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{path});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size154 = 0;
          $self->{utterances} = [];
          my $_etype157 = 0;
          $xfer += $input->readListBegin(\$_etype157, \$_size154);
          for (my $_i158 = 0; $_i158 < $_size154; ++$_i158)
          {
            my $elem159 = undef;
            $elem159 = new thrift::adept::common::Utterance();
            $xfer += $elem159->read($input);
            push(@{$self->{utterances}},$elem159);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size160 = 0;
          $self->{speakers} = [];
          my $_etype163 = 0;
          $xfer += $input->readListBegin(\$_etype163, \$_size160);
          for (my $_i164 = 0; $_i164 < $_size160; ++$_i164)
          {
            my $elem165 = undef;
            $xfer += $input->readString(\$elem165);
            push(@{$self->{speakers}},$elem165);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readConversationFile_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
    $xfer += $output->writeString($self->{path});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{utterances}) {
    $xfer += $output->writeFieldBegin('utterances', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{utterances}}));
      {
        foreach my $iter166 (@{$self->{utterances}}) 
        {
          $xfer += ${iter166}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{speakers}) {
    $xfer += $output->writeFieldBegin('speakers', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{speakers}}));
      {
        foreach my $iter167 (@{$self->{speakers}}) 
        {
          $xfer += $output->writeString($iter167);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 4);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readConversationFile_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readConversationFile_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readConversationFile_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readConversationFile_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readEREFile_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readEREFile_args->mk_accessors( qw( path docId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{path} = undef;
  $self->{docId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{docId}) {
      $self->{docId} = $vals->{docId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readEREFile_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{path});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{docId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readEREFile_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
    $xfer += $output->writeString($self->{path});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{docId}) {
    $xfer += $output->writeFieldBegin('docId', TType::STRING, 2);
    $xfer += $output->writeString($self->{docId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readEREFile_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readEREFile_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readEREFile_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new thrift::adept::io::EREDocument();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readEREFile_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_EREtoHltContentContainer_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_EREtoHltContentContainer_args->mk_accessors( qw( EREPath XMLPath ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{EREPath} = undef;
  $self->{XMLPath} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{EREPath}) {
      $self->{EREPath} = $vals->{EREPath};
    }
    if (defined $vals->{XMLPath}) {
      $self->{XMLPath} = $vals->{XMLPath};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_EREtoHltContentContainer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{EREPath});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{XMLPath});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_EREtoHltContentContainer_args');
  if (defined $self->{EREPath}) {
    $xfer += $output->writeFieldBegin('EREPath', TType::STRING, 1);
    $xfer += $output->writeString($self->{EREPath});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{XMLPath}) {
    $xfer += $output->writeFieldBegin('XMLPath', TType::STRING, 2);
    $xfer += $output->writeString($self->{XMLPath});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_EREtoHltContentContainer_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_EREtoHltContentContainer_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_EREtoHltContentContainer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new thrift::adept::common::HltContentContainer();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_EREtoHltContentContainer_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_getSentences_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_getSentences_args->mk_accessors( qw( conllDoc ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{conllDoc} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{conllDoc}) {
      $self->{conllDoc} = $vals->{conllDoc};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_getSentences_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{conllDoc} = new thrift::adept::io::CoNLLDocument();
        $xfer += $self->{conllDoc}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_getSentences_args');
  if (defined $self->{conllDoc}) {
    $xfer += $output->writeFieldBegin('conllDoc', TType::STRUCT, 1);
    $xfer += $self->{conllDoc}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_getSentences_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_getSentences_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_getSentences_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size168 = 0;
          $self->{success} = [];
          my $_etype171 = 0;
          $xfer += $input->readListBegin(\$_etype171, \$_size168);
          for (my $_i172 = 0; $_i172 < $_size168; ++$_i172)
          {
            my $elem173 = undef;
            $elem173 = new thrift::adept::common::Sentence();
            $xfer += $elem173->read($input);
            push(@{$self->{success}},$elem173);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_getSentences_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter174 (@{$self->{success}}) 
        {
          $xfer += ${iter174}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readCoNLLFile_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readCoNLLFile_args->mk_accessors( qw( path ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readCoNLLFile_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{path});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readCoNLLFile_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
    $xfer += $output->writeString($self->{path});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readCoNLLFile_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readCoNLLFile_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readCoNLLFile_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new thrift::adept::io::CoNLLDocument();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readCoNLLFile_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_CoNLLtoHltContentContainer_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_CoNLLtoHltContentContainer_args->mk_accessors( qw( filepath ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{filepath} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{filepath}) {
      $self->{filepath} = $vals->{filepath};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_CoNLLtoHltContentContainer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filepath});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_CoNLLtoHltContentContainer_args');
  if (defined $self->{filepath}) {
    $xfer += $output->writeFieldBegin('filepath', TType::STRING, 1);
    $xfer += $output->writeString($self->{filepath});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_CoNLLtoHltContentContainer_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_CoNLLtoHltContentContainer_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_CoNLLtoHltContentContainer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new thrift::adept::common::HltContentContainer();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_CoNLLtoHltContentContainer_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_getAbsolutePathFromClasspathOrFileSystem_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_getAbsolutePathFromClasspathOrFileSystem_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_getAbsolutePathFromClasspathOrFileSystem_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_getAbsolutePathFromClasspathOrFileSystem_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readFileIntoString_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readFileIntoString_args->mk_accessors( qw( path ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readFileIntoString_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{path});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readFileIntoString_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRING, 1);
    $xfer += $output->writeString($self->{path});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readFileIntoString_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readFileIntoString_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readFileIntoString_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readFileIntoString_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readFileIntoLines_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readFileIntoLines_args->mk_accessors( qw( filename lines ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{filename} = undef;
  $self->{lines} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{filename}) {
      $self->{filename} = $vals->{filename};
    }
    if (defined $vals->{lines}) {
      $self->{lines} = $vals->{lines};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readFileIntoLines_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size175 = 0;
          $self->{lines} = [];
          my $_etype178 = 0;
          $xfer += $input->readListBegin(\$_etype178, \$_size175);
          for (my $_i179 = 0; $_i179 < $_size175; ++$_i179)
          {
            my $elem180 = undef;
            $xfer += $input->readString(\$elem180);
            push(@{$self->{lines}},$elem180);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readFileIntoLines_args');
  if (defined $self->{filename}) {
    $xfer += $output->writeFieldBegin('filename', TType::STRING, 1);
    $xfer += $output->writeString($self->{filename});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lines}) {
    $xfer += $output->writeFieldBegin('lines', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{lines}}));
      {
        foreach my $iter181 (@{$self->{lines}}) 
        {
          $xfer += $output->writeString($iter181);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_readFileIntoLines_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_readFileIntoLines_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_readFileIntoLines_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_readFileIntoLines_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_fileToLines_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_fileToLines_args->mk_accessors( qw( filename ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{filename} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{filename}) {
      $self->{filename} = $vals->{filename};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_fileToLines_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filename});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_fileToLines_args');
  if (defined $self->{filename}) {
    $xfer += $output->writeFieldBegin('filename', TType::STRING, 1);
    $xfer += $output->writeString($self->{filename});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_fileToLines_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_fileToLines_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_fileToLines_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size182 = 0;
          $self->{success} = [];
          my $_etype185 = 0;
          $xfer += $input->readListBegin(\$_etype185, \$_size182);
          for (my $_i186 = 0; $_i186 < $_size182; ++$_i186)
          {
            my $elem187 = undef;
            $xfer += $input->readString(\$elem187);
            push(@{$self->{success}},$elem187);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_fileToLines_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter188 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter188);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_checkSurrogates_args;
use base qw(Class::Accessor);
thrift::adept::io::Reader_checkSurrogates_args->mk_accessors( qw( text ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{text} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{text}) {
      $self->{text} = $vals->{text};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_checkSurrogates_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{text});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_checkSurrogates_args');
  if (defined $self->{text}) {
    $xfer += $output->writeFieldBegin('text', TType::STRING, 1);
    $xfer += $output->writeString($self->{text});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::Reader_checkSurrogates_result;
use base qw(Class::Accessor);
thrift::adept::io::Reader_checkSurrogates_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Reader_checkSurrogates_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Reader_checkSurrogates_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::io::ReaderIf;

use strict;


sub readConversationFile{
  my $self = shift;
  my $path = shift;
  my $utterances = shift;
  my $speakers = shift;
  my $title = shift;

  die 'implement interface';
}

sub readEREFile{
  my $self = shift;
  my $path = shift;
  my $docId = shift;

  die 'implement interface';
}

sub EREtoHltContentContainer{
  my $self = shift;
  my $EREPath = shift;
  my $XMLPath = shift;

  die 'implement interface';
}

sub getSentences{
  my $self = shift;
  my $conllDoc = shift;

  die 'implement interface';
}

sub readCoNLLFile{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}

sub CoNLLtoHltContentContainer{
  my $self = shift;
  my $filepath = shift;

  die 'implement interface';
}

sub getAbsolutePathFromClasspathOrFileSystem{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub readFileIntoString{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}

sub readFileIntoLines{
  my $self = shift;
  my $filename = shift;
  my $lines = shift;

  die 'implement interface';
}

sub fileToLines{
  my $self = shift;
  my $filename = shift;

  die 'implement interface';
}

sub checkSurrogates{
  my $self = shift;
  my $text = shift;

  die 'implement interface';
}

package thrift::adept::io::ReaderRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub readConversationFile{
  my ($self, $request) = @_;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $utterances = ($request->{'utterances'}) ? $request->{'utterances'} : undef;
  my $speakers = ($request->{'speakers'}) ? $request->{'speakers'} : undef;
  my $title = ($request->{'title'}) ? $request->{'title'} : undef;
  return $self->{impl}->readConversationFile($path, $utterances, $speakers, $title);
}

sub readEREFile{
  my ($self, $request) = @_;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $docId = ($request->{'docId'}) ? $request->{'docId'} : undef;
  return $self->{impl}->readEREFile($path, $docId);
}

sub EREtoHltContentContainer{
  my ($self, $request) = @_;

  my $EREPath = ($request->{'EREPath'}) ? $request->{'EREPath'} : undef;
  my $XMLPath = ($request->{'XMLPath'}) ? $request->{'XMLPath'} : undef;
  return $self->{impl}->EREtoHltContentContainer($EREPath, $XMLPath);
}

sub getSentences{
  my ($self, $request) = @_;

  my $conllDoc = ($request->{'conllDoc'}) ? $request->{'conllDoc'} : undef;
  return $self->{impl}->getSentences($conllDoc);
}

sub readCoNLLFile{
  my ($self, $request) = @_;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->readCoNLLFile($path);
}

sub CoNLLtoHltContentContainer{
  my ($self, $request) = @_;

  my $filepath = ($request->{'filepath'}) ? $request->{'filepath'} : undef;
  return $self->{impl}->CoNLLtoHltContentContainer($filepath);
}

sub getAbsolutePathFromClasspathOrFileSystem{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->getAbsolutePathFromClasspathOrFileSystem($name);
}

sub readFileIntoString{
  my ($self, $request) = @_;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->readFileIntoString($path);
}

sub readFileIntoLines{
  my ($self, $request) = @_;

  my $filename = ($request->{'filename'}) ? $request->{'filename'} : undef;
  my $lines = ($request->{'lines'}) ? $request->{'lines'} : undef;
  return $self->{impl}->readFileIntoLines($filename, $lines);
}

sub fileToLines{
  my ($self, $request) = @_;

  my $filename = ($request->{'filename'}) ? $request->{'filename'} : undef;
  return $self->{impl}->fileToLines($filename);
}

sub checkSurrogates{
  my ($self, $request) = @_;

  my $text = ($request->{'text'}) ? $request->{'text'} : undef;
  return $self->{impl}->checkSurrogates($text);
}

package thrift::adept::io::ReaderClient;


use base qw(thrift::adept::io::ReaderIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub readConversationFile{
  my $self = shift;
  my $path = shift;
  my $utterances = shift;
  my $speakers = shift;
  my $title = shift;

    $self->send_readConversationFile($path, $utterances, $speakers, $title);
  return $self->recv_readConversationFile();
}

sub send_readConversationFile{
  my $self = shift;
  my $path = shift;
  my $utterances = shift;
  my $speakers = shift;
  my $title = shift;

  $self->{output}->writeMessageBegin('readConversationFile', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_readConversationFile_args();
  $args->{path} = $path;
  $args->{utterances} = $utterances;
  $args->{speakers} = $speakers;
  $args->{title} = $title;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_readConversationFile{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_readConversationFile_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "readConversationFile failed: unknown result";
}
sub readEREFile{
  my $self = shift;
  my $path = shift;
  my $docId = shift;

    $self->send_readEREFile($path, $docId);
  return $self->recv_readEREFile();
}

sub send_readEREFile{
  my $self = shift;
  my $path = shift;
  my $docId = shift;

  $self->{output}->writeMessageBegin('readEREFile', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_readEREFile_args();
  $args->{path} = $path;
  $args->{docId} = $docId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_readEREFile{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_readEREFile_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "readEREFile failed: unknown result";
}
sub EREtoHltContentContainer{
  my $self = shift;
  my $EREPath = shift;
  my $XMLPath = shift;

    $self->send_EREtoHltContentContainer($EREPath, $XMLPath);
  return $self->recv_EREtoHltContentContainer();
}

sub send_EREtoHltContentContainer{
  my $self = shift;
  my $EREPath = shift;
  my $XMLPath = shift;

  $self->{output}->writeMessageBegin('EREtoHltContentContainer', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_EREtoHltContentContainer_args();
  $args->{EREPath} = $EREPath;
  $args->{XMLPath} = $XMLPath;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_EREtoHltContentContainer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_EREtoHltContentContainer_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "EREtoHltContentContainer failed: unknown result";
}
sub getSentences{
  my $self = shift;
  my $conllDoc = shift;

    $self->send_getSentences($conllDoc);
  return $self->recv_getSentences();
}

sub send_getSentences{
  my $self = shift;
  my $conllDoc = shift;

  $self->{output}->writeMessageBegin('getSentences', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_getSentences_args();
  $args->{conllDoc} = $conllDoc;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getSentences{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_getSentences_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getSentences failed: unknown result";
}
sub readCoNLLFile{
  my $self = shift;
  my $path = shift;

    $self->send_readCoNLLFile($path);
  return $self->recv_readCoNLLFile();
}

sub send_readCoNLLFile{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('readCoNLLFile', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_readCoNLLFile_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_readCoNLLFile{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_readCoNLLFile_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "readCoNLLFile failed: unknown result";
}
sub CoNLLtoHltContentContainer{
  my $self = shift;
  my $filepath = shift;

    $self->send_CoNLLtoHltContentContainer($filepath);
  return $self->recv_CoNLLtoHltContentContainer();
}

sub send_CoNLLtoHltContentContainer{
  my $self = shift;
  my $filepath = shift;

  $self->{output}->writeMessageBegin('CoNLLtoHltContentContainer', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_CoNLLtoHltContentContainer_args();
  $args->{filepath} = $filepath;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_CoNLLtoHltContentContainer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_CoNLLtoHltContentContainer_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "CoNLLtoHltContentContainer failed: unknown result";
}
sub getAbsolutePathFromClasspathOrFileSystem{
  my $self = shift;
  my $name = shift;

    $self->send_getAbsolutePathFromClasspathOrFileSystem($name);
  return $self->recv_getAbsolutePathFromClasspathOrFileSystem();
}

sub send_getAbsolutePathFromClasspathOrFileSystem{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('getAbsolutePathFromClasspathOrFileSystem', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getAbsolutePathFromClasspathOrFileSystem{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getAbsolutePathFromClasspathOrFileSystem failed: unknown result";
}
sub readFileIntoString{
  my $self = shift;
  my $path = shift;

    $self->send_readFileIntoString($path);
  return $self->recv_readFileIntoString();
}

sub send_readFileIntoString{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('readFileIntoString', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_readFileIntoString_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_readFileIntoString{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_readFileIntoString_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "readFileIntoString failed: unknown result";
}
sub readFileIntoLines{
  my $self = shift;
  my $filename = shift;
  my $lines = shift;

    $self->send_readFileIntoLines($filename, $lines);
  return $self->recv_readFileIntoLines();
}

sub send_readFileIntoLines{
  my $self = shift;
  my $filename = shift;
  my $lines = shift;

  $self->{output}->writeMessageBegin('readFileIntoLines', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_readFileIntoLines_args();
  $args->{filename} = $filename;
  $args->{lines} = $lines;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_readFileIntoLines{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_readFileIntoLines_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "readFileIntoLines failed: unknown result";
}
sub fileToLines{
  my $self = shift;
  my $filename = shift;

    $self->send_fileToLines($filename);
  return $self->recv_fileToLines();
}

sub send_fileToLines{
  my $self = shift;
  my $filename = shift;

  $self->{output}->writeMessageBegin('fileToLines', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_fileToLines_args();
  $args->{filename} = $filename;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fileToLines{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_fileToLines_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "fileToLines failed: unknown result";
}
sub checkSurrogates{
  my $self = shift;
  my $text = shift;

    $self->send_checkSurrogates($text);
  return $self->recv_checkSurrogates();
}

sub send_checkSurrogates{
  my $self = shift;
  my $text = shift;

  $self->{output}->writeMessageBegin('checkSurrogates', TMessageType::CALL, $self->{seqid});
  my $args = new thrift::adept::io::Reader_checkSurrogates_args();
  $args->{text} = $text;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkSurrogates{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new thrift::adept::io::Reader_checkSurrogates_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "checkSurrogates failed: unknown result";
}
package thrift::adept::io::ReaderProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_readConversationFile {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_readConversationFile_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_readConversationFile_result();
    $result->{success} = $self->{handler}->readConversationFile($args->path, $args->utterances, $args->speakers, $args->title);
    $output->writeMessageBegin('readConversationFile', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_readEREFile {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_readEREFile_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_readEREFile_result();
    $result->{success} = $self->{handler}->readEREFile($args->path, $args->docId);
    $output->writeMessageBegin('readEREFile', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_EREtoHltContentContainer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_EREtoHltContentContainer_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_EREtoHltContentContainer_result();
    $result->{success} = $self->{handler}->EREtoHltContentContainer($args->EREPath, $args->XMLPath);
    $output->writeMessageBegin('EREtoHltContentContainer', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getSentences {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_getSentences_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_getSentences_result();
    $result->{success} = $self->{handler}->getSentences($args->conllDoc);
    $output->writeMessageBegin('getSentences', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_readCoNLLFile {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_readCoNLLFile_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_readCoNLLFile_result();
    $result->{success} = $self->{handler}->readCoNLLFile($args->path);
    $output->writeMessageBegin('readCoNLLFile', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_CoNLLtoHltContentContainer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_CoNLLtoHltContentContainer_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_CoNLLtoHltContentContainer_result();
    $result->{success} = $self->{handler}->CoNLLtoHltContentContainer($args->filepath);
    $output->writeMessageBegin('CoNLLtoHltContentContainer', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getAbsolutePathFromClasspathOrFileSystem {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_getAbsolutePathFromClasspathOrFileSystem_result();
    $result->{success} = $self->{handler}->getAbsolutePathFromClasspathOrFileSystem($args->name);
    $output->writeMessageBegin('getAbsolutePathFromClasspathOrFileSystem', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_readFileIntoString {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_readFileIntoString_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_readFileIntoString_result();
    $result->{success} = $self->{handler}->readFileIntoString($args->path);
    $output->writeMessageBegin('readFileIntoString', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_readFileIntoLines {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_readFileIntoLines_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_readFileIntoLines_result();
    $result->{success} = $self->{handler}->readFileIntoLines($args->filename, $args->lines);
    $output->writeMessageBegin('readFileIntoLines', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fileToLines {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_fileToLines_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_fileToLines_result();
    $result->{success} = $self->{handler}->fileToLines($args->filename);
    $output->writeMessageBegin('fileToLines', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkSurrogates {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new thrift::adept::io::Reader_checkSurrogates_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new thrift::adept::io::Reader_checkSurrogates_result();
    $result->{success} = $self->{handler}->checkSurrogates($args->text);
    $output->writeMessageBegin('checkSurrogates', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
