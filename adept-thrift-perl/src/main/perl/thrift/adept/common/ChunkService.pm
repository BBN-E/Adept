#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;
use thrift::adept::common::ItemService;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::ChunkService_Contains_args;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_Contains_args->mk_accessors( qw( chunk ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{chunk} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{chunk}) {
                                                                            $self->{chunk} = $vals->{chunk};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_Contains_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^1$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{chunk} = new thrift::adept::common::ChunkUnion();
                                                                              $xfer += $self->{chunk}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_Contains_args');
                                                                        if (defined $self->{chunk}) {
                                                                          $xfer += $output->writeFieldBegin('chunk', TType::STRUCT, 1);
                                                                          $xfer += $self->{chunk}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_Contains_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_Contains_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_Contains_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::BOOL) {
                                                                              $xfer += $input->readBool(\$self->{success});
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_Contains_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
                                                                          $xfer += $output->writeBool($self->{success});
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_equals_args;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_equals_args->mk_accessors( qw( obj ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{obj} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{obj}) {
                                                                            $self->{obj} = $vals->{obj};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_equals_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^1$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{obj} = new thrift::adept::common::ChunkUnion();
                                                                              $xfer += $self->{obj}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_equals_args');
                                                                        if (defined $self->{obj}) {
                                                                          $xfer += $output->writeFieldBegin('obj', TType::STRUCT, 1);
                                                                          $xfer += $self->{obj}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_equals_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_equals_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_equals_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::BOOL) {
                                                                              $xfer += $input->readBool(\$self->{success});
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_equals_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
                                                                          $xfer += $output->writeBool($self->{success});
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getContainingChunk_args;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_getContainingChunk_args->mk_accessors( qw( chunks ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{chunks} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{chunks}) {
                                                                            $self->{chunks} = $vals->{chunks};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getContainingChunk_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^1$/ && do{                                                                            if ($ftype == TType::LIST) {
                                                                              {
                                                                                my $_size752 = 0;
                                                                                $self->{chunks} = [];
                                                                                my $_etype755 = 0;
                                                                                $xfer += $input->readListBegin(\$_etype755, \$_size752);
                                                                                for (my $_i756 = 0; $_i756 < $_size752; ++$_i756)
                                                                                {
                                                                                  my $elem757 = undef;
                                                                                  $elem757 = new thrift::adept::common::ChunkUnion();
                                                                                  $xfer += $elem757->read($input);
                                                                                  push(@{$self->{chunks}},$elem757);
                                                                                }
                                                                                $xfer += $input->readListEnd();
                                                                              }
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getContainingChunk_args');
                                                                        if (defined $self->{chunks}) {
                                                                          $xfer += $output->writeFieldBegin('chunks', TType::LIST, 1);
                                                                          {
                                                                            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{chunks}}));
                                                                            {
                                                                              foreach my $iter758 (@{$self->{chunks}}) 
                                                                              {
                                                                                $xfer += ${iter758}->write($output);
                                                                              }
                                                                            }
                                                                            $xfer += $output->writeListEnd();
                                                                          }
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getContainingChunk_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_getContainingChunk_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getContainingChunk_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{success} = new thrift::adept::common::ChunkUnion();
                                                                              $xfer += $self->{success}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getContainingChunk_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                          $xfer += $self->{success}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getMatchingChunk_args;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_getMatchingChunk_args->mk_accessors( qw( chunks ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{chunks} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{chunks}) {
                                                                            $self->{chunks} = $vals->{chunks};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getMatchingChunk_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^1$/ && do{                                                                            if ($ftype == TType::LIST) {
                                                                              {
                                                                                my $_size759 = 0;
                                                                                $self->{chunks} = [];
                                                                                my $_etype762 = 0;
                                                                                $xfer += $input->readListBegin(\$_etype762, \$_size759);
                                                                                for (my $_i763 = 0; $_i763 < $_size759; ++$_i763)
                                                                                {
                                                                                  my $elem764 = undef;
                                                                                  $elem764 = new thrift::adept::common::ChunkUnion();
                                                                                  $xfer += $elem764->read($input);
                                                                                  push(@{$self->{chunks}},$elem764);
                                                                                }
                                                                                $xfer += $input->readListEnd();
                                                                              }
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getMatchingChunk_args');
                                                                        if (defined $self->{chunks}) {
                                                                          $xfer += $output->writeFieldBegin('chunks', TType::LIST, 1);
                                                                          {
                                                                            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{chunks}}));
                                                                            {
                                                                              foreach my $iter765 (@{$self->{chunks}}) 
                                                                              {
                                                                                $xfer += ${iter765}->write($output);
                                                                              }
                                                                            }
                                                                            $xfer += $output->writeListEnd();
                                                                          }
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getMatchingChunk_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_getMatchingChunk_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getMatchingChunk_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{success} = new thrift::adept::common::ChunkUnion();
                                                                              $xfer += $self->{success}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getMatchingChunk_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                          $xfer += $self->{success}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getTokenOffset_args;
use base qw(Class::Accessor);

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getTokenOffset_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getTokenOffset_args');
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getTokenOffset_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_getTokenOffset_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getTokenOffset_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{success} = new thrift::adept::common::TokenOffset();
                                                                              $xfer += $self->{success}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getTokenOffset_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                          $xfer += $self->{success}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getTokenStream_args;
use base qw(Class::Accessor);

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getTokenStream_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getTokenStream_args');
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_getTokenStream_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_getTokenStream_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_getTokenStream_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{success} = new thrift::adept::common::TokenStream();
                                                                              $xfer += $self->{success}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_getTokenStream_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                          $xfer += $self->{success}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_hashCode_args;
use base qw(Class::Accessor);

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_hashCode_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_hashCode_args');
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_hashCode_result;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_hashCode_result->mk_accessors( qw( success ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{success} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{success}) {
                                                                            $self->{success} = $vals->{success};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_hashCode_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^0$/ && do{                                                                            if ($ftype == TType::I32) {
                                                                              $xfer += $input->readI32(\$self->{success});
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_hashCode_result');
                                                                        if (defined $self->{success}) {
                                                                          $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                                                                          $xfer += $output->writeI32($self->{success});
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_setTokenStream_args;
use base qw(Class::Accessor);
thrift::adept::common::ChunkService_setTokenStream_args->mk_accessors( qw( tokenStream ) );

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        $self->{tokenStream} = undef;
                                                                        if (UNIVERSAL::isa($vals,'HASH')) {
                                                                          if (defined $vals->{tokenStream}) {
                                                                            $self->{tokenStream} = $vals->{tokenStream};
                                                                          }
                                                                        }
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_setTokenStream_args';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                            /^1$/ && do{                                                                            if ($ftype == TType::STRUCT) {
                                                                              $self->{tokenStream} = new thrift::adept::common::TokenStream();
                                                                              $xfer += $self->{tokenStream}->read($input);
                                                                            } else {
                                                                              $xfer += $input->skip($ftype);
                                                                            }
                                                                            last; };
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_setTokenStream_args');
                                                                        if (defined $self->{tokenStream}) {
                                                                          $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 1);
                                                                          $xfer += $self->{tokenStream}->write($output);
                                                                          $xfer += $output->writeFieldEnd();
                                                                        }
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkService_setTokenStream_result;
use base qw(Class::Accessor);

sub new {
                                                                        my $classname = shift;
                                                                        my $self      = {};
                                                                        my $vals      = shift || {};
                                                                        return bless ($self, $classname);
}

sub getName {
                                                                        return 'ChunkService_setTokenStream_result';
                                                                      }

sub read {
                                                                        my ($self, $input) = @_;
                                                                        my $xfer  = 0;
                                                                        my $fname;
                                                                        my $ftype = 0;
                                                                        my $fid   = 0;
                                                                        $xfer += $input->readStructBegin(\$fname);
                                                                        while (1) 
                                                                        {
                                                                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                          if ($ftype == TType::STOP) {
                                                                            last;
                                                                          }
                                                                          SWITCH: for($fid)
                                                                          {
                                                                              $xfer += $input->skip($ftype);
                                                                          }
                                                                          $xfer += $input->readFieldEnd();
                                                                        }
                                                                        $xfer += $input->readStructEnd();
                                                                        return $xfer;
                                                                      }

sub write {
                                                                        my ($self, $output) = @_;
                                                                        my $xfer   = 0;
                                                                        $xfer += $output->writeStructBegin('ChunkService_setTokenStream_result');
                                                                        $xfer += $output->writeFieldStop();
                                                                        $xfer += $output->writeStructEnd();
                                                                        return $xfer;
                                                                      }

package thrift::adept::common::ChunkServiceIf;

use strict;
use base qw(thrift::adept::common::ItemServiceIf);

sub Contains{
  my $self = shift;
  my $chunk = shift;

  die 'implement interface';
}

sub equals{
  my $self = shift;
  my $obj = shift;

  die 'implement interface';
}

sub getContainingChunk{
  my $self = shift;
  my $chunks = shift;

  die 'implement interface';
}

sub getMatchingChunk{
  my $self = shift;
  my $chunks = shift;

  die 'implement interface';
}

sub getTokenOffset{
  my $self = shift;

  die 'implement interface';
}

sub getTokenStream{
  my $self = shift;

  die 'implement interface';
}

sub hashCode{
  my $self = shift;

  die 'implement interface';
}

sub setTokenStream{
  my $self = shift;
  my $tokenStream = shift;

  die 'implement interface';
}

package thrift::adept::common::ChunkServiceRest;

use strict;
use base qw(thrift::adept::common::ItemServiceRest);

sub Contains{
                                                                        my ($self, $request) = @_;

                                                                        my $chunk = ($request->{'chunk'}) ? $request->{'chunk'} : undef;
                                                                        return $self->{impl}->Contains($chunk);
                                                                      }

sub equals{
                                                                        my ($self, $request) = @_;

                                                                        my $obj = ($request->{'obj'}) ? $request->{'obj'} : undef;
                                                                        return $self->{impl}->equals($obj);
                                                                      }

sub getContainingChunk{
                                                                        my ($self, $request) = @_;

                                                                        my $chunks = ($request->{'chunks'}) ? $request->{'chunks'} : undef;
                                                                        return $self->{impl}->getContainingChunk($chunks);
                                                                      }

sub getMatchingChunk{
                                                                        my ($self, $request) = @_;

                                                                        my $chunks = ($request->{'chunks'}) ? $request->{'chunks'} : undef;
                                                                        return $self->{impl}->getMatchingChunk($chunks);
                                                                      }

sub getTokenOffset{
                                                                        my ($self, $request) = @_;

                                                                        return $self->{impl}->getTokenOffset();
                                                                      }

sub getTokenStream{
                                                                        my ($self, $request) = @_;

                                                                        return $self->{impl}->getTokenStream();
                                                                      }

sub hashCode{
                                                                        my ($self, $request) = @_;

                                                                        return $self->{impl}->hashCode();
                                                                      }

sub setTokenStream{
                                                                        my ($self, $request) = @_;

                                                                        my $tokenStream = ($request->{'tokenStream'}) ? $request->{'tokenStream'} : undef;
                                                                        return $self->{impl}->setTokenStream($tokenStream);
                                                                      }

package thrift::adept::common::ChunkServiceClient;

use base qw(thrift::adept::common::ItemServiceClient);
use base qw(thrift::adept::common::ChunkServiceIf);
sub new {
                                                                        my ($classname, $input, $output) = @_;
                                                                        my $self      = {};
                                                                        $self = $classname->SUPER::new($input, $output);
                                                                        return bless($self,$classname);
}

sub Contains{
  my $self = shift;
  my $chunk = shift;

                                                                                                                                                $self->send_Contains($chunk);
                                                                        return $self->recv_Contains();
}

sub send_Contains{
  my $self = shift;
  my $chunk = shift;

                                                                        $self->{output}->writeMessageBegin('Contains', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_Contains_args();
                                                                        $args->{chunk} = $chunk;
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_Contains{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_Contains_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "Contains failed: unknown result";
}
sub equals{
  my $self = shift;
  my $obj = shift;

                                                                                                                                                $self->send_equals($obj);
                                                                        return $self->recv_equals();
}

sub send_equals{
  my $self = shift;
  my $obj = shift;

                                                                        $self->{output}->writeMessageBegin('equals', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_equals_args();
                                                                        $args->{obj} = $obj;
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_equals{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_equals_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "equals failed: unknown result";
}
sub getContainingChunk{
  my $self = shift;
  my $chunks = shift;

                                                                                                                                                $self->send_getContainingChunk($chunks);
                                                                        return $self->recv_getContainingChunk();
}

sub send_getContainingChunk{
  my $self = shift;
  my $chunks = shift;

                                                                        $self->{output}->writeMessageBegin('getContainingChunk', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_getContainingChunk_args();
                                                                        $args->{chunks} = $chunks;
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_getContainingChunk{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_getContainingChunk_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "getContainingChunk failed: unknown result";
}
sub getMatchingChunk{
  my $self = shift;
  my $chunks = shift;

                                                                                                                                                $self->send_getMatchingChunk($chunks);
                                                                        return $self->recv_getMatchingChunk();
}

sub send_getMatchingChunk{
  my $self = shift;
  my $chunks = shift;

                                                                        $self->{output}->writeMessageBegin('getMatchingChunk', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_getMatchingChunk_args();
                                                                        $args->{chunks} = $chunks;
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_getMatchingChunk{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_getMatchingChunk_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "getMatchingChunk failed: unknown result";
}
sub getTokenOffset{
  my $self = shift;

                                                                                                                                                $self->send_getTokenOffset();
                                                                        return $self->recv_getTokenOffset();
}

sub send_getTokenOffset{
  my $self = shift;

                                                                        $self->{output}->writeMessageBegin('getTokenOffset', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_getTokenOffset_args();
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_getTokenOffset{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_getTokenOffset_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "getTokenOffset failed: unknown result";
}
sub getTokenStream{
  my $self = shift;

                                                                                                                                                $self->send_getTokenStream();
                                                                        return $self->recv_getTokenStream();
}

sub send_getTokenStream{
  my $self = shift;

                                                                        $self->{output}->writeMessageBegin('getTokenStream', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_getTokenStream_args();
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_getTokenStream{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_getTokenStream_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "getTokenStream failed: unknown result";
}
sub hashCode{
  my $self = shift;

                                                                                                                                                $self->send_hashCode();
                                                                        return $self->recv_hashCode();
}

sub send_hashCode{
  my $self = shift;

                                                                        $self->{output}->writeMessageBegin('hashCode', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_hashCode_args();
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_hashCode{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_hashCode_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        if (defined $result->{success} ) {
                                                                          return $result->{success};
                                                                        }
                                                                        die "hashCode failed: unknown result";
}
sub setTokenStream{
  my $self = shift;
  my $tokenStream = shift;

                                                                                                                                                $self->send_setTokenStream($tokenStream);
                                                                        $self->recv_setTokenStream();
}

sub send_setTokenStream{
  my $self = shift;
  my $tokenStream = shift;

                                                                        $self->{output}->writeMessageBegin('setTokenStream', TMessageType::CALL, $self->{seqid});
                                                                        my $args = new thrift::adept::common::ChunkService_setTokenStream_args();
                                                                        $args->{tokenStream} = $tokenStream;
                                                                        $args->write($self->{output});
                                                                        $self->{output}->writeMessageEnd();
                                                                        $self->{output}->getTransport()->flush();
}

sub recv_setTokenStream{
  my $self = shift;

                                                                        my $rseqid = 0;
                                                                        my $fname;
                                                                        my $mtype = 0;

                                                                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                        if ($mtype == TMessageType::EXCEPTION) {
                                                                          my $x = new TApplicationException();
                                                                          $x->read($self->{input});
                                                                          $self->{input}->readMessageEnd();
                                                                          die $x;
                                                                        }
                                                                        my $result = new thrift::adept::common::ChunkService_setTokenStream_result();
                                                                        $result->read($self->{input});
                                                                        $self->{input}->readMessageEnd();

                                                                        return;
}
package thrift::adept::common::ChunkServiceProcessor;

use strict;
use base qw(thrift::adept::common::ItemServiceProcessor);

sub process {
                                                                          my ($self, $input, $output) = @_;
                                                                          my $rseqid = 0;
                                                                          my $fname  = undef;
                                                                          my $mtype  = 0;

                                                                          $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                          my $methodname = 'process_'.$fname;
                                                                          if (!$self->can($methodname)) {
                                                                            $input->skip(TType::STRUCT);
                                                                            $input->readMessageEnd();
                                                                            my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                                                                            $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                                                                            $x->write($output);
                                                                            $output->writeMessageEnd();
                                                                            $output->getTransport()->flush();
                                                                            return;
                                                                          }
                                                                          $self->$methodname($rseqid, $input, $output);
                                                                          return 1;
}

sub process_Contains {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_Contains_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_Contains_result();
                                                                          $result->{success} = $self->{handler}->Contains($args->chunk);
                                                                          $output->writeMessageBegin('Contains', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_equals {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_equals_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_equals_result();
                                                                          $result->{success} = $self->{handler}->equals($args->obj);
                                                                          $output->writeMessageBegin('equals', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_getContainingChunk {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_getContainingChunk_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_getContainingChunk_result();
                                                                          $result->{success} = $self->{handler}->getContainingChunk($args->chunks);
                                                                          $output->writeMessageBegin('getContainingChunk', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_getMatchingChunk {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_getMatchingChunk_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_getMatchingChunk_result();
                                                                          $result->{success} = $self->{handler}->getMatchingChunk($args->chunks);
                                                                          $output->writeMessageBegin('getMatchingChunk', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_getTokenOffset {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_getTokenOffset_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_getTokenOffset_result();
                                                                          $result->{success} = $self->{handler}->getTokenOffset();
                                                                          $output->writeMessageBegin('getTokenOffset', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_getTokenStream {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_getTokenStream_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_getTokenStream_result();
                                                                          $result->{success} = $self->{handler}->getTokenStream();
                                                                          $output->writeMessageBegin('getTokenStream', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_hashCode {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_hashCode_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_hashCode_result();
                                                                          $result->{success} = $self->{handler}->hashCode();
                                                                          $output->writeMessageBegin('hashCode', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

sub process_setTokenStream {
                                                                          my ($self, $seqid, $input, $output) = @_;
                                                                          my $args = new thrift::adept::common::ChunkService_setTokenStream_args();
                                                                          $args->read($input);
                                                                          $input->readMessageEnd();
                                                                          my $result = new thrift::adept::common::ChunkService_setTokenStream_result();
                                                                          $self->{handler}->setTokenStream($args->tokenStream);
                                                                          $output->writeMessageBegin('setTokenStream', TMessageType::REPLY, $seqid);
                                                                          $result->write($output);
                                                                          $output->writeMessageEnd();
                                                                          $output->getTransport()->flush();
}

1;