#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package thrift::adept::common::Polarity;
use constant POSITIVE => 0;
use constant NEGATIVE => 1;
use constant NEUTRAL => 2;
package thrift::adept::common::TopicPolarity;
use constant POSITIVE => 0;
use constant NEGATIVE => 1;
use constant NONE => 2;
package thrift::adept::common::AsrName;
use constant NONE => 0;
use constant LDC => 1;
use constant BBN => 2;
package thrift::adept::common::AudioFileType;
use constant WAV => 0;
use constant MP3 => 1;
use constant SPH => 2;
package thrift::adept::common::ChannelName;
use constant NONE => 0;
use constant LEFT_STEREO => 1;
use constant RIGHT_STEREO => 2;
use constant MONO => 3;
package thrift::adept::common::ContentType;
use constant TEXT => 0;
use constant SPEECH => 1;
package thrift::adept::common::EntailmentJudgment;
use constant ENTAILS => 0;
use constant CONTRADICTS => 1;
use constant NOT_RELATED => 2;
package thrift::adept::common::Modality;
use constant ABILITY => 0;
use constant EFFORT => 1;
use constant INTENTION => 2;
use constant SUCCESS => 3;
use constant WANT => 4;
use constant COMMITTED_BELIEF => 5;
use constant NON_COMMITTED_BELIEF => 6;
use constant NON_ATTRIBUTABLE_BELIEF => 7;
package thrift::adept::common::SarcasmJudgment;
use constant POSITIVE => 0;
use constant NEGATIVE => 1;
use constant NONE => 2;
package thrift::adept::common::SentenceType;
use constant NONE => 0;
use constant STATEMENT => 1;
use constant QUESTION => 2;
use constant INCOMPLETE => 3;
use constant CLAUSE => 4;
package thrift::adept::common::SpeechUnit;
use constant NONE => 0;
use constant WORD => 1;
use constant PHONEME => 2;
package thrift::adept::common::Subjectivity;
use constant SUBJECTIVE => 0;
use constant OBJECTIVE => 1;
use constant NONE => 2;
package thrift::adept::common::TokenType;
use constant WORD => 0;
use constant PUNCTUATION => 1;
use constant GARBAGE => 2;
use constant LEXEME => 3;
use constant PAUSE_FILLER => 4;
use constant LAUGHTER => 5;
use constant SILENCE => 6;
use constant MUSIC => 7;
use constant TAG => 8;
use constant OTHER => 9;
package thrift::adept::common::TokenizerType;
use constant ADEPT => 0;
use constant STANFORD_CORENLP => 1;
use constant UMASS => 2;
use constant WHITESPACE => 3;
use constant OTHER => 4;
package thrift::adept::common::TranscriptType;
use constant SOURCE => 0;
use constant TRANSLATION => 1;
package thrift::adept::common::TranslatorName;
use constant NONE => 0;
use constant SDL_LW => 1;
package thrift::adept::common::TranslatorType;
use constant NONE => 0;
use constant SDL_LW => 1;
package thrift::adept::common::EmailAddress;
use base qw(Class::Accessor);
thrift::adept::common::EmailAddress->mk_accessors( qw( address displayName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{address} = undef;
  $self->{displayName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{address}) {
      $self->{address} = $vals->{address};
    }
    if (defined $vals->{displayName}) {
      $self->{displayName} = $vals->{displayName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EmailAddress';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{address});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{displayName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EmailAddress');
  if (defined $self->{address}) {
    $xfer += $output->writeFieldBegin('address', TType::STRING, 1);
    $xfer += $output->writeString($self->{address});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{displayName}) {
    $xfer += $output->writeFieldBegin('displayName', TType::STRING, 2);
    $xfer += $output->writeString($self->{displayName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::ID;
use base qw(Class::Accessor);
thrift::adept::common::ID->mk_accessors( qw( id idStr MAX_ID MIN_ID ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{idStr} = undef;
  $self->{MAX_ID} = undef;
  $self->{MIN_ID} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{idStr}) {
      $self->{idStr} = $vals->{idStr};
    }
    if (defined $vals->{MAX_ID}) {
      $self->{MAX_ID} = $vals->{MAX_ID};
    }
    if (defined $vals->{MIN_ID}) {
      $self->{MIN_ID} = $vals->{MIN_ID};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ID';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{idStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{MAX_ID});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{MIN_ID});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ID');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{idStr}) {
    $xfer += $output->writeFieldBegin('idStr', TType::STRING, 2);
    $xfer += $output->writeString($self->{idStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{MAX_ID}) {
    $xfer += $output->writeFieldBegin('MAX_ID', TType::I64, 3);
    $xfer += $output->writeI64($self->{MAX_ID});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{MIN_ID}) {
    $xfer += $output->writeFieldBegin('MIN_ID', TType::I64, 4);
    $xfer += $output->writeI64($self->{MIN_ID});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::LanguageIdentification;
use base qw(Class::Accessor);
thrift::adept::common::LanguageIdentification->mk_accessors( qw( languageProbabilityDistribution id value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{languageProbabilityDistribution} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{languageProbabilityDistribution}) {
      $self->{languageProbabilityDistribution} = $vals->{languageProbabilityDistribution};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'LanguageIdentification';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size0 = 0;
          $self->{languageProbabilityDistribution} = {};
          my $_ktype1 = 0;
          my $_vtype2 = 0;
          $xfer += $input->readMapBegin(\$_ktype1, \$_vtype2, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $key5 = '';
            my $val6 = 0.0;
            $xfer += $input->readString(\$key5);
            $xfer += $input->readDouble(\$val6);
            $self->{languageProbabilityDistribution}->{$key5} = $val6;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('LanguageIdentification');
  if (defined $self->{languageProbabilityDistribution}) {
    $xfer += $output->writeFieldBegin('languageProbabilityDistribution', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::DOUBLE, scalar(keys %{$self->{languageProbabilityDistribution}}));
      {
        while( my ($kiter7,$viter8) = each %{$self->{languageProbabilityDistribution}}) 
        {
          $xfer += $output->writeString($kiter7);
          $xfer += $output->writeDouble($viter8);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 2);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Item;
use base qw(Class::Accessor);
thrift::adept::common::Item->mk_accessors( qw( id value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Item';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Item');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 1);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::TokenOffset;
use base qw(Class::Accessor);
thrift::adept::common::TokenOffset->mk_accessors( qw( beginIndex endIndex ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{beginIndex} = undef;
  $self->{endIndex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{beginIndex}) {
      $self->{beginIndex} = $vals->{beginIndex};
    }
    if (defined $vals->{endIndex}) {
      $self->{endIndex} = $vals->{endIndex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenOffset';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{beginIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{endIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenOffset');
  if (defined $self->{beginIndex}) {
    $xfer += $output->writeFieldBegin('beginIndex', TType::I64, 1);
    $xfer += $output->writeI64($self->{beginIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endIndex}) {
    $xfer += $output->writeFieldBegin('endIndex', TType::I64, 2);
    $xfer += $output->writeI64($self->{endIndex});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::TokenOffsetObject;
use base qw(Class::Accessor);
thrift::adept::common::TokenOffsetObject->mk_accessors( qw( tokenOffset ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenOffsetObject';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenOffsetObject');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Corpus;
use base qw(Class::Accessor);
thrift::adept::common::Corpus->mk_accessors( qw( corpusId type name uri id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{corpusId} = undef;
  $self->{type} = undef;
  $self->{name} = undef;
  $self->{uri} = undef;
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{corpusId}) {
      $self->{corpusId} = $vals->{corpusId};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{uri}) {
      $self->{uri} = $vals->{uri};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Corpus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{corpusId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Corpus');
  if (defined $self->{corpusId}) {
    $xfer += $output->writeFieldBegin('corpusId', TType::STRING, 1);
    $xfer += $output->writeString($self->{corpusId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 3);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uri}) {
    $xfer += $output->writeFieldBegin('uri', TType::STRING, 4);
    $xfer += $output->writeString($self->{uri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 5);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Document;
use base qw(Class::Accessor);
thrift::adept::common::Document->mk_accessors( qw( docId corpus docType uri language audioUri genre headline id value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{docId} = undef;
  $self->{corpus} = undef;
  $self->{docType} = undef;
  $self->{uri} = undef;
  $self->{language} = undef;
  $self->{audioUri} = undef;
  $self->{genre} = undef;
  $self->{headline} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{docId}) {
      $self->{docId} = $vals->{docId};
    }
    if (defined $vals->{corpus}) {
      $self->{corpus} = $vals->{corpus};
    }
    if (defined $vals->{docType}) {
      $self->{docType} = $vals->{docType};
    }
    if (defined $vals->{uri}) {
      $self->{uri} = $vals->{uri};
    }
    if (defined $vals->{language}) {
      $self->{language} = $vals->{language};
    }
    if (defined $vals->{audioUri}) {
      $self->{audioUri} = $vals->{audioUri};
    }
    if (defined $vals->{genre}) {
      $self->{genre} = $vals->{genre};
    }
    if (defined $vals->{headline}) {
      $self->{headline} = $vals->{headline};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Document';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{docId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{corpus} = new thrift::adept::common::Corpus();
        $xfer += $self->{corpus}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{docType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{language});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{audioUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{genre});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{headline});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Document');
  if (defined $self->{docId}) {
    $xfer += $output->writeFieldBegin('docId', TType::STRING, 1);
    $xfer += $output->writeString($self->{docId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{corpus}) {
    $xfer += $output->writeFieldBegin('corpus', TType::STRUCT, 2);
    $xfer += $self->{corpus}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{docType}) {
    $xfer += $output->writeFieldBegin('docType', TType::STRING, 3);
    $xfer += $output->writeString($self->{docType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uri}) {
    $xfer += $output->writeFieldBegin('uri', TType::STRING, 4);
    $xfer += $output->writeString($self->{uri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{language}) {
    $xfer += $output->writeFieldBegin('language', TType::STRING, 5);
    $xfer += $output->writeString($self->{language});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{audioUri}) {
    $xfer += $output->writeFieldBegin('audioUri', TType::STRING, 6);
    $xfer += $output->writeString($self->{audioUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{genre}) {
    $xfer += $output->writeFieldBegin('genre', TType::STRING, 7);
    $xfer += $output->writeString($self->{genre});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{headline}) {
    $xfer += $output->writeFieldBegin('headline', TType::STRING, 8);
    $xfer += $output->writeString($self->{headline});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 9);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 10);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::DocumentList;
use base qw(Class::Accessor);
thrift::adept::common::DocumentList->mk_accessors( qw( id serialVersionUID ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{serialVersionUID} = 651655831447893195;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{serialVersionUID}) {
      $self->{serialVersionUID} = $vals->{serialVersionUID};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'DocumentList';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{serialVersionUID});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('DocumentList');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 1);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serialVersionUID}) {
    $xfer += $output->writeFieldBegin('serialVersionUID', TType::I64, 2);
    $xfer += $output->writeI64($self->{serialVersionUID});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::AudioOffset;
use base qw(Class::Accessor);
thrift::adept::common::AudioOffset->mk_accessors( qw( beginIndex endIndex ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{beginIndex} = undef;
  $self->{endIndex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{beginIndex}) {
      $self->{beginIndex} = $vals->{beginIndex};
    }
    if (defined $vals->{endIndex}) {
      $self->{endIndex} = $vals->{endIndex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AudioOffset';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{beginIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{endIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AudioOffset');
  if (defined $self->{beginIndex}) {
    $xfer += $output->writeFieldBegin('beginIndex', TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{beginIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endIndex}) {
    $xfer += $output->writeFieldBegin('endIndex', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{endIndex});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Audio;
use base qw(Class::Accessor);
thrift::adept::common::Audio->mk_accessors( qw( uri audioBuffer audioType timeSpan ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{uri} = undef;
  $self->{audioBuffer} = undef;
  $self->{audioType} = undef;
  $self->{timeSpan} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{uri}) {
      $self->{uri} = $vals->{uri};
    }
    if (defined $vals->{audioBuffer}) {
      $self->{audioBuffer} = $vals->{audioBuffer};
    }
    if (defined $vals->{audioType}) {
      $self->{audioType} = $vals->{audioType};
    }
    if (defined $vals->{timeSpan}) {
      $self->{timeSpan} = $vals->{timeSpan};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Audio';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{uri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{audioBuffer});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{audioType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{timeSpan} = new thrift::adept::common::AudioOffset();
        $xfer += $self->{timeSpan}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Audio');
  if (defined $self->{uri}) {
    $xfer += $output->writeFieldBegin('uri', TType::STRING, 1);
    $xfer += $output->writeString($self->{uri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{audioBuffer}) {
    $xfer += $output->writeFieldBegin('audioBuffer', TType::STRING, 2);
    $xfer += $output->writeString($self->{audioBuffer});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{audioType}) {
    $xfer += $output->writeFieldBegin('audioType', TType::I32, 3);
    $xfer += $output->writeI32($self->{audioType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeSpan}) {
    $xfer += $output->writeFieldBegin('timeSpan', TType::STRUCT, 4);
    $xfer += $self->{timeSpan}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::CharOffset;
use base qw(Class::Accessor);
thrift::adept::common::CharOffset->mk_accessors( qw( beginIndex endIndex ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{beginIndex} = undef;
  $self->{endIndex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{beginIndex}) {
      $self->{beginIndex} = $vals->{beginIndex};
    }
    if (defined $vals->{endIndex}) {
      $self->{endIndex} = $vals->{endIndex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CharOffset';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{beginIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{endIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CharOffset');
  if (defined $self->{beginIndex}) {
    $xfer += $output->writeFieldBegin('beginIndex', TType::I32, 1);
    $xfer += $output->writeI32($self->{beginIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endIndex}) {
    $xfer += $output->writeFieldBegin('endIndex', TType::I32, 2);
    $xfer += $output->writeI32($self->{endIndex});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Tag;
use base qw(Class::Accessor);
thrift::adept::common::Tag->mk_accessors( qw( tagName attributes charOffset ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tagName} = undef;
  $self->{attributes} = undef;
  $self->{charOffset} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tagName}) {
      $self->{tagName} = $vals->{tagName};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Tag';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tagName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size9 = 0;
          $self->{attributes} = {};
          my $_ktype10 = 0;
          my $_vtype11 = 0;
          $xfer += $input->readMapBegin(\$_ktype10, \$_vtype11, \$_size9);
          for (my $_i13 = 0; $_i13 < $_size9; ++$_i13)
          {
            my $key14 = '';
            my $val15 = '';
            $xfer += $input->readString(\$key14);
            $xfer += $input->readString(\$val15);
            $self->{attributes}->{$key14} = $val15;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Tag');
  if (defined $self->{tagName}) {
    $xfer += $output->writeFieldBegin('tagName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tagName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter16,$viter17) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter16);
          $xfer += $output->writeString($viter17);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 3);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Token;
use base qw(Class::Accessor);
thrift::adept::common::Token->mk_accessors( qw( sequenceId charOffset value audioOffset confidence lemma tokenType id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{charOffset} = undef;
  $self->{value} = undef;
  $self->{audioOffset} = undef;
  $self->{confidence} = undef;
  $self->{lemma} = undef;
  $self->{tokenType} = undef;
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{audioOffset}) {
      $self->{audioOffset} = $vals->{audioOffset};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{lemma}) {
      $self->{lemma} = $vals->{lemma};
    }
    if (defined $vals->{tokenType}) {
      $self->{tokenType} = $vals->{tokenType};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Token';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{audioOffset} = new thrift::adept::common::AudioOffset();
        $xfer += $self->{audioOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{lemma});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{tokenType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Token');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 2);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{audioOffset}) {
    $xfer += $output->writeFieldBegin('audioOffset', TType::STRUCT, 4);
    $xfer += $self->{audioOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 5);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lemma}) {
    $xfer += $output->writeFieldBegin('lemma', TType::STRING, 6);
    $xfer += $output->writeString($self->{lemma});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenType}) {
    $xfer += $output->writeFieldBegin('tokenType', TType::I32, 7);
    $xfer += $output->writeI32($self->{tokenType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 8);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::TokenStream;
use base qw(Class::Accessor);
thrift::adept::common::TokenStream->mk_accessors( qw( tokenizerType transcriptType language channelName contentType textValue asrName document serialVersionUID speechUnit translatorName tokenList ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenizerType} = undef;
  $self->{transcriptType} = undef;
  $self->{language} = undef;
  $self->{channelName} = undef;
  $self->{contentType} = undef;
  $self->{textValue} = undef;
  $self->{asrName} = undef;
  $self->{document} = undef;
  $self->{serialVersionUID} = 2407040331925099456;
  $self->{speechUnit} = undef;
  $self->{translatorName} = undef;
  $self->{tokenList} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenizerType}) {
      $self->{tokenizerType} = $vals->{tokenizerType};
    }
    if (defined $vals->{transcriptType}) {
      $self->{transcriptType} = $vals->{transcriptType};
    }
    if (defined $vals->{language}) {
      $self->{language} = $vals->{language};
    }
    if (defined $vals->{channelName}) {
      $self->{channelName} = $vals->{channelName};
    }
    if (defined $vals->{contentType}) {
      $self->{contentType} = $vals->{contentType};
    }
    if (defined $vals->{textValue}) {
      $self->{textValue} = $vals->{textValue};
    }
    if (defined $vals->{asrName}) {
      $self->{asrName} = $vals->{asrName};
    }
    if (defined $vals->{document}) {
      $self->{document} = $vals->{document};
    }
    if (defined $vals->{serialVersionUID}) {
      $self->{serialVersionUID} = $vals->{serialVersionUID};
    }
    if (defined $vals->{speechUnit}) {
      $self->{speechUnit} = $vals->{speechUnit};
    }
    if (defined $vals->{translatorName}) {
      $self->{translatorName} = $vals->{translatorName};
    }
    if (defined $vals->{tokenList}) {
      $self->{tokenList} = $vals->{tokenList};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenStream';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{tokenizerType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{transcriptType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{language});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{channelName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{contentType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{textValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{asrName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{document} = new thrift::adept::common::Document();
        $xfer += $self->{document}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{serialVersionUID});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{speechUnit});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{translatorName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size18 = 0;
          $self->{tokenList} = [];
          my $_etype21 = 0;
          $xfer += $input->readListBegin(\$_etype21, \$_size18);
          for (my $_i22 = 0; $_i22 < $_size18; ++$_i22)
          {
            my $elem23 = undef;
            $elem23 = new thrift::adept::common::Token();
            $xfer += $elem23->read($input);
            push(@{$self->{tokenList}},$elem23);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenStream');
  if (defined $self->{tokenizerType}) {
    $xfer += $output->writeFieldBegin('tokenizerType', TType::I32, 1);
    $xfer += $output->writeI32($self->{tokenizerType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{transcriptType}) {
    $xfer += $output->writeFieldBegin('transcriptType', TType::I32, 2);
    $xfer += $output->writeI32($self->{transcriptType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{language}) {
    $xfer += $output->writeFieldBegin('language', TType::STRING, 3);
    $xfer += $output->writeString($self->{language});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{channelName}) {
    $xfer += $output->writeFieldBegin('channelName', TType::I32, 4);
    $xfer += $output->writeI32($self->{channelName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contentType}) {
    $xfer += $output->writeFieldBegin('contentType', TType::I32, 5);
    $xfer += $output->writeI32($self->{contentType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{textValue}) {
    $xfer += $output->writeFieldBegin('textValue', TType::STRING, 6);
    $xfer += $output->writeString($self->{textValue});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{asrName}) {
    $xfer += $output->writeFieldBegin('asrName', TType::I32, 7);
    $xfer += $output->writeI32($self->{asrName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{document}) {
    $xfer += $output->writeFieldBegin('document', TType::STRUCT, 8);
    $xfer += $self->{document}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serialVersionUID}) {
    $xfer += $output->writeFieldBegin('serialVersionUID', TType::I64, 9);
    $xfer += $output->writeI64($self->{serialVersionUID});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{speechUnit}) {
    $xfer += $output->writeFieldBegin('speechUnit', TType::I32, 10);
    $xfer += $output->writeI32($self->{speechUnit});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{translatorName}) {
    $xfer += $output->writeFieldBegin('translatorName', TType::I32, 11);
    $xfer += $output->writeI32($self->{translatorName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenList}) {
    $xfer += $output->writeFieldBegin('tokenList', TType::LIST, 12);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{tokenList}}));
      {
        foreach my $iter24 (@{$self->{tokenList}}) 
        {
          $xfer += ${iter24}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Arc;
use base qw(Class::Accessor);
thrift::adept::common::Arc->mk_accessors( qw( source destination token weight ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{source} = undef;
  $self->{destination} = undef;
  $self->{token} = undef;
  $self->{weight} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{source}) {
      $self->{source} = $vals->{source};
    }
    if (defined $vals->{destination}) {
      $self->{destination} = $vals->{destination};
    }
    if (defined $vals->{token}) {
      $self->{token} = $vals->{token};
    }
    if (defined $vals->{weight}) {
      $self->{weight} = $vals->{weight};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Arc';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{source});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{destination});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{token} = new thrift::adept::common::Token();
        $xfer += $self->{token}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{weight});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Arc');
  if (defined $self->{source}) {
    $xfer += $output->writeFieldBegin('source', TType::I32, 1);
    $xfer += $output->writeI32($self->{source});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{destination}) {
    $xfer += $output->writeFieldBegin('destination', TType::I32, 2);
    $xfer += $output->writeI32($self->{destination});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{token}) {
    $xfer += $output->writeFieldBegin('token', TType::STRUCT, 3);
    $xfer += $self->{token}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{weight}) {
    $xfer += $output->writeFieldBegin('weight', TType::DOUBLE, 4);
    $xfer += $output->writeDouble($self->{weight});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::TokenLattice;
use base qw(Class::Accessor);
thrift::adept::common::TokenLattice->mk_accessors( qw( startState endState arcs ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startState} = undef;
  $self->{endState} = undef;
  $self->{arcs} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startState}) {
      $self->{startState} = $vals->{startState};
    }
    if (defined $vals->{endState}) {
      $self->{endState} = $vals->{endState};
    }
    if (defined $vals->{arcs}) {
      $self->{arcs} = $vals->{arcs};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenLattice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startState});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{endState});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size25 = 0;
          $self->{arcs} = [];
          my $_etype28 = 0;
          $xfer += $input->readListBegin(\$_etype28, \$_size25);
          for (my $_i29 = 0; $_i29 < $_size25; ++$_i29)
          {
            my $elem30 = undef;
            $elem30 = new thrift::adept::common::Arc();
            $xfer += $elem30->read($input);
            push(@{$self->{arcs}},$elem30);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenLattice');
  if (defined $self->{startState}) {
    $xfer += $output->writeFieldBegin('startState', TType::I32, 1);
    $xfer += $output->writeI32($self->{startState});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endState}) {
    $xfer += $output->writeFieldBegin('endState', TType::I32, 2);
    $xfer += $output->writeI32($self->{endState});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arcs}) {
    $xfer += $output->writeFieldBegin('arcs', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{arcs}}));
      {
        foreach my $iter31 (@{$self->{arcs}}) 
        {
          $xfer += ${iter31}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Chunk;
use base qw(Class::Accessor);
thrift::adept::common::Chunk->mk_accessors( qw( tokenOffset tokenStream id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Chunk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Chunk');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 3);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 5);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::AdeptException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
thrift::adept::common::AdeptException->mk_accessors( qw( serialVersionUID ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{serialVersionUID} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{serialVersionUID}) {
      $self->{serialVersionUID} = $vals->{serialVersionUID};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AdeptException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{serialVersionUID});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AdeptException');
  if (defined $self->{serialVersionUID}) {
    $xfer += $output->writeFieldBegin('serialVersionUID', TType::I64, 1);
    $xfer += $output->writeI64($self->{serialVersionUID});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::AnomalousText;
use base qw(Class::Accessor);
thrift::adept::common::AnomalousText->mk_accessors( qw( confidence document explanation id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{confidence} = undef;
  $self->{document} = undef;
  $self->{explanation} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{document}) {
      $self->{document} = $vals->{document};
    }
    if (defined $vals->{explanation}) {
      $self->{explanation} = $vals->{explanation};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AnomalousText';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{document} = new thrift::adept::common::Document();
        $xfer += $self->{document}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{explanation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AnomalousText');
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{document}) {
    $xfer += $output->writeFieldBegin('document', TType::STRUCT, 2);
    $xfer += $self->{document}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{explanation}) {
    $xfer += $output->writeFieldBegin('explanation', TType::STRING, 3);
    $xfer += $output->writeString($self->{explanation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 6);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Type;
use base qw(Class::Accessor);
thrift::adept::common::Type->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Type';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Type');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::CommittedBelief;
use base qw(Class::Accessor);
thrift::adept::common::CommittedBelief->mk_accessors( qw( sequenceId tokenOffset tokenStream charOffset modality id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{modality} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{modality}) {
      $self->{modality} = $vals->{modality};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CommittedBelief';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{modality});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CommittedBelief');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 4);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{modality}) {
    $xfer += $output->writeFieldBegin('modality', TType::I32, 5);
    $xfer += $output->writeI32($self->{modality});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::EntityMention;
use base qw(Class::Accessor);
thrift::adept::common::EntityMention->mk_accessors( qw( sequenceId tokenOffset tokenStream charOffset entityIdDistribution entityType mentionType context contextSize id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{entityIdDistribution} = undef;
  $self->{entityType} = undef;
  $self->{mentionType} = undef;
  $self->{context} = undef;
  $self->{contextSize} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{entityIdDistribution}) {
      $self->{entityIdDistribution} = $vals->{entityIdDistribution};
    }
    if (defined $vals->{entityType}) {
      $self->{entityType} = $vals->{entityType};
    }
    if (defined $vals->{mentionType}) {
      $self->{mentionType} = $vals->{mentionType};
    }
    if (defined $vals->{context}) {
      $self->{context} = $vals->{context};
    }
    if (defined $vals->{contextSize}) {
      $self->{contextSize} = $vals->{contextSize};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EntityMention';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size32 = 0;
          $self->{entityIdDistribution} = {};
          my $_ktype33 = 0;
          my $_vtype34 = 0;
          $xfer += $input->readMapBegin(\$_ktype33, \$_vtype34, \$_size32);
          for (my $_i36 = 0; $_i36 < $_size32; ++$_i36)
          {
            my $key37 = 0;
            my $val38 = 0.0;
            $xfer += $input->readI64(\$key37);
            $xfer += $input->readDouble(\$val38);
            $self->{entityIdDistribution}->{$key37} = $val38;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entityType} = new thrift::adept::common::Type();
        $xfer += $self->{entityType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mentionType} = new thrift::adept::common::Type();
        $xfer += $self->{mentionType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{context});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{contextSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EntityMention');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 4);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entityIdDistribution}) {
    $xfer += $output->writeFieldBegin('entityIdDistribution', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::I64, TType::DOUBLE, scalar(keys %{$self->{entityIdDistribution}}));
      {
        while( my ($kiter39,$viter40) = each %{$self->{entityIdDistribution}}) 
        {
          $xfer += $output->writeI64($kiter39);
          $xfer += $output->writeDouble($viter40);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entityType}) {
    $xfer += $output->writeFieldBegin('entityType', TType::STRUCT, 6);
    $xfer += $self->{entityType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mentionType}) {
    $xfer += $output->writeFieldBegin('mentionType', TType::STRUCT, 7);
    $xfer += $self->{mentionType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{context}) {
    $xfer += $output->writeFieldBegin('context', TType::STRING, 8);
    $xfer += $output->writeString($self->{context});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contextSize}) {
    $xfer += $output->writeFieldBegin('contextSize', TType::I32, 9);
    $xfer += $output->writeI32($self->{contextSize});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 10);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 11);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 12);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Entity;
use base qw(Class::Accessor);
thrift::adept::common::Entity->mk_accessors( qw( entityId entityType canonicalMention id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{entityId} = undef;
  $self->{entityType} = undef;
  $self->{canonicalMention} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{entityId}) {
      $self->{entityId} = $vals->{entityId};
    }
    if (defined $vals->{entityType}) {
      $self->{entityType} = $vals->{entityType};
    }
    if (defined $vals->{canonicalMention}) {
      $self->{canonicalMention} = $vals->{canonicalMention};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Entity';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{entityId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entityType} = new thrift::adept::common::Type();
        $xfer += $self->{entityType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{canonicalMention} = new thrift::adept::common::EntityMention();
        $xfer += $self->{canonicalMention}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Entity');
  if (defined $self->{entityId}) {
    $xfer += $output->writeFieldBegin('entityId', TType::I64, 1);
    $xfer += $output->writeI64($self->{entityId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entityType}) {
    $xfer += $output->writeFieldBegin('entityType', TType::STRUCT, 2);
    $xfer += $self->{entityType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{canonicalMention}) {
    $xfer += $output->writeFieldBegin('canonicalMention', TType::STRUCT, 3);
    $xfer += $self->{canonicalMention}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 6);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::EntityObject;
use base qw(Class::Accessor);
thrift::adept::common::EntityObject->mk_accessors( qw( entity ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{entity} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{entity}) {
      $self->{entity} = $vals->{entity};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EntityObject';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entity} = new thrift::adept::common::Entity();
        $xfer += $self->{entity}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EntityObject');
  if (defined $self->{entity}) {
    $xfer += $output->writeFieldBegin('entity', TType::STRUCT, 1);
    $xfer += $self->{entity}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Coreference;
use base qw(Class::Accessor);
thrift::adept::common::Coreference->mk_accessors( qw( coreferenceId entities resolvedEntityMentions id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{coreferenceId} = undef;
  $self->{entities} = undef;
  $self->{resolvedEntityMentions} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{coreferenceId}) {
      $self->{coreferenceId} = $vals->{coreferenceId};
    }
    if (defined $vals->{entities}) {
      $self->{entities} = $vals->{entities};
    }
    if (defined $vals->{resolvedEntityMentions}) {
      $self->{resolvedEntityMentions} = $vals->{resolvedEntityMentions};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Coreference';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{coreferenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size41 = 0;
          $self->{entities} = [];
          my $_etype44 = 0;
          $xfer += $input->readListBegin(\$_etype44, \$_size41);
          for (my $_i45 = 0; $_i45 < $_size41; ++$_i45)
          {
            my $elem46 = undef;
            $elem46 = new thrift::adept::common::Entity();
            $xfer += $elem46->read($input);
            push(@{$self->{entities}},$elem46);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size47 = 0;
          $self->{resolvedEntityMentions} = [];
          my $_etype50 = 0;
          $xfer += $input->readListBegin(\$_etype50, \$_size47);
          for (my $_i51 = 0; $_i51 < $_size47; ++$_i51)
          {
            my $elem52 = undef;
            $elem52 = new thrift::adept::common::EntityMention();
            $xfer += $elem52->read($input);
            push(@{$self->{resolvedEntityMentions}},$elem52);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Coreference');
  if (defined $self->{coreferenceId}) {
    $xfer += $output->writeFieldBegin('coreferenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{coreferenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entities}) {
    $xfer += $output->writeFieldBegin('entities', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{entities}}));
      {
        foreach my $iter53 (@{$self->{entities}}) 
        {
          $xfer += ${iter53}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resolvedEntityMentions}) {
    $xfer += $output->writeFieldBegin('resolvedEntityMentions', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{resolvedEntityMentions}}));
      {
        foreach my $iter54 (@{$self->{resolvedEntityMentions}}) 
        {
          $xfer += ${iter54}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 6);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::DiscourseUnit;
use base qw(Class::Accessor);
thrift::adept::common::DiscourseUnit->mk_accessors( qw( tokenOffset tokenStream charOffset sequenceId discourceType noveltyConfidence uncertaintyConfidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{sequenceId} = undef;
  $self->{discourceType} = undef;
  $self->{noveltyConfidence} = undef;
  $self->{uncertaintyConfidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{discourceType}) {
      $self->{discourceType} = $vals->{discourceType};
    }
    if (defined $vals->{noveltyConfidence}) {
      $self->{noveltyConfidence} = $vals->{noveltyConfidence};
    }
    if (defined $vals->{uncertaintyConfidence}) {
      $self->{uncertaintyConfidence} = $vals->{uncertaintyConfidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'DiscourseUnit';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{discourceType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{noveltyConfidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{uncertaintyConfidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('DiscourseUnit');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 3);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 4);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{discourceType}) {
    $xfer += $output->writeFieldBegin('discourceType', TType::STRING, 5);
    $xfer += $output->writeString($self->{discourceType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noveltyConfidence}) {
    $xfer += $output->writeFieldBegin('noveltyConfidence', TType::DOUBLE, 6);
    $xfer += $output->writeDouble($self->{noveltyConfidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uncertaintyConfidence}) {
    $xfer += $output->writeFieldBegin('uncertaintyConfidence', TType::DOUBLE, 7);
    $xfer += $output->writeDouble($self->{uncertaintyConfidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 8);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 9);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 10);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Passage;
use base qw(Class::Accessor);
thrift::adept::common::Passage->mk_accessors( qw( sequenceId tokenOffset tokenStream charOffset contentType id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{contentType} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{contentType}) {
      $self->{contentType} = $vals->{contentType};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Passage';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{contentType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Passage');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 4);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contentType}) {
    $xfer += $output->writeFieldBegin('contentType', TType::STRING, 5);
    $xfer += $output->writeString($self->{contentType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Message;
use base qw(Class::Accessor);
thrift::adept::common::Message->mk_accessors( qw( sequenceId tokenOffset tokenStream sender recipients ccRecipients bccRecipients sentDate priority subject contentType messageId userAgent inReplyTo reference returnPathAddress id value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{sender} = undef;
  $self->{recipients} = undef;
  $self->{ccRecipients} = undef;
  $self->{bccRecipients} = undef;
  $self->{sentDate} = undef;
  $self->{priority} = undef;
  $self->{subject} = undef;
  $self->{contentType} = undef;
  $self->{messageId} = undef;
  $self->{userAgent} = undef;
  $self->{inReplyTo} = undef;
  $self->{reference} = undef;
  $self->{returnPathAddress} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{sender}) {
      $self->{sender} = $vals->{sender};
    }
    if (defined $vals->{recipients}) {
      $self->{recipients} = $vals->{recipients};
    }
    if (defined $vals->{ccRecipients}) {
      $self->{ccRecipients} = $vals->{ccRecipients};
    }
    if (defined $vals->{bccRecipients}) {
      $self->{bccRecipients} = $vals->{bccRecipients};
    }
    if (defined $vals->{sentDate}) {
      $self->{sentDate} = $vals->{sentDate};
    }
    if (defined $vals->{priority}) {
      $self->{priority} = $vals->{priority};
    }
    if (defined $vals->{subject}) {
      $self->{subject} = $vals->{subject};
    }
    if (defined $vals->{contentType}) {
      $self->{contentType} = $vals->{contentType};
    }
    if (defined $vals->{messageId}) {
      $self->{messageId} = $vals->{messageId};
    }
    if (defined $vals->{userAgent}) {
      $self->{userAgent} = $vals->{userAgent};
    }
    if (defined $vals->{inReplyTo}) {
      $self->{inReplyTo} = $vals->{inReplyTo};
    }
    if (defined $vals->{reference}) {
      $self->{reference} = $vals->{reference};
    }
    if (defined $vals->{returnPathAddress}) {
      $self->{returnPathAddress} = $vals->{returnPathAddress};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Message';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sender} = new thrift::adept::common::EmailAddress();
        $xfer += $self->{sender}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size55 = 0;
          $self->{recipients} = [];
          my $_etype58 = 0;
          $xfer += $input->readListBegin(\$_etype58, \$_size55);
          for (my $_i59 = 0; $_i59 < $_size55; ++$_i59)
          {
            my $elem60 = undef;
            $elem60 = new thrift::adept::common::EmailAddress();
            $xfer += $elem60->read($input);
            push(@{$self->{recipients}},$elem60);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size61 = 0;
          $self->{ccRecipients} = [];
          my $_etype64 = 0;
          $xfer += $input->readListBegin(\$_etype64, \$_size61);
          for (my $_i65 = 0; $_i65 < $_size61; ++$_i65)
          {
            my $elem66 = undef;
            $elem66 = new thrift::adept::common::EmailAddress();
            $xfer += $elem66->read($input);
            push(@{$self->{ccRecipients}},$elem66);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size67 = 0;
          $self->{bccRecipients} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $elem72 = new thrift::adept::common::EmailAddress();
            $xfer += $elem72->read($input);
            push(@{$self->{bccRecipients}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{sentDate});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{priority});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subject});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{contentType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{messageId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userAgent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size73 = 0;
          $self->{inReplyTo} = [];
          my $_etype76 = 0;
          $xfer += $input->readListBegin(\$_etype76, \$_size73);
          for (my $_i77 = 0; $_i77 < $_size73; ++$_i77)
          {
            my $elem78 = undef;
            $xfer += $input->readString(\$elem78);
            push(@{$self->{inReplyTo}},$elem78);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size79 = 0;
          $self->{reference} = [];
          my $_etype82 = 0;
          $xfer += $input->readListBegin(\$_etype82, \$_size79);
          for (my $_i83 = 0; $_i83 < $_size79; ++$_i83)
          {
            my $elem84 = undef;
            $xfer += $input->readString(\$elem84);
            push(@{$self->{reference}},$elem84);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{returnPathAddress} = new thrift::adept::common::EmailAddress();
        $xfer += $self->{returnPathAddress}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Message');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sender}) {
    $xfer += $output->writeFieldBegin('sender', TType::STRUCT, 4);
    $xfer += $self->{sender}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recipients}) {
    $xfer += $output->writeFieldBegin('recipients', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{recipients}}));
      {
        foreach my $iter85 (@{$self->{recipients}}) 
        {
          $xfer += ${iter85}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ccRecipients}) {
    $xfer += $output->writeFieldBegin('ccRecipients', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{ccRecipients}}));
      {
        foreach my $iter86 (@{$self->{ccRecipients}}) 
        {
          $xfer += ${iter86}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bccRecipients}) {
    $xfer += $output->writeFieldBegin('bccRecipients', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{bccRecipients}}));
      {
        foreach my $iter87 (@{$self->{bccRecipients}}) 
        {
          $xfer += ${iter87}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentDate}) {
    $xfer += $output->writeFieldBegin('sentDate', TType::STRING, 8);
    $xfer += $output->writeString($self->{sentDate});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{priority}) {
    $xfer += $output->writeFieldBegin('priority', TType::STRING, 9);
    $xfer += $output->writeString($self->{priority});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subject}) {
    $xfer += $output->writeFieldBegin('subject', TType::STRING, 10);
    $xfer += $output->writeString($self->{subject});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contentType}) {
    $xfer += $output->writeFieldBegin('contentType', TType::STRING, 11);
    $xfer += $output->writeString($self->{contentType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{messageId}) {
    $xfer += $output->writeFieldBegin('messageId', TType::STRING, 13);
    $xfer += $output->writeString($self->{messageId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userAgent}) {
    $xfer += $output->writeFieldBegin('userAgent', TType::STRING, 14);
    $xfer += $output->writeString($self->{userAgent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inReplyTo}) {
    $xfer += $output->writeFieldBegin('inReplyTo', TType::LIST, 15);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{inReplyTo}}));
      {
        foreach my $iter88 (@{$self->{inReplyTo}}) 
        {
          $xfer += $output->writeString($iter88);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reference}) {
    $xfer += $output->writeFieldBegin('reference', TType::LIST, 16);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{reference}}));
      {
        foreach my $iter89 (@{$self->{reference}}) 
        {
          $xfer += $output->writeString($iter89);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{returnPathAddress}) {
    $xfer += $output->writeFieldBegin('returnPathAddress', TType::STRUCT, 17);
    $xfer += $self->{returnPathAddress}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 18);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 19);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Entailment;
use base qw(Class::Accessor);
thrift::adept::common::Entailment->mk_accessors( qw( entailmentId hypothesis judgmentDistribution text id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{entailmentId} = undef;
  $self->{hypothesis} = undef;
  $self->{judgmentDistribution} = undef;
  $self->{text} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{entailmentId}) {
      $self->{entailmentId} = $vals->{entailmentId};
    }
    if (defined $vals->{hypothesis}) {
      $self->{hypothesis} = $vals->{hypothesis};
    }
    if (defined $vals->{judgmentDistribution}) {
      $self->{judgmentDistribution} = $vals->{judgmentDistribution};
    }
    if (defined $vals->{text}) {
      $self->{text} = $vals->{text};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Entailment';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{entailmentId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hypothesis} = new thrift::adept::common::Passage();
        $xfer += $self->{hypothesis}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size90 = 0;
          $self->{judgmentDistribution} = {};
          my $_ktype91 = 0;
          my $_vtype92 = 0;
          $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $key95 = 0;
            my $val96 = 0.0;
            $xfer += $input->readI32(\$key95);
            $xfer += $input->readDouble(\$val96);
            $self->{judgmentDistribution}->{$key95} = $val96;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{text} = new thrift::adept::common::Passage();
        $xfer += $self->{text}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Entailment');
  if (defined $self->{entailmentId}) {
    $xfer += $output->writeFieldBegin('entailmentId', TType::I64, 1);
    $xfer += $output->writeI64($self->{entailmentId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hypothesis}) {
    $xfer += $output->writeFieldBegin('hypothesis', TType::STRUCT, 2);
    $xfer += $self->{hypothesis}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{judgmentDistribution}) {
    $xfer += $output->writeFieldBegin('judgmentDistribution', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::I32, TType::DOUBLE, scalar(keys %{$self->{judgmentDistribution}}));
      {
        while( my ($kiter97,$viter98) = each %{$self->{judgmentDistribution}}) 
        {
          $xfer += $output->writeI32($kiter97);
          $xfer += $output->writeDouble($viter98);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{text}) {
    $xfer += $output->writeFieldBegin('text', TType::STRUCT, 4);
    $xfer += $self->{text}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 5);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 6);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 7);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::HltContent;
use base qw(Class::Accessor);
thrift::adept::common::HltContent->mk_accessors( qw( id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HltContent';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HltContent');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 1);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 3);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::InterPausalUnit;
use base qw(Class::Accessor);
thrift::adept::common::InterPausalUnit->mk_accessors( qw( sequenceId ipuAudioOffset acousticFeatures id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{ipuAudioOffset} = undef;
  $self->{acousticFeatures} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{ipuAudioOffset}) {
      $self->{ipuAudioOffset} = $vals->{ipuAudioOffset};
    }
    if (defined $vals->{acousticFeatures}) {
      $self->{acousticFeatures} = $vals->{acousticFeatures};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InterPausalUnit';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ipuAudioOffset} = new thrift::adept::common::AudioOffset();
        $xfer += $self->{ipuAudioOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size99 = 0;
          $self->{acousticFeatures} = {};
          my $_ktype100 = 0;
          my $_vtype101 = 0;
          $xfer += $input->readMapBegin(\$_ktype100, \$_vtype101, \$_size99);
          for (my $_i103 = 0; $_i103 < $_size99; ++$_i103)
          {
            my $key104 = '';
            my $val105 = 0.0;
            $xfer += $input->readString(\$key104);
            $xfer += $input->readDouble(\$val105);
            $self->{acousticFeatures}->{$key104} = $val105;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InterPausalUnit');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ipuAudioOffset}) {
    $xfer += $output->writeFieldBegin('ipuAudioOffset', TType::STRUCT, 2);
    $xfer += $self->{ipuAudioOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{acousticFeatures}) {
    $xfer += $output->writeFieldBegin('acousticFeatures', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::DOUBLE, scalar(keys %{$self->{acousticFeatures}}));
      {
        while( my ($kiter106,$viter107) = each %{$self->{acousticFeatures}}) 
        {
          $xfer += $output->writeString($kiter106);
          $xfer += $output->writeDouble($viter107);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 6);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Opinion;
use base qw(Class::Accessor);
thrift::adept::common::Opinion->mk_accessors( qw( tokenOffset tokenStream charOffset subjectivity polarity id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{subjectivity} = undef;
  $self->{polarity} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{subjectivity}) {
      $self->{subjectivity} = $vals->{subjectivity};
    }
    if (defined $vals->{polarity}) {
      $self->{polarity} = $vals->{polarity};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Opinion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{subjectivity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{polarity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Opinion');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 3);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subjectivity}) {
    $xfer += $output->writeFieldBegin('subjectivity', TType::I32, 4);
    $xfer += $output->writeI32($self->{subjectivity});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{polarity}) {
    $xfer += $output->writeFieldBegin('polarity', TType::I32, 5);
    $xfer += $output->writeI32($self->{polarity});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Paraphrase;
use base qw(Class::Accessor);
thrift::adept::common::Paraphrase->mk_accessors( qw( value confidence posTag id algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{value} = undef;
  $self->{confidence} = undef;
  $self->{posTag} = undef;
  $self->{id} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{posTag}) {
      $self->{posTag} = $vals->{posTag};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Paraphrase';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{posTag} = new thrift::adept::common::Type();
        $xfer += $self->{posTag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Paraphrase');
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{posTag}) {
    $xfer += $output->writeFieldBegin('posTag', TType::STRUCT, 3);
    $xfer += $self->{posTag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 5);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::PartOfSpeech;
use base qw(Class::Accessor);
thrift::adept::common::PartOfSpeech->mk_accessors( qw( sequenceId tokenOffset tokenStream charOffset posTag id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{posTag} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{posTag}) {
      $self->{posTag} = $vals->{posTag};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PartOfSpeech';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{posTag} = new thrift::adept::common::Type();
        $xfer += $self->{posTag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PartOfSpeech');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 4);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{posTag}) {
    $xfer += $output->writeFieldBegin('posTag', TType::STRUCT, 5);
    $xfer += $self->{posTag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::PostQuote;
use base qw(Class::Accessor);
thrift::adept::common::PostQuote->mk_accessors( qw( sequenceId tokenOffset tokenStream openTag closeTag subQuotes charOffset postId id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{openTag} = undef;
  $self->{closeTag} = undef;
  $self->{subQuotes} = undef;
  $self->{charOffset} = undef;
  $self->{postId} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{openTag}) {
      $self->{openTag} = $vals->{openTag};
    }
    if (defined $vals->{closeTag}) {
      $self->{closeTag} = $vals->{closeTag};
    }
    if (defined $vals->{subQuotes}) {
      $self->{subQuotes} = $vals->{subQuotes};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{postId}) {
      $self->{postId} = $vals->{postId};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PostQuote';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{openTag} = new thrift::adept::common::Tag();
        $xfer += $self->{openTag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{closeTag} = new thrift::adept::common::Tag();
        $xfer += $self->{closeTag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size108 = 0;
          $self->{subQuotes} = [];
          my $_etype111 = 0;
          $xfer += $input->readListBegin(\$_etype111, \$_size108);
          for (my $_i112 = 0; $_i112 < $_size108; ++$_i112)
          {
            my $elem113 = undef;
            $xfer += $input->readI32(\$elem113);
            push(@{$self->{subQuotes}},$elem113);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PostQuote');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{openTag}) {
    $xfer += $output->writeFieldBegin('openTag', TType::STRUCT, 4);
    $xfer += $self->{openTag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{closeTag}) {
    $xfer += $output->writeFieldBegin('closeTag', TType::STRUCT, 5);
    $xfer += $self->{closeTag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subQuotes}) {
    $xfer += $output->writeFieldBegin('subQuotes', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{subQuotes}}));
      {
        foreach my $iter114 (@{$self->{subQuotes}}) 
        {
          $xfer += $output->writeI32($iter114);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 7);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postId}) {
    $xfer += $output->writeFieldBegin('postId', TType::STRING, 8);
    $xfer += $output->writeString($self->{postId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 9);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 10);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 11);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Post;
use base qw(Class::Accessor);
thrift::adept::common::Post->mk_accessors( qw( sequenceId tokenOffset tokenStream openTag closeTag quotes allSubQuotes charOffset id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{openTag} = undef;
  $self->{closeTag} = undef;
  $self->{quotes} = undef;
  $self->{allSubQuotes} = undef;
  $self->{charOffset} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{openTag}) {
      $self->{openTag} = $vals->{openTag};
    }
    if (defined $vals->{closeTag}) {
      $self->{closeTag} = $vals->{closeTag};
    }
    if (defined $vals->{quotes}) {
      $self->{quotes} = $vals->{quotes};
    }
    if (defined $vals->{allSubQuotes}) {
      $self->{allSubQuotes} = $vals->{allSubQuotes};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Post';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{openTag} = new thrift::adept::common::Tag();
        $xfer += $self->{openTag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{closeTag} = new thrift::adept::common::Tag();
        $xfer += $self->{closeTag}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size115 = 0;
          $self->{quotes} = [];
          my $_etype118 = 0;
          $xfer += $input->readListBegin(\$_etype118, \$_size115);
          for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
          {
            my $elem120 = undef;
            $xfer += $input->readI32(\$elem120);
            push(@{$self->{quotes}},$elem120);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size121 = 0;
          $self->{allSubQuotes} = [];
          my $_etype124 = 0;
          $xfer += $input->readListBegin(\$_etype124, \$_size121);
          for (my $_i125 = 0; $_i125 < $_size121; ++$_i125)
          {
            my $elem126 = undef;
            $elem126 = new thrift::adept::common::PostQuote();
            $xfer += $elem126->read($input);
            push(@{$self->{allSubQuotes}},$elem126);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Post');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{openTag}) {
    $xfer += $output->writeFieldBegin('openTag', TType::STRUCT, 4);
    $xfer += $self->{openTag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{closeTag}) {
    $xfer += $output->writeFieldBegin('closeTag', TType::STRUCT, 5);
    $xfer += $self->{closeTag}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{quotes}) {
    $xfer += $output->writeFieldBegin('quotes', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::I32, scalar(@{$self->{quotes}}));
      {
        foreach my $iter127 (@{$self->{quotes}}) 
        {
          $xfer += $output->writeI32($iter127);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allSubQuotes}) {
    $xfer += $output->writeFieldBegin('allSubQuotes', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{allSubQuotes}}));
      {
        foreach my $iter128 (@{$self->{allSubQuotes}}) 
        {
          $xfer += ${iter128}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 8);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 9);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 10);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 11);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::ProsodicPhrase;
use base qw(Class::Accessor);
thrift::adept::common::ProsodicPhrase->mk_accessors( qw( tokenOffset tokenStream charOffset sequenceId confidence noveltyConfidence type uncertaintyConfidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{sequenceId} = undef;
  $self->{confidence} = undef;
  $self->{noveltyConfidence} = undef;
  $self->{type} = undef;
  $self->{uncertaintyConfidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{noveltyConfidence}) {
      $self->{noveltyConfidence} = $vals->{noveltyConfidence};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{uncertaintyConfidence}) {
      $self->{uncertaintyConfidence} = $vals->{uncertaintyConfidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ProsodicPhrase';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{noveltyConfidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{uncertaintyConfidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ProsodicPhrase');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 3);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 4);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 5);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noveltyConfidence}) {
    $xfer += $output->writeFieldBegin('noveltyConfidence', TType::DOUBLE, 6);
    $xfer += $output->writeDouble($self->{noveltyConfidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 7);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uncertaintyConfidence}) {
    $xfer += $output->writeFieldBegin('uncertaintyConfidence', TType::DOUBLE, 8);
    $xfer += $output->writeDouble($self->{uncertaintyConfidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 9);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 10);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 11);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Sarcasm;
use base qw(Class::Accessor);
thrift::adept::common::Sarcasm->mk_accessors( qw( sarcasmId tokenOffset tokenStream charOffset judgment confidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sarcasmId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{judgment} = undef;
  $self->{confidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sarcasmId}) {
      $self->{sarcasmId} = $vals->{sarcasmId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{judgment}) {
      $self->{judgment} = $vals->{judgment};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Sarcasm';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sarcasmId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{judgment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Sarcasm');
  if (defined $self->{sarcasmId}) {
    $xfer += $output->writeFieldBegin('sarcasmId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sarcasmId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 4);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{judgment}) {
    $xfer += $output->writeFieldBegin('judgment', TType::I32, 5);
    $xfer += $output->writeI32($self->{judgment});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 6);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 7);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 8);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 9);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Sentence;
use base qw(Class::Accessor);
thrift::adept::common::Sentence->mk_accessors( qw( sequenceId tokenOffset tokenStream charOffset noveltyConfidence punctuation type uncertaintyConfidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{noveltyConfidence} = undef;
  $self->{punctuation} = undef;
  $self->{type} = undef;
  $self->{uncertaintyConfidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{noveltyConfidence}) {
      $self->{noveltyConfidence} = $vals->{noveltyConfidence};
    }
    if (defined $vals->{punctuation}) {
      $self->{punctuation} = $vals->{punctuation};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{uncertaintyConfidence}) {
      $self->{uncertaintyConfidence} = $vals->{uncertaintyConfidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Sentence';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{noveltyConfidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{punctuation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{uncertaintyConfidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Sentence');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 2);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 3);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 4);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{noveltyConfidence}) {
    $xfer += $output->writeFieldBegin('noveltyConfidence', TType::DOUBLE, 5);
    $xfer += $output->writeDouble($self->{noveltyConfidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{punctuation}) {
    $xfer += $output->writeFieldBegin('punctuation', TType::STRING, 6);
    $xfer += $output->writeString($self->{punctuation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 7);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uncertaintyConfidence}) {
    $xfer += $output->writeFieldBegin('uncertaintyConfidence', TType::DOUBLE, 8);
    $xfer += $output->writeDouble($self->{uncertaintyConfidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 9);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 10);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 11);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Session;
use base qw(Class::Accessor);
thrift::adept::common::Session->mk_accessors( qw( tokenOffset tokenStream sequenceId contentType sentences charOffset id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{sequenceId} = undef;
  $self->{contentType} = undef;
  $self->{sentences} = undef;
  $self->{charOffset} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{contentType}) {
      $self->{contentType} = $vals->{contentType};
    }
    if (defined $vals->{sentences}) {
      $self->{sentences} = $vals->{sentences};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Session';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{contentType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size129 = 0;
          $self->{sentences} = [];
          my $_etype132 = 0;
          $xfer += $input->readListBegin(\$_etype132, \$_size129);
          for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
          {
            my $elem134 = undef;
            $elem134 = new thrift::adept::common::Sentence();
            $xfer += $elem134->read($input);
            push(@{$self->{sentences}},$elem134);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Session');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 3);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{contentType}) {
    $xfer += $output->writeFieldBegin('contentType', TType::STRING, 4);
    $xfer += $output->writeString($self->{contentType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentences}) {
    $xfer += $output->writeFieldBegin('sentences', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sentences}}));
      {
        foreach my $iter135 (@{$self->{sentences}}) 
        {
          $xfer += ${iter135}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 6);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 7);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 8);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 9);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::SentenceSimilarity;
use base qw(Class::Accessor);
thrift::adept::common::SentenceSimilarity->mk_accessors( qw( similarity sentence1 sentence2 id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{similarity} = undef;
  $self->{sentence1} = undef;
  $self->{sentence2} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{similarity}) {
      $self->{similarity} = $vals->{similarity};
    }
    if (defined $vals->{sentence1}) {
      $self->{sentence1} = $vals->{sentence1};
    }
    if (defined $vals->{sentence2}) {
      $self->{sentence2} = $vals->{sentence2};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SentenceSimilarity';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{similarity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sentence1} = new thrift::adept::common::Sentence();
        $xfer += $self->{sentence1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sentence2} = new thrift::adept::common::Sentence();
        $xfer += $self->{sentence2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SentenceSimilarity');
  if (defined $self->{similarity}) {
    $xfer += $output->writeFieldBegin('similarity', TType::DOUBLE, 1);
    $xfer += $output->writeDouble($self->{similarity});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentence1}) {
    $xfer += $output->writeFieldBegin('sentence1', TType::STRUCT, 2);
    $xfer += $self->{sentence1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentence2}) {
    $xfer += $output->writeFieldBegin('sentence2', TType::STRUCT, 3);
    $xfer += $self->{sentence2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 6);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Slot;
use base qw(Class::Accessor);
thrift::adept::common::Slot->mk_accessors( qw( slotId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{slotId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{slotId}) {
      $self->{slotId} = $vals->{slotId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Slot';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{slotId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Slot');
  if (defined $self->{slotId}) {
    $xfer += $output->writeFieldBegin('slotId', TType::I64, 1);
    $xfer += $output->writeI64($self->{slotId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Story;
use base qw(Class::Accessor);
thrift::adept::common::Story->mk_accessors( qw( tokenOffset tokenStream charOffset sequenceId topicLabels id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{sequenceId} = undef;
  $self->{topicLabels} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{topicLabels}) {
      $self->{topicLabels} = $vals->{topicLabels};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Story';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size136 = 0;
          $self->{topicLabels} = [];
          my $_etype139 = 0;
          $xfer += $input->readListBegin(\$_etype139, \$_size136);
          for (my $_i140 = 0; $_i140 < $_size136; ++$_i140)
          {
            my $elem141 = undef;
            $xfer += $input->readString(\$elem141);
            push(@{$self->{topicLabels}},$elem141);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Story');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 3);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 4);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{topicLabels}) {
    $xfer += $output->writeFieldBegin('topicLabels', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{topicLabels}}));
      {
        foreach my $iter142 (@{$self->{topicLabels}}) 
        {
          $xfer += $output->writeString($iter142);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::SyntacticChunk;
use base qw(Class::Accessor);
thrift::adept::common::SyntacticChunk->mk_accessors( qw( sequenceId scType tokenOffset tokenStream charOffset id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sequenceId} = undef;
  $self->{scType} = undef;
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sequenceId}) {
      $self->{sequenceId} = $vals->{sequenceId};
    }
    if (defined $vals->{scType}) {
      $self->{scType} = $vals->{scType};
    }
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SyntacticChunk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{sequenceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scType} = new thrift::adept::common::Type();
        $xfer += $self->{scType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SyntacticChunk');
  if (defined $self->{sequenceId}) {
    $xfer += $output->writeFieldBegin('sequenceId', TType::I64, 1);
    $xfer += $output->writeI64($self->{sequenceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scType}) {
    $xfer += $output->writeFieldBegin('scType', TType::STRUCT, 2);
    $xfer += $self->{scType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 3);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 4);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 5);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::TokenStreamList;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamList->mk_accessors( qw( tokenStreamList ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenStreamList} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenStreamList}) {
      $self->{tokenStreamList} = $vals->{tokenStreamList};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenStreamList';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size143 = 0;
          $self->{tokenStreamList} = [];
          my $_etype146 = 0;
          $xfer += $input->readListBegin(\$_etype146, \$_size143);
          for (my $_i147 = 0; $_i147 < $_size143; ++$_i147)
          {
            my $elem148 = undef;
            $elem148 = new thrift::adept::common::TokenStream();
            $xfer += $elem148->read($input);
            push(@{$self->{tokenStreamList}},$elem148);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenStreamList');
  if (defined $self->{tokenStreamList}) {
    $xfer += $output->writeFieldBegin('tokenStreamList', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{tokenStreamList}}));
      {
        foreach my $iter149 (@{$self->{tokenStreamList}}) 
        {
          $xfer += ${iter149}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Viewpoint;
use base qw(Class::Accessor);
thrift::adept::common::Viewpoint->mk_accessors( qw( speakerId belief ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{speakerId} = undef;
  $self->{belief} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{speakerId}) {
      $self->{speakerId} = $vals->{speakerId};
    }
    if (defined $vals->{belief}) {
      $self->{belief} = $vals->{belief};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Viewpoint';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{speakerId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{belief});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Viewpoint');
  if (defined $self->{speakerId}) {
    $xfer += $output->writeFieldBegin('speakerId', TType::STRING, 1);
    $xfer += $output->writeString($self->{speakerId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{belief}) {
    $xfer += $output->writeFieldBegin('belief', TType::STRING, 2);
    $xfer += $output->writeString($self->{belief});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Topic;
use base qw(Class::Accessor);
thrift::adept::common::Topic->mk_accessors( qw( topicId name belief polarity viewpoints ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{topicId} = undef;
  $self->{name} = undef;
  $self->{belief} = undef;
  $self->{polarity} = undef;
  $self->{viewpoints} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{topicId}) {
      $self->{topicId} = $vals->{topicId};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{belief}) {
      $self->{belief} = $vals->{belief};
    }
    if (defined $vals->{polarity}) {
      $self->{polarity} = $vals->{polarity};
    }
    if (defined $vals->{viewpoints}) {
      $self->{viewpoints} = $vals->{viewpoints};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Topic';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{topicId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{belief});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{polarity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size150 = 0;
          $self->{viewpoints} = [];
          my $_etype153 = 0;
          $xfer += $input->readListBegin(\$_etype153, \$_size150);
          for (my $_i154 = 0; $_i154 < $_size150; ++$_i154)
          {
            my $elem155 = undef;
            $elem155 = new thrift::adept::common::Viewpoint();
            $xfer += $elem155->read($input);
            push(@{$self->{viewpoints}},$elem155);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Topic');
  if (defined $self->{topicId}) {
    $xfer += $output->writeFieldBegin('topicId', TType::I64, 1);
    $xfer += $output->writeI64($self->{topicId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{belief}) {
    $xfer += $output->writeFieldBegin('belief', TType::STRING, 3);
    $xfer += $output->writeString($self->{belief});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{polarity}) {
    $xfer += $output->writeFieldBegin('polarity', TType::I32, 4);
    $xfer += $output->writeI32($self->{polarity});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{viewpoints}) {
    $xfer += $output->writeFieldBegin('viewpoints', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{viewpoints}}));
      {
        foreach my $iter156 (@{$self->{viewpoints}}) 
        {
          $xfer += ${iter156}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Value;
use base qw(Class::Accessor);
thrift::adept::common::Value->mk_accessors( qw( valueId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{valueId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{valueId}) {
      $self->{valueId} = $vals->{valueId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Value';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{valueId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Value');
  if (defined $self->{valueId}) {
    $xfer += $output->writeFieldBegin('valueId', TType::I64, 1);
    $xfer += $output->writeI64($self->{valueId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Triple;
use base qw(Class::Accessor);
thrift::adept::common::Triple->mk_accessors( qw( entity slot value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{entity} = undef;
  $self->{slot} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{entity}) {
      $self->{entity} = $vals->{entity};
    }
    if (defined $vals->{slot}) {
      $self->{slot} = $vals->{slot};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Triple';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entity} = new thrift::adept::common::Entity();
        $xfer += $self->{entity}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{slot} = new thrift::adept::common::Slot();
        $xfer += $self->{slot}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Triple');
  if (defined $self->{entity}) {
    $xfer += $output->writeFieldBegin('entity', TType::STRUCT, 1);
    $xfer += $self->{entity}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{slot}) {
    $xfer += $output->writeFieldBegin('slot', TType::STRUCT, 2);
    $xfer += $self->{slot}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Utterance;
use base qw(Class::Accessor);
thrift::adept::common::Utterance->mk_accessors( qw( tokenOffset tokenStream charOffset utteranceId speakerId annotation id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenOffset} = undef;
  $self->{tokenStream} = undef;
  $self->{charOffset} = undef;
  $self->{utteranceId} = undef;
  $self->{speakerId} = undef;
  $self->{annotation} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenOffset}) {
      $self->{tokenOffset} = $vals->{tokenOffset};
    }
    if (defined $vals->{tokenStream}) {
      $self->{tokenStream} = $vals->{tokenStream};
    }
    if (defined $vals->{charOffset}) {
      $self->{charOffset} = $vals->{charOffset};
    }
    if (defined $vals->{utteranceId}) {
      $self->{utteranceId} = $vals->{utteranceId};
    }
    if (defined $vals->{speakerId}) {
      $self->{speakerId} = $vals->{speakerId};
    }
    if (defined $vals->{annotation}) {
      $self->{annotation} = $vals->{annotation};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Utterance';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenOffset} = new thrift::adept::common::TokenOffset();
        $xfer += $self->{tokenOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tokenStream} = new thrift::adept::common::TokenStream();
        $xfer += $self->{tokenStream}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{charOffset} = new thrift::adept::common::CharOffset();
        $xfer += $self->{charOffset}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{utteranceId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{speakerId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{annotation});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Utterance');
  if (defined $self->{tokenOffset}) {
    $xfer += $output->writeFieldBegin('tokenOffset', TType::STRUCT, 1);
    $xfer += $self->{tokenOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tokenStream}) {
    $xfer += $output->writeFieldBegin('tokenStream', TType::STRUCT, 2);
    $xfer += $self->{tokenStream}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{charOffset}) {
    $xfer += $output->writeFieldBegin('charOffset', TType::STRUCT, 3);
    $xfer += $self->{charOffset}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{utteranceId}) {
    $xfer += $output->writeFieldBegin('utteranceId', TType::I64, 4);
    $xfer += $output->writeI64($self->{utteranceId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{speakerId}) {
    $xfer += $output->writeFieldBegin('speakerId', TType::I64, 5);
    $xfer += $output->writeI64($self->{speakerId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{annotation}) {
    $xfer += $output->writeFieldBegin('annotation', TType::STRING, 6);
    $xfer += $output->writeString($self->{annotation});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 7);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 8);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 9);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Conversation;
use base qw(Class::Accessor);
thrift::adept::common::Conversation->mk_accessors( qw( conversationId name oneSided topics utterances id value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{conversationId} = undef;
  $self->{name} = undef;
  $self->{oneSided} = undef;
  $self->{topics} = undef;
  $self->{utterances} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{conversationId}) {
      $self->{conversationId} = $vals->{conversationId};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{oneSided}) {
      $self->{oneSided} = $vals->{oneSided};
    }
    if (defined $vals->{topics}) {
      $self->{topics} = $vals->{topics};
    }
    if (defined $vals->{utterances}) {
      $self->{utterances} = $vals->{utterances};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Conversation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{conversationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{oneSided});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size157 = 0;
          $self->{topics} = [];
          my $_etype160 = 0;
          $xfer += $input->readListBegin(\$_etype160, \$_size157);
          for (my $_i161 = 0; $_i161 < $_size157; ++$_i161)
          {
            my $elem162 = undef;
            $elem162 = new thrift::adept::common::Topic();
            $xfer += $elem162->read($input);
            push(@{$self->{topics}},$elem162);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size163 = 0;
          $self->{utterances} = [];
          my $_etype166 = 0;
          $xfer += $input->readListBegin(\$_etype166, \$_size163);
          for (my $_i167 = 0; $_i167 < $_size163; ++$_i167)
          {
            my $elem168 = undef;
            $elem168 = new thrift::adept::common::Utterance();
            $xfer += $elem168->read($input);
            push(@{$self->{utterances}},$elem168);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Conversation');
  if (defined $self->{conversationId}) {
    $xfer += $output->writeFieldBegin('conversationId', TType::I64, 1);
    $xfer += $output->writeI64($self->{conversationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{oneSided}) {
    $xfer += $output->writeFieldBegin('oneSided', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{oneSided});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{topics}) {
    $xfer += $output->writeFieldBegin('topics', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{topics}}));
      {
        foreach my $iter169 (@{$self->{topics}}) 
        {
          $xfer += ${iter169}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{utterances}) {
    $xfer += $output->writeFieldBegin('utterances', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{utterances}}));
      {
        foreach my $iter170 (@{$self->{utterances}}) 
        {
          $xfer += ${iter170}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::ChunkUnion;
use base qw(Class::Accessor);
thrift::adept::common::ChunkUnion->mk_accessors( qw( committedBelief discourseUnit entityMention opinion partOfSpeech passage prosodicPhrase sarcasm sentence story syntacticChunk utterance chunk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{committedBelief} = undef;
  $self->{discourseUnit} = undef;
  $self->{entityMention} = undef;
  $self->{opinion} = undef;
  $self->{partOfSpeech} = undef;
  $self->{passage} = undef;
  $self->{prosodicPhrase} = undef;
  $self->{sarcasm} = undef;
  $self->{sentence} = undef;
  $self->{story} = undef;
  $self->{syntacticChunk} = undef;
  $self->{utterance} = undef;
  $self->{chunk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{committedBelief}) {
      $self->{committedBelief} = $vals->{committedBelief};
    }
    if (defined $vals->{discourseUnit}) {
      $self->{discourseUnit} = $vals->{discourseUnit};
    }
    if (defined $vals->{entityMention}) {
      $self->{entityMention} = $vals->{entityMention};
    }
    if (defined $vals->{opinion}) {
      $self->{opinion} = $vals->{opinion};
    }
    if (defined $vals->{partOfSpeech}) {
      $self->{partOfSpeech} = $vals->{partOfSpeech};
    }
    if (defined $vals->{passage}) {
      $self->{passage} = $vals->{passage};
    }
    if (defined $vals->{prosodicPhrase}) {
      $self->{prosodicPhrase} = $vals->{prosodicPhrase};
    }
    if (defined $vals->{sarcasm}) {
      $self->{sarcasm} = $vals->{sarcasm};
    }
    if (defined $vals->{sentence}) {
      $self->{sentence} = $vals->{sentence};
    }
    if (defined $vals->{story}) {
      $self->{story} = $vals->{story};
    }
    if (defined $vals->{syntacticChunk}) {
      $self->{syntacticChunk} = $vals->{syntacticChunk};
    }
    if (defined $vals->{utterance}) {
      $self->{utterance} = $vals->{utterance};
    }
    if (defined $vals->{chunk}) {
      $self->{chunk} = $vals->{chunk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ChunkUnion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{committedBelief} = new thrift::adept::common::CommittedBelief();
        $xfer += $self->{committedBelief}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{discourseUnit} = new thrift::adept::common::DiscourseUnit();
        $xfer += $self->{discourseUnit}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entityMention} = new thrift::adept::common::EntityMention();
        $xfer += $self->{entityMention}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{opinion} = new thrift::adept::common::Opinion();
        $xfer += $self->{opinion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{partOfSpeech} = new thrift::adept::common::PartOfSpeech();
        $xfer += $self->{partOfSpeech}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{passage} = new thrift::adept::common::Passage();
        $xfer += $self->{passage}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{prosodicPhrase} = new thrift::adept::common::ProsodicPhrase();
        $xfer += $self->{prosodicPhrase}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sarcasm} = new thrift::adept::common::Sarcasm();
        $xfer += $self->{sarcasm}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sentence} = new thrift::adept::common::Sentence();
        $xfer += $self->{sentence}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{story} = new thrift::adept::common::Story();
        $xfer += $self->{story}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{syntacticChunk} = new thrift::adept::common::SyntacticChunk();
        $xfer += $self->{syntacticChunk}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{utterance} = new thrift::adept::common::Utterance();
        $xfer += $self->{utterance}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{chunk} = new thrift::adept::common::Chunk();
        $xfer += $self->{chunk}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ChunkUnion');
  if (defined $self->{committedBelief}) {
    $xfer += $output->writeFieldBegin('committedBelief', TType::STRUCT, 1);
    $xfer += $self->{committedBelief}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{discourseUnit}) {
    $xfer += $output->writeFieldBegin('discourseUnit', TType::STRUCT, 2);
    $xfer += $self->{discourseUnit}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entityMention}) {
    $xfer += $output->writeFieldBegin('entityMention', TType::STRUCT, 3);
    $xfer += $self->{entityMention}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{opinion}) {
    $xfer += $output->writeFieldBegin('opinion', TType::STRUCT, 4);
    $xfer += $self->{opinion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partOfSpeech}) {
    $xfer += $output->writeFieldBegin('partOfSpeech', TType::STRUCT, 5);
    $xfer += $self->{partOfSpeech}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{passage}) {
    $xfer += $output->writeFieldBegin('passage', TType::STRUCT, 6);
    $xfer += $self->{passage}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{prosodicPhrase}) {
    $xfer += $output->writeFieldBegin('prosodicPhrase', TType::STRUCT, 7);
    $xfer += $self->{prosodicPhrase}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sarcasm}) {
    $xfer += $output->writeFieldBegin('sarcasm', TType::STRUCT, 8);
    $xfer += $self->{sarcasm}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentence}) {
    $xfer += $output->writeFieldBegin('sentence', TType::STRUCT, 9);
    $xfer += $self->{sentence}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{story}) {
    $xfer += $output->writeFieldBegin('story', TType::STRUCT, 10);
    $xfer += $self->{story}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{syntacticChunk}) {
    $xfer += $output->writeFieldBegin('syntacticChunk', TType::STRUCT, 11);
    $xfer += $self->{syntacticChunk}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{utterance}) {
    $xfer += $output->writeFieldBegin('utterance', TType::STRUCT, 12);
    $xfer += $self->{utterance}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{chunk}) {
    $xfer += $output->writeFieldBegin('chunk', TType::STRUCT, 13);
    $xfer += $self->{chunk}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Argument;
use base qw(Class::Accessor);
thrift::adept::common::Argument->mk_accessors( qw( argumentType argumentDistribution id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{argumentType} = undef;
  $self->{argumentDistribution} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{argumentType}) {
      $self->{argumentType} = $vals->{argumentType};
    }
    if (defined $vals->{argumentDistribution}) {
      $self->{argumentDistribution} = $vals->{argumentDistribution};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Argument';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{argumentType} = new thrift::adept::common::Type();
        $xfer += $self->{argumentType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size171 = 0;
          $self->{argumentDistribution} = {};
          my $_ktype172 = 0;
          my $_vtype173 = 0;
          $xfer += $input->readMapBegin(\$_ktype172, \$_vtype173, \$_size171);
          for (my $_i175 = 0; $_i175 < $_size171; ++$_i175)
          {
            my $key176 = new thrift::adept::common::ChunkUnion();
            my $val177 = 0.0;
            $key176 = new thrift::adept::common::ChunkUnion();
            $xfer += $key176->read($input);
            $xfer += $input->readDouble(\$val177);
            $self->{argumentDistribution}->{$key176} = $val177;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Argument');
  if (defined $self->{argumentType}) {
    $xfer += $output->writeFieldBegin('argumentType', TType::STRUCT, 1);
    $xfer += $self->{argumentType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{argumentDistribution}) {
    $xfer += $output->writeFieldBegin('argumentDistribution', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRUCT, TType::DOUBLE, scalar(keys %{$self->{argumentDistribution}}));
      {
        while( my ($kiter178,$viter179) = each %{$self->{argumentDistribution}}) 
        {
          $xfer += ${kiter178}->write($output);
          $xfer += $output->writeDouble($viter179);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 3);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 5);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::ArgumentTuple;
use base qw(Class::Accessor);
thrift::adept::common::ArgumentTuple->mk_accessors( qw( tupleType attributes arguments confidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tupleType} = undef;
  $self->{attributes} = undef;
  $self->{arguments} = undef;
  $self->{confidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tupleType}) {
      $self->{tupleType} = $vals->{tupleType};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
    if (defined $vals->{arguments}) {
      $self->{arguments} = $vals->{arguments};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ArgumentTuple';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tupleType} = new thrift::adept::common::Type();
        $xfer += $self->{tupleType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size180 = 0;
          $self->{attributes} = [];
          my $_etype183 = 0;
          $xfer += $input->readListBegin(\$_etype183, \$_size180);
          for (my $_i184 = 0; $_i184 < $_size180; ++$_i184)
          {
            my $elem185 = undef;
            $elem185 = new thrift::adept::common::Type();
            $xfer += $elem185->read($input);
            push(@{$self->{attributes}},$elem185);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size186 = 0;
          $self->{arguments} = [];
          my $_etype189 = 0;
          $xfer += $input->readListBegin(\$_etype189, \$_size186);
          for (my $_i190 = 0; $_i190 < $_size186; ++$_i190)
          {
            my $elem191 = undef;
            $elem191 = new thrift::adept::common::Argument();
            $xfer += $elem191->read($input);
            push(@{$self->{arguments}},$elem191);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ArgumentTuple');
  if (defined $self->{tupleType}) {
    $xfer += $output->writeFieldBegin('tupleType', TType::STRUCT, 1);
    $xfer += $self->{tupleType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{attributes}}));
      {
        foreach my $iter192 (@{$self->{attributes}}) 
        {
          $xfer += ${iter192}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arguments}) {
    $xfer += $output->writeFieldBegin('arguments', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{arguments}}));
      {
        foreach my $iter193 (@{$self->{arguments}}) 
        {
          $xfer += ${iter193}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 4);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 5);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 6);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 7);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Event;
use base qw(Class::Accessor);
thrift::adept::common::Event->mk_accessors( qw( eventId eventType attributes arguments confidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{eventId} = undef;
  $self->{eventType} = undef;
  $self->{attributes} = undef;
  $self->{arguments} = undef;
  $self->{confidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{eventId}) {
      $self->{eventId} = $vals->{eventId};
    }
    if (defined $vals->{eventType}) {
      $self->{eventType} = $vals->{eventType};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
    if (defined $vals->{arguments}) {
      $self->{arguments} = $vals->{arguments};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Event';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{eventId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{eventType} = new thrift::adept::common::Type();
        $xfer += $self->{eventType}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size194 = 0;
          $self->{attributes} = [];
          my $_etype197 = 0;
          $xfer += $input->readListBegin(\$_etype197, \$_size194);
          for (my $_i198 = 0; $_i198 < $_size194; ++$_i198)
          {
            my $elem199 = undef;
            $elem199 = new thrift::adept::common::Type();
            $xfer += $elem199->read($input);
            push(@{$self->{attributes}},$elem199);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size200 = 0;
          $self->{arguments} = [];
          my $_etype203 = 0;
          $xfer += $input->readListBegin(\$_etype203, \$_size200);
          for (my $_i204 = 0; $_i204 < $_size200; ++$_i204)
          {
            my $elem205 = undef;
            $elem205 = new thrift::adept::common::Argument();
            $xfer += $elem205->read($input);
            push(@{$self->{arguments}},$elem205);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Event');
  if (defined $self->{eventId}) {
    $xfer += $output->writeFieldBegin('eventId', TType::I64, 1);
    $xfer += $output->writeI64($self->{eventId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{eventType}) {
    $xfer += $output->writeFieldBegin('eventType', TType::STRUCT, 2);
    $xfer += $self->{eventType}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{attributes}}));
      {
        foreach my $iter206 (@{$self->{attributes}}) 
        {
          $xfer += ${iter206}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arguments}) {
    $xfer += $output->writeFieldBegin('arguments', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{arguments}}));
      {
        foreach my $iter207 (@{$self->{arguments}}) 
        {
          $xfer += ${iter207}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 5);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 6);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 7);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 8);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::EventRelations;
use base qw(Class::Accessor);
thrift::adept::common::EventRelations->mk_accessors( qw( coreferences ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{coreferences} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{coreferences}) {
      $self->{coreferences} = $vals->{coreferences};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EventRelations';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size208 = 0;
          $self->{coreferences} = [];
          my $_etype211 = 0;
          $xfer += $input->readListBegin(\$_etype211, \$_size208);
          for (my $_i212 = 0; $_i212 < $_size208; ++$_i212)
          {
            my $elem213 = undef;
            $elem213 = new thrift::adept::common::Event();
            $xfer += $elem213->read($input);
            push(@{$self->{coreferences}},$elem213);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EventRelations');
  if (defined $self->{coreferences}) {
    $xfer += $output->writeFieldBegin('coreferences', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{coreferences}}));
      {
        foreach my $iter214 (@{$self->{coreferences}}) 
        {
          $xfer += ${iter214}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Relation;
use base qw(Class::Accessor);
thrift::adept::common::Relation->mk_accessors( qw( relationId type arguments confidence id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{relationId} = undef;
  $self->{type} = undef;
  $self->{arguments} = undef;
  $self->{confidence} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{relationId}) {
      $self->{relationId} = $vals->{relationId};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{arguments}) {
      $self->{arguments} = $vals->{arguments};
    }
    if (defined $vals->{confidence}) {
      $self->{confidence} = $vals->{confidence};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Relation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{relationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{type} = new thrift::adept::common::Type();
        $xfer += $self->{type}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size215 = 0;
          $self->{arguments} = [];
          my $_etype218 = 0;
          $xfer += $input->readListBegin(\$_etype218, \$_size215);
          for (my $_i219 = 0; $_i219 < $_size215; ++$_i219)
          {
            my $elem220 = undef;
            $elem220 = new thrift::adept::common::Argument();
            $xfer += $elem220->read($input);
            push(@{$self->{arguments}},$elem220);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{confidence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Relation');
  if (defined $self->{relationId}) {
    $xfer += $output->writeFieldBegin('relationId', TType::I64, 1);
    $xfer += $output->writeI64($self->{relationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRUCT, 2);
    $xfer += $self->{type}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{arguments}) {
    $xfer += $output->writeFieldBegin('arguments', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{arguments}}));
      {
        foreach my $iter221 (@{$self->{arguments}}) 
        {
          $xfer += ${iter221}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{confidence}) {
    $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 4);
    $xfer += $output->writeDouble($self->{confidence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 5);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 6);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 7);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::JointRelationCoreference;
use base qw(Class::Accessor);
thrift::adept::common::JointRelationCoreference->mk_accessors( qw( coreference relations id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{coreference} = undef;
  $self->{relations} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{coreference}) {
      $self->{coreference} = $vals->{coreference};
    }
    if (defined $vals->{relations}) {
      $self->{relations} = $vals->{relations};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'JointRelationCoreference';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{coreference} = new thrift::adept::common::Coreference();
        $xfer += $self->{coreference}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size222 = 0;
          $self->{relations} = [];
          my $_etype225 = 0;
          $xfer += $input->readListBegin(\$_etype225, \$_size222);
          for (my $_i226 = 0; $_i226 < $_size222; ++$_i226)
          {
            my $elem227 = undef;
            $elem227 = new thrift::adept::common::Relation();
            $xfer += $elem227->read($input);
            push(@{$self->{relations}},$elem227);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('JointRelationCoreference');
  if (defined $self->{coreference}) {
    $xfer += $output->writeFieldBegin('coreference', TType::STRUCT, 1);
    $xfer += $self->{coreference}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{relations}) {
    $xfer += $output->writeFieldBegin('relations', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{relations}}));
      {
        foreach my $iter228 (@{$self->{relations}}) 
        {
          $xfer += ${iter228}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 3);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 5);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Dependency;
use base qw(Class::Accessor);
thrift::adept::common::Dependency->mk_accessors( qw( governor dependent dependencyType id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{governor} = undef;
  $self->{dependent} = undef;
  $self->{dependencyType} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{governor}) {
      $self->{governor} = $vals->{governor};
    }
    if (defined $vals->{dependent}) {
      $self->{dependent} = $vals->{dependent};
    }
    if (defined $vals->{dependencyType}) {
      $self->{dependencyType} = $vals->{dependencyType};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Dependency';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{governor} = new thrift::adept::common::ChunkUnion();
        $xfer += $self->{governor}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{dependent} = new thrift::adept::common::ChunkUnion();
        $xfer += $self->{dependent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dependencyType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Dependency');
  if (defined $self->{governor}) {
    $xfer += $output->writeFieldBegin('governor', TType::STRUCT, 1);
    $xfer += $self->{governor}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dependent}) {
    $xfer += $output->writeFieldBegin('dependent', TType::STRUCT, 2);
    $xfer += $self->{dependent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dependencyType}) {
    $xfer += $output->writeFieldBegin('dependencyType', TType::STRING, 3);
    $xfer += $output->writeString($self->{dependencyType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 4);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 6);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::HltContentContainer;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainer->mk_accessors( qw( committedBeliefs coreferences dependencies entityMentions jointRelationCoreferences namedEntities opinions partOfSpeechs passages posts prosodicPhrases relations sarcasms sentences syntacticChunks sessions utterances messages interPausalUnits events eventRelations id value algorithmName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{committedBeliefs} = undef;
  $self->{coreferences} = undef;
  $self->{dependencies} = undef;
  $self->{entityMentions} = undef;
  $self->{jointRelationCoreferences} = undef;
  $self->{namedEntities} = undef;
  $self->{opinions} = undef;
  $self->{partOfSpeechs} = undef;
  $self->{passages} = undef;
  $self->{posts} = undef;
  $self->{prosodicPhrases} = undef;
  $self->{relations} = undef;
  $self->{sarcasms} = undef;
  $self->{sentences} = undef;
  $self->{syntacticChunks} = undef;
  $self->{sessions} = undef;
  $self->{utterances} = undef;
  $self->{messages} = undef;
  $self->{interPausalUnits} = undef;
  $self->{events} = undef;
  $self->{eventRelations} = undef;
  $self->{id} = undef;
  $self->{value} = undef;
  $self->{algorithmName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{committedBeliefs}) {
      $self->{committedBeliefs} = $vals->{committedBeliefs};
    }
    if (defined $vals->{coreferences}) {
      $self->{coreferences} = $vals->{coreferences};
    }
    if (defined $vals->{dependencies}) {
      $self->{dependencies} = $vals->{dependencies};
    }
    if (defined $vals->{entityMentions}) {
      $self->{entityMentions} = $vals->{entityMentions};
    }
    if (defined $vals->{jointRelationCoreferences}) {
      $self->{jointRelationCoreferences} = $vals->{jointRelationCoreferences};
    }
    if (defined $vals->{namedEntities}) {
      $self->{namedEntities} = $vals->{namedEntities};
    }
    if (defined $vals->{opinions}) {
      $self->{opinions} = $vals->{opinions};
    }
    if (defined $vals->{partOfSpeechs}) {
      $self->{partOfSpeechs} = $vals->{partOfSpeechs};
    }
    if (defined $vals->{passages}) {
      $self->{passages} = $vals->{passages};
    }
    if (defined $vals->{posts}) {
      $self->{posts} = $vals->{posts};
    }
    if (defined $vals->{prosodicPhrases}) {
      $self->{prosodicPhrases} = $vals->{prosodicPhrases};
    }
    if (defined $vals->{relations}) {
      $self->{relations} = $vals->{relations};
    }
    if (defined $vals->{sarcasms}) {
      $self->{sarcasms} = $vals->{sarcasms};
    }
    if (defined $vals->{sentences}) {
      $self->{sentences} = $vals->{sentences};
    }
    if (defined $vals->{syntacticChunks}) {
      $self->{syntacticChunks} = $vals->{syntacticChunks};
    }
    if (defined $vals->{sessions}) {
      $self->{sessions} = $vals->{sessions};
    }
    if (defined $vals->{utterances}) {
      $self->{utterances} = $vals->{utterances};
    }
    if (defined $vals->{messages}) {
      $self->{messages} = $vals->{messages};
    }
    if (defined $vals->{interPausalUnits}) {
      $self->{interPausalUnits} = $vals->{interPausalUnits};
    }
    if (defined $vals->{events}) {
      $self->{events} = $vals->{events};
    }
    if (defined $vals->{eventRelations}) {
      $self->{eventRelations} = $vals->{eventRelations};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{algorithmName}) {
      $self->{algorithmName} = $vals->{algorithmName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HltContentContainer';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size229 = 0;
          $self->{committedBeliefs} = [];
          my $_etype232 = 0;
          $xfer += $input->readListBegin(\$_etype232, \$_size229);
          for (my $_i233 = 0; $_i233 < $_size229; ++$_i233)
          {
            my $elem234 = undef;
            $elem234 = new thrift::adept::common::CommittedBelief();
            $xfer += $elem234->read($input);
            push(@{$self->{committedBeliefs}},$elem234);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size235 = 0;
          $self->{coreferences} = [];
          my $_etype238 = 0;
          $xfer += $input->readListBegin(\$_etype238, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $elem240 = undef;
            $elem240 = new thrift::adept::common::Coreference();
            $xfer += $elem240->read($input);
            push(@{$self->{coreferences}},$elem240);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size241 = 0;
          $self->{dependencies} = [];
          my $_etype244 = 0;
          $xfer += $input->readListBegin(\$_etype244, \$_size241);
          for (my $_i245 = 0; $_i245 < $_size241; ++$_i245)
          {
            my $elem246 = undef;
            $elem246 = new thrift::adept::common::Dependency();
            $xfer += $elem246->read($input);
            push(@{$self->{dependencies}},$elem246);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size247 = 0;
          $self->{entityMentions} = [];
          my $_etype250 = 0;
          $xfer += $input->readListBegin(\$_etype250, \$_size247);
          for (my $_i251 = 0; $_i251 < $_size247; ++$_i251)
          {
            my $elem252 = undef;
            $elem252 = new thrift::adept::common::EntityMention();
            $xfer += $elem252->read($input);
            push(@{$self->{entityMentions}},$elem252);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size253 = 0;
          $self->{jointRelationCoreferences} = [];
          my $_etype256 = 0;
          $xfer += $input->readListBegin(\$_etype256, \$_size253);
          for (my $_i257 = 0; $_i257 < $_size253; ++$_i257)
          {
            my $elem258 = undef;
            $elem258 = new thrift::adept::common::JointRelationCoreference();
            $xfer += $elem258->read($input);
            push(@{$self->{jointRelationCoreferences}},$elem258);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size259 = 0;
          $self->{namedEntities} = [];
          my $_etype262 = 0;
          $xfer += $input->readListBegin(\$_etype262, \$_size259);
          for (my $_i263 = 0; $_i263 < $_size259; ++$_i263)
          {
            my $elem264 = undef;
            $elem264 = new thrift::adept::common::EntityMention();
            $xfer += $elem264->read($input);
            push(@{$self->{namedEntities}},$elem264);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size265 = 0;
          $self->{opinions} = [];
          my $_etype268 = 0;
          $xfer += $input->readListBegin(\$_etype268, \$_size265);
          for (my $_i269 = 0; $_i269 < $_size265; ++$_i269)
          {
            my $elem270 = undef;
            $elem270 = new thrift::adept::common::Opinion();
            $xfer += $elem270->read($input);
            push(@{$self->{opinions}},$elem270);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size271 = 0;
          $self->{partOfSpeechs} = [];
          my $_etype274 = 0;
          $xfer += $input->readListBegin(\$_etype274, \$_size271);
          for (my $_i275 = 0; $_i275 < $_size271; ++$_i275)
          {
            my $elem276 = undef;
            $elem276 = new thrift::adept::common::PartOfSpeech();
            $xfer += $elem276->read($input);
            push(@{$self->{partOfSpeechs}},$elem276);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size277 = 0;
          $self->{passages} = [];
          my $_etype280 = 0;
          $xfer += $input->readListBegin(\$_etype280, \$_size277);
          for (my $_i281 = 0; $_i281 < $_size277; ++$_i281)
          {
            my $elem282 = undef;
            $elem282 = new thrift::adept::common::Passage();
            $xfer += $elem282->read($input);
            push(@{$self->{passages}},$elem282);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size283 = 0;
          $self->{posts} = [];
          my $_etype286 = 0;
          $xfer += $input->readListBegin(\$_etype286, \$_size283);
          for (my $_i287 = 0; $_i287 < $_size283; ++$_i287)
          {
            my $elem288 = undef;
            $elem288 = new thrift::adept::common::Post();
            $xfer += $elem288->read($input);
            push(@{$self->{posts}},$elem288);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size289 = 0;
          $self->{prosodicPhrases} = [];
          my $_etype292 = 0;
          $xfer += $input->readListBegin(\$_etype292, \$_size289);
          for (my $_i293 = 0; $_i293 < $_size289; ++$_i293)
          {
            my $elem294 = undef;
            $elem294 = new thrift::adept::common::ProsodicPhrase();
            $xfer += $elem294->read($input);
            push(@{$self->{prosodicPhrases}},$elem294);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size295 = 0;
          $self->{relations} = [];
          my $_etype298 = 0;
          $xfer += $input->readListBegin(\$_etype298, \$_size295);
          for (my $_i299 = 0; $_i299 < $_size295; ++$_i299)
          {
            my $elem300 = undef;
            $elem300 = new thrift::adept::common::Relation();
            $xfer += $elem300->read($input);
            push(@{$self->{relations}},$elem300);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size301 = 0;
          $self->{sarcasms} = [];
          my $_etype304 = 0;
          $xfer += $input->readListBegin(\$_etype304, \$_size301);
          for (my $_i305 = 0; $_i305 < $_size301; ++$_i305)
          {
            my $elem306 = undef;
            $elem306 = new thrift::adept::common::Sarcasm();
            $xfer += $elem306->read($input);
            push(@{$self->{sarcasms}},$elem306);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size307 = 0;
          $self->{sentences} = [];
          my $_etype310 = 0;
          $xfer += $input->readListBegin(\$_etype310, \$_size307);
          for (my $_i311 = 0; $_i311 < $_size307; ++$_i311)
          {
            my $elem312 = undef;
            $elem312 = new thrift::adept::common::Sentence();
            $xfer += $elem312->read($input);
            push(@{$self->{sentences}},$elem312);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size313 = 0;
          $self->{syntacticChunks} = [];
          my $_etype316 = 0;
          $xfer += $input->readListBegin(\$_etype316, \$_size313);
          for (my $_i317 = 0; $_i317 < $_size313; ++$_i317)
          {
            my $elem318 = undef;
            $elem318 = new thrift::adept::common::SyntacticChunk();
            $xfer += $elem318->read($input);
            push(@{$self->{syntacticChunks}},$elem318);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size319 = 0;
          $self->{sessions} = [];
          my $_etype322 = 0;
          $xfer += $input->readListBegin(\$_etype322, \$_size319);
          for (my $_i323 = 0; $_i323 < $_size319; ++$_i323)
          {
            my $elem324 = undef;
            $elem324 = new thrift::adept::common::Session();
            $xfer += $elem324->read($input);
            push(@{$self->{sessions}},$elem324);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size325 = 0;
          $self->{utterances} = [];
          my $_etype328 = 0;
          $xfer += $input->readListBegin(\$_etype328, \$_size325);
          for (my $_i329 = 0; $_i329 < $_size325; ++$_i329)
          {
            my $elem330 = undef;
            $elem330 = new thrift::adept::common::Utterance();
            $xfer += $elem330->read($input);
            push(@{$self->{utterances}},$elem330);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size331 = 0;
          $self->{messages} = [];
          my $_etype334 = 0;
          $xfer += $input->readListBegin(\$_etype334, \$_size331);
          for (my $_i335 = 0; $_i335 < $_size331; ++$_i335)
          {
            my $elem336 = undef;
            $elem336 = new thrift::adept::common::Message();
            $xfer += $elem336->read($input);
            push(@{$self->{messages}},$elem336);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size337 = 0;
          $self->{interPausalUnits} = [];
          my $_etype340 = 0;
          $xfer += $input->readListBegin(\$_etype340, \$_size337);
          for (my $_i341 = 0; $_i341 < $_size337; ++$_i341)
          {
            my $elem342 = undef;
            $elem342 = new thrift::adept::common::InterPausalUnit();
            $xfer += $elem342->read($input);
            push(@{$self->{interPausalUnits}},$elem342);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size343 = 0;
          $self->{events} = [];
          my $_etype346 = 0;
          $xfer += $input->readListBegin(\$_etype346, \$_size343);
          for (my $_i347 = 0; $_i347 < $_size343; ++$_i347)
          {
            my $elem348 = undef;
            $elem348 = new thrift::adept::common::Event();
            $xfer += $elem348->read($input);
            push(@{$self->{events}},$elem348);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size349 = 0;
          $self->{eventRelations} = [];
          my $_etype352 = 0;
          $xfer += $input->readListBegin(\$_etype352, \$_size349);
          for (my $_i353 = 0; $_i353 < $_size349; ++$_i353)
          {
            my $elem354 = undef;
            $elem354 = new thrift::adept::common::EventRelations();
            $xfer += $elem354->read($input);
            push(@{$self->{eventRelations}},$elem354);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^22$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^23$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^24$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{algorithmName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HltContentContainer');
  if (defined $self->{committedBeliefs}) {
    $xfer += $output->writeFieldBegin('committedBeliefs', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{committedBeliefs}}));
      {
        foreach my $iter355 (@{$self->{committedBeliefs}}) 
        {
          $xfer += ${iter355}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{coreferences}) {
    $xfer += $output->writeFieldBegin('coreferences', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{coreferences}}));
      {
        foreach my $iter356 (@{$self->{coreferences}}) 
        {
          $xfer += ${iter356}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dependencies}) {
    $xfer += $output->writeFieldBegin('dependencies', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{dependencies}}));
      {
        foreach my $iter357 (@{$self->{dependencies}}) 
        {
          $xfer += ${iter357}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entityMentions}) {
    $xfer += $output->writeFieldBegin('entityMentions', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{entityMentions}}));
      {
        foreach my $iter358 (@{$self->{entityMentions}}) 
        {
          $xfer += ${iter358}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{jointRelationCoreferences}) {
    $xfer += $output->writeFieldBegin('jointRelationCoreferences', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{jointRelationCoreferences}}));
      {
        foreach my $iter359 (@{$self->{jointRelationCoreferences}}) 
        {
          $xfer += ${iter359}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{namedEntities}) {
    $xfer += $output->writeFieldBegin('namedEntities', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{namedEntities}}));
      {
        foreach my $iter360 (@{$self->{namedEntities}}) 
        {
          $xfer += ${iter360}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{opinions}) {
    $xfer += $output->writeFieldBegin('opinions', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{opinions}}));
      {
        foreach my $iter361 (@{$self->{opinions}}) 
        {
          $xfer += ${iter361}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partOfSpeechs}) {
    $xfer += $output->writeFieldBegin('partOfSpeechs', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{partOfSpeechs}}));
      {
        foreach my $iter362 (@{$self->{partOfSpeechs}}) 
        {
          $xfer += ${iter362}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{passages}) {
    $xfer += $output->writeFieldBegin('passages', TType::LIST, 9);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{passages}}));
      {
        foreach my $iter363 (@{$self->{passages}}) 
        {
          $xfer += ${iter363}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{posts}) {
    $xfer += $output->writeFieldBegin('posts', TType::LIST, 10);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{posts}}));
      {
        foreach my $iter364 (@{$self->{posts}}) 
        {
          $xfer += ${iter364}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{prosodicPhrases}) {
    $xfer += $output->writeFieldBegin('prosodicPhrases', TType::LIST, 11);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{prosodicPhrases}}));
      {
        foreach my $iter365 (@{$self->{prosodicPhrases}}) 
        {
          $xfer += ${iter365}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{relations}) {
    $xfer += $output->writeFieldBegin('relations', TType::LIST, 12);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{relations}}));
      {
        foreach my $iter366 (@{$self->{relations}}) 
        {
          $xfer += ${iter366}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sarcasms}) {
    $xfer += $output->writeFieldBegin('sarcasms', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sarcasms}}));
      {
        foreach my $iter367 (@{$self->{sarcasms}}) 
        {
          $xfer += ${iter367}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentences}) {
    $xfer += $output->writeFieldBegin('sentences', TType::LIST, 14);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sentences}}));
      {
        foreach my $iter368 (@{$self->{sentences}}) 
        {
          $xfer += ${iter368}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{syntacticChunks}) {
    $xfer += $output->writeFieldBegin('syntacticChunks', TType::LIST, 15);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{syntacticChunks}}));
      {
        foreach my $iter369 (@{$self->{syntacticChunks}}) 
        {
          $xfer += ${iter369}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sessions}) {
    $xfer += $output->writeFieldBegin('sessions', TType::LIST, 16);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sessions}}));
      {
        foreach my $iter370 (@{$self->{sessions}}) 
        {
          $xfer += ${iter370}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{utterances}) {
    $xfer += $output->writeFieldBegin('utterances', TType::LIST, 17);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{utterances}}));
      {
        foreach my $iter371 (@{$self->{utterances}}) 
        {
          $xfer += ${iter371}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{messages}) {
    $xfer += $output->writeFieldBegin('messages', TType::LIST, 18);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{messages}}));
      {
        foreach my $iter372 (@{$self->{messages}}) 
        {
          $xfer += ${iter372}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{interPausalUnits}) {
    $xfer += $output->writeFieldBegin('interPausalUnits', TType::LIST, 19);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{interPausalUnits}}));
      {
        foreach my $iter373 (@{$self->{interPausalUnits}}) 
        {
          $xfer += ${iter373}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{events}) {
    $xfer += $output->writeFieldBegin('events', TType::LIST, 20);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{events}}));
      {
        foreach my $iter374 (@{$self->{events}}) 
        {
          $xfer += ${iter374}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{eventRelations}) {
    $xfer += $output->writeFieldBegin('eventRelations', TType::LIST, 21);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{eventRelations}}));
      {
        foreach my $iter375 (@{$self->{eventRelations}}) 
        {
          $xfer += ${iter375}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 22);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 23);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{algorithmName}) {
    $xfer += $output->writeFieldBegin('algorithmName', TType::STRING, 24);
    $xfer += $output->writeString($self->{algorithmName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::HltContentContainerList;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerList->mk_accessors( qw( id serialVersionUID hltContentContainerList ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{serialVersionUID} = 651655831447893195;
  $self->{hltContentContainerList} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{serialVersionUID}) {
      $self->{serialVersionUID} = $vals->{serialVersionUID};
    }
    if (defined $vals->{hltContentContainerList}) {
      $self->{hltContentContainerList} = $vals->{hltContentContainerList};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HltContentContainerList';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{id} = new thrift::adept::common::ID();
        $xfer += $self->{id}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{serialVersionUID});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size376 = 0;
          $self->{hltContentContainerList} = [];
          my $_etype379 = 0;
          $xfer += $input->readListBegin(\$_etype379, \$_size376);
          for (my $_i380 = 0; $_i380 < $_size376; ++$_i380)
          {
            my $elem381 = undef;
            $elem381 = new thrift::adept::common::HltContentContainer();
            $xfer += $elem381->read($input);
            push(@{$self->{hltContentContainerList}},$elem381);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HltContentContainerList');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRUCT, 1);
    $xfer += $self->{id}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serialVersionUID}) {
    $xfer += $output->writeFieldBegin('serialVersionUID', TType::I64, 2);
    $xfer += $output->writeI64($self->{serialVersionUID});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hltContentContainerList}) {
    $xfer += $output->writeFieldBegin('hltContentContainerList', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{hltContentContainerList}}));
      {
        foreach my $iter382 (@{$self->{hltContentContainerList}}) 
        {
          $xfer += ${iter382}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::Translation;
use base qw(Class::Accessor);
thrift::adept::common::Translation->mk_accessors( qw( sourceChunk targetChunk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sourceChunk} = undef;
  $self->{targetChunk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sourceChunk}) {
      $self->{sourceChunk} = $vals->{sourceChunk};
    }
    if (defined $vals->{targetChunk}) {
      $self->{targetChunk} = $vals->{targetChunk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Translation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sourceChunk} = new thrift::adept::common::ChunkUnion();
        $xfer += $self->{sourceChunk}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{targetChunk} = new thrift::adept::common::ChunkUnion();
        $xfer += $self->{targetChunk}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Translation');
  if (defined $self->{sourceChunk}) {
    $xfer += $output->writeFieldBegin('sourceChunk', TType::STRUCT, 1);
    $xfer += $self->{sourceChunk}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{targetChunk}) {
    $xfer += $output->writeFieldBegin('targetChunk', TType::STRUCT, 2);
    $xfer += $self->{targetChunk}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package thrift::adept::common::HltContentUnion;
use base qw(Class::Accessor);
thrift::adept::common::HltContentUnion->mk_accessors( qw( anomalousText argument chunk committedBelief discourseUnit entityMention opinion partOfSpeech passage prosodicPhrase sarcasm sentence story syntacticChunk utterance coreference dependency entity hltContentContainer interPausalUnit jointRelationCoreference paraphrase relation sentenceSimilarity chunkUnion ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{anomalousText} = undef;
  $self->{argument} = undef;
  $self->{chunk} = undef;
  $self->{committedBelief} = undef;
  $self->{discourseUnit} = undef;
  $self->{entityMention} = undef;
  $self->{opinion} = undef;
  $self->{partOfSpeech} = undef;
  $self->{passage} = undef;
  $self->{prosodicPhrase} = undef;
  $self->{sarcasm} = undef;
  $self->{sentence} = undef;
  $self->{story} = undef;
  $self->{syntacticChunk} = undef;
  $self->{utterance} = undef;
  $self->{coreference} = undef;
  $self->{dependency} = undef;
  $self->{entity} = undef;
  $self->{hltContentContainer} = undef;
  $self->{interPausalUnit} = undef;
  $self->{jointRelationCoreference} = undef;
  $self->{paraphrase} = undef;
  $self->{relation} = undef;
  $self->{sentenceSimilarity} = undef;
  $self->{chunkUnion} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{anomalousText}) {
      $self->{anomalousText} = $vals->{anomalousText};
    }
    if (defined $vals->{argument}) {
      $self->{argument} = $vals->{argument};
    }
    if (defined $vals->{chunk}) {
      $self->{chunk} = $vals->{chunk};
    }
    if (defined $vals->{committedBelief}) {
      $self->{committedBelief} = $vals->{committedBelief};
    }
    if (defined $vals->{discourseUnit}) {
      $self->{discourseUnit} = $vals->{discourseUnit};
    }
    if (defined $vals->{entityMention}) {
      $self->{entityMention} = $vals->{entityMention};
    }
    if (defined $vals->{opinion}) {
      $self->{opinion} = $vals->{opinion};
    }
    if (defined $vals->{partOfSpeech}) {
      $self->{partOfSpeech} = $vals->{partOfSpeech};
    }
    if (defined $vals->{passage}) {
      $self->{passage} = $vals->{passage};
    }
    if (defined $vals->{prosodicPhrase}) {
      $self->{prosodicPhrase} = $vals->{prosodicPhrase};
    }
    if (defined $vals->{sarcasm}) {
      $self->{sarcasm} = $vals->{sarcasm};
    }
    if (defined $vals->{sentence}) {
      $self->{sentence} = $vals->{sentence};
    }
    if (defined $vals->{story}) {
      $self->{story} = $vals->{story};
    }
    if (defined $vals->{syntacticChunk}) {
      $self->{syntacticChunk} = $vals->{syntacticChunk};
    }
    if (defined $vals->{utterance}) {
      $self->{utterance} = $vals->{utterance};
    }
    if (defined $vals->{coreference}) {
      $self->{coreference} = $vals->{coreference};
    }
    if (defined $vals->{dependency}) {
      $self->{dependency} = $vals->{dependency};
    }
    if (defined $vals->{entity}) {
      $self->{entity} = $vals->{entity};
    }
    if (defined $vals->{hltContentContainer}) {
      $self->{hltContentContainer} = $vals->{hltContentContainer};
    }
    if (defined $vals->{interPausalUnit}) {
      $self->{interPausalUnit} = $vals->{interPausalUnit};
    }
    if (defined $vals->{jointRelationCoreference}) {
      $self->{jointRelationCoreference} = $vals->{jointRelationCoreference};
    }
    if (defined $vals->{paraphrase}) {
      $self->{paraphrase} = $vals->{paraphrase};
    }
    if (defined $vals->{relation}) {
      $self->{relation} = $vals->{relation};
    }
    if (defined $vals->{sentenceSimilarity}) {
      $self->{sentenceSimilarity} = $vals->{sentenceSimilarity};
    }
    if (defined $vals->{chunkUnion}) {
      $self->{chunkUnion} = $vals->{chunkUnion};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HltContentUnion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{anomalousText} = new thrift::adept::common::AnomalousText();
        $xfer += $self->{anomalousText}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{argument} = new thrift::adept::common::Argument();
        $xfer += $self->{argument}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{chunk} = new thrift::adept::common::Chunk();
        $xfer += $self->{chunk}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{committedBelief} = new thrift::adept::common::CommittedBelief();
        $xfer += $self->{committedBelief}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{discourseUnit} = new thrift::adept::common::DiscourseUnit();
        $xfer += $self->{discourseUnit}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entityMention} = new thrift::adept::common::EntityMention();
        $xfer += $self->{entityMention}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{opinion} = new thrift::adept::common::Opinion();
        $xfer += $self->{opinion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{partOfSpeech} = new thrift::adept::common::PartOfSpeech();
        $xfer += $self->{partOfSpeech}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{passage} = new thrift::adept::common::Passage();
        $xfer += $self->{passage}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{prosodicPhrase} = new thrift::adept::common::ProsodicPhrase();
        $xfer += $self->{prosodicPhrase}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sarcasm} = new thrift::adept::common::Sarcasm();
        $xfer += $self->{sarcasm}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sentence} = new thrift::adept::common::Sentence();
        $xfer += $self->{sentence}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{story} = new thrift::adept::common::Story();
        $xfer += $self->{story}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{syntacticChunk} = new thrift::adept::common::SyntacticChunk();
        $xfer += $self->{syntacticChunk}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{utterance} = new thrift::adept::common::Utterance();
        $xfer += $self->{utterance}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{coreference} = new thrift::adept::common::Coreference();
        $xfer += $self->{coreference}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{dependency} = new thrift::adept::common::Dependency();
        $xfer += $self->{dependency}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{entity} = new thrift::adept::common::Entity();
        $xfer += $self->{entity}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hltContentContainer} = new thrift::adept::common::HltContentContainer();
        $xfer += $self->{hltContentContainer}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{interPausalUnit} = new thrift::adept::common::InterPausalUnit();
        $xfer += $self->{interPausalUnit}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{jointRelationCoreference} = new thrift::adept::common::JointRelationCoreference();
        $xfer += $self->{jointRelationCoreference}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^22$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{paraphrase} = new thrift::adept::common::Paraphrase();
        $xfer += $self->{paraphrase}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^23$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{relation} = new thrift::adept::common::Relation();
        $xfer += $self->{relation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^24$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sentenceSimilarity} = new thrift::adept::common::SentenceSimilarity();
        $xfer += $self->{sentenceSimilarity}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^25$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{chunkUnion} = new thrift::adept::common::ChunkUnion();
        $xfer += $self->{chunkUnion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HltContentUnion');
  if (defined $self->{anomalousText}) {
    $xfer += $output->writeFieldBegin('anomalousText', TType::STRUCT, 1);
    $xfer += $self->{anomalousText}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{argument}) {
    $xfer += $output->writeFieldBegin('argument', TType::STRUCT, 2);
    $xfer += $self->{argument}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{chunk}) {
    $xfer += $output->writeFieldBegin('chunk', TType::STRUCT, 3);
    $xfer += $self->{chunk}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{committedBelief}) {
    $xfer += $output->writeFieldBegin('committedBelief', TType::STRUCT, 4);
    $xfer += $self->{committedBelief}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{discourseUnit}) {
    $xfer += $output->writeFieldBegin('discourseUnit', TType::STRUCT, 5);
    $xfer += $self->{discourseUnit}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entityMention}) {
    $xfer += $output->writeFieldBegin('entityMention', TType::STRUCT, 6);
    $xfer += $self->{entityMention}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{opinion}) {
    $xfer += $output->writeFieldBegin('opinion', TType::STRUCT, 7);
    $xfer += $self->{opinion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partOfSpeech}) {
    $xfer += $output->writeFieldBegin('partOfSpeech', TType::STRUCT, 8);
    $xfer += $self->{partOfSpeech}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{passage}) {
    $xfer += $output->writeFieldBegin('passage', TType::STRUCT, 9);
    $xfer += $self->{passage}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{prosodicPhrase}) {
    $xfer += $output->writeFieldBegin('prosodicPhrase', TType::STRUCT, 10);
    $xfer += $self->{prosodicPhrase}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sarcasm}) {
    $xfer += $output->writeFieldBegin('sarcasm', TType::STRUCT, 11);
    $xfer += $self->{sarcasm}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentence}) {
    $xfer += $output->writeFieldBegin('sentence', TType::STRUCT, 12);
    $xfer += $self->{sentence}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{story}) {
    $xfer += $output->writeFieldBegin('story', TType::STRUCT, 13);
    $xfer += $self->{story}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{syntacticChunk}) {
    $xfer += $output->writeFieldBegin('syntacticChunk', TType::STRUCT, 14);
    $xfer += $self->{syntacticChunk}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{utterance}) {
    $xfer += $output->writeFieldBegin('utterance', TType::STRUCT, 15);
    $xfer += $self->{utterance}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{coreference}) {
    $xfer += $output->writeFieldBegin('coreference', TType::STRUCT, 16);
    $xfer += $self->{coreference}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dependency}) {
    $xfer += $output->writeFieldBegin('dependency', TType::STRUCT, 17);
    $xfer += $self->{dependency}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{entity}) {
    $xfer += $output->writeFieldBegin('entity', TType::STRUCT, 18);
    $xfer += $self->{entity}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hltContentContainer}) {
    $xfer += $output->writeFieldBegin('hltContentContainer', TType::STRUCT, 19);
    $xfer += $self->{hltContentContainer}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{interPausalUnit}) {
    $xfer += $output->writeFieldBegin('interPausalUnit', TType::STRUCT, 20);
    $xfer += $self->{interPausalUnit}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{jointRelationCoreference}) {
    $xfer += $output->writeFieldBegin('jointRelationCoreference', TType::STRUCT, 21);
    $xfer += $self->{jointRelationCoreference}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{paraphrase}) {
    $xfer += $output->writeFieldBegin('paraphrase', TType::STRUCT, 22);
    $xfer += $self->{paraphrase}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{relation}) {
    $xfer += $output->writeFieldBegin('relation', TType::STRUCT, 23);
    $xfer += $self->{relation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sentenceSimilarity}) {
    $xfer += $output->writeFieldBegin('sentenceSimilarity', TType::STRUCT, 24);
    $xfer += $self->{sentenceSimilarity}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{chunkUnion}) {
    $xfer += $output->writeFieldBegin('chunkUnion', TType::STRUCT, 25);
    $xfer += $self->{chunkUnion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
