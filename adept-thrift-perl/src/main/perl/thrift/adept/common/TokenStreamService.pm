#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::TokenStreamService_getChannelName_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getChannelName_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getChannelName_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getChannelName_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getChannelName_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getChannelName_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getChannelName_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getContentType_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getContentType_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getContentType_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getContentType_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getContentType_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getContentType_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getContentType_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getDocument_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getDocument_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getDocument_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getDocument_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getDocument_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getDocument_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::STRUCT) {
                      $self->{success} = new thrift::adept::common::Document();
                      $xfer += $self->{success}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getDocument_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                  $xfer += $self->{success}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getLanguage_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getLanguage_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getLanguage_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getLanguage_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getLanguage_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getLanguage_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::STRING) {
                      $xfer += $input->readString(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getLanguage_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
                  $xfer += $output->writeString($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getSerialversionuid_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getSerialversionuid_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getSerialversionuid_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getSerialversionuid_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getSerialversionuid_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getSerialversionuid_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I64) {
                      $xfer += $input->readI64(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getSerialversionuid_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I64, 0);
                  $xfer += $output->writeI64($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getSpeechUnit_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getSpeechUnit_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getSpeechUnit_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getSpeechUnit_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getSpeechUnit_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getSpeechUnit_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getSpeechUnit_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTextValue_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTextValue_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTextValue_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTextValue_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getTextValue_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTextValue_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::STRING) {
                      $xfer += $input->readString(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTextValue_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
                  $xfer += $output->writeString($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTokenizerType_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTokenizerType_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTokenizerType_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTokenizerType_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getTokenizerType_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTokenizerType_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTokenizerType_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTranscriptType_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTranscriptType_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTranscriptType_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTranscriptType_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getTranscriptType_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTranscriptType_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTranscriptType_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTranslatorName_args;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTranslatorName_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTranslatorName_args');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_getTranslatorName_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_getTranslatorName_result->mk_accessors( qw( success ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{success} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{success}) {
                    $self->{success} = $vals->{success};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_getTranslatorName_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^0$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{success});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_getTranslatorName_result');
                if (defined $self->{success}) {
                  $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                  $xfer += $output->writeI32($self->{success});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setAsrName_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_setAsrName_args->mk_accessors( qw( asrName ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{asrName} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{asrName}) {
                    $self->{asrName} = $vals->{asrName};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setAsrName_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{asrName});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setAsrName_args');
                if (defined $self->{asrName}) {
                  $xfer += $output->writeFieldBegin('asrName', TType::I32, 1);
                  $xfer += $output->writeI32($self->{asrName});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setAsrName_result;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setAsrName_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setAsrName_result');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setDocument_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_setDocument_args->mk_accessors( qw( document ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{document} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{document}) {
                    $self->{document} = $vals->{document};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setDocument_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == TType::STRUCT) {
                      $self->{document} = new thrift::adept::common::Document();
                      $xfer += $self->{document}->read($input);
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setDocument_args');
                if (defined $self->{document}) {
                  $xfer += $output->writeFieldBegin('document', TType::STRUCT, 1);
                  $xfer += $self->{document}->write($output);
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setDocument_result;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setDocument_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setDocument_result');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setSpeechUnit_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_setSpeechUnit_args->mk_accessors( qw( speechUnit ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{speechUnit} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{speechUnit}) {
                    $self->{speechUnit} = $vals->{speechUnit};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setSpeechUnit_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{speechUnit});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setSpeechUnit_args');
                if (defined $self->{speechUnit}) {
                  $xfer += $output->writeFieldBegin('speechUnit', TType::I32, 1);
                  $xfer += $output->writeI32($self->{speechUnit});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setSpeechUnit_result;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setSpeechUnit_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setSpeechUnit_result');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setTranslatorName_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenStreamService_setTranslatorName_args->mk_accessors( qw( translatorName ) );

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                $self->{translatorName} = undef;
                if (UNIVERSAL::isa($vals,'HASH')) {
                  if (defined $vals->{translatorName}) {
                    $self->{translatorName} = $vals->{translatorName};
                  }
                }
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setTranslatorName_args';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                    /^1$/ && do{                    if ($ftype == TType::I32) {
                      $xfer += $input->readI32(\$self->{translatorName});
                    } else {
                      $xfer += $input->skip($ftype);
                    }
                    last; };
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setTranslatorName_args');
                if (defined $self->{translatorName}) {
                  $xfer += $output->writeFieldBegin('translatorName', TType::I32, 1);
                  $xfer += $output->writeI32($self->{translatorName});
                  $xfer += $output->writeFieldEnd();
                }
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamService_setTranslatorName_result;
use base qw(Class::Accessor);

sub new {
                my $classname = shift;
                my $self      = {};
                my $vals      = shift || {};
                return bless ($self, $classname);
}

sub getName {
                return 'TokenStreamService_setTranslatorName_result';
              }

sub read {
                my ($self, $input) = @_;
                my $xfer  = 0;
                my $fname;
                my $ftype = 0;
                my $fid   = 0;
                $xfer += $input->readStructBegin(\$fname);
                while (1) 
                {
                  $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                  if ($ftype == TType::STOP) {
                    last;
                  }
                  SWITCH: for($fid)
                  {
                      $xfer += $input->skip($ftype);
                  }
                  $xfer += $input->readFieldEnd();
                }
                $xfer += $input->readStructEnd();
                return $xfer;
              }

sub write {
                my ($self, $output) = @_;
                my $xfer   = 0;
                $xfer += $output->writeStructBegin('TokenStreamService_setTranslatorName_result');
                $xfer += $output->writeFieldStop();
                $xfer += $output->writeStructEnd();
                return $xfer;
              }

package thrift::adept::common::TokenStreamServiceIf;

use strict;


sub getChannelName{
  my $self = shift;

  die 'implement interface';
}

sub getContentType{
  my $self = shift;

  die 'implement interface';
}

sub getDocument{
  my $self = shift;

  die 'implement interface';
}

sub getLanguage{
  my $self = shift;

  die 'implement interface';
}

sub getSerialversionuid{
  my $self = shift;

  die 'implement interface';
}

sub getSpeechUnit{
  my $self = shift;

  die 'implement interface';
}

sub getTextValue{
  my $self = shift;

  die 'implement interface';
}

sub getTokenizerType{
  my $self = shift;

  die 'implement interface';
}

sub getTranscriptType{
  my $self = shift;

  die 'implement interface';
}

sub getTranslatorName{
  my $self = shift;

  die 'implement interface';
}

sub setAsrName{
  my $self = shift;
  my $asrName = shift;

  die 'implement interface';
}

sub setDocument{
  my $self = shift;
  my $document = shift;

  die 'implement interface';
}

sub setSpeechUnit{
  my $self = shift;
  my $speechUnit = shift;

  die 'implement interface';
}

sub setTranslatorName{
  my $self = shift;
  my $translatorName = shift;

  die 'implement interface';
}

package thrift::adept::common::TokenStreamServiceRest;

use strict;


sub new {
                my ($classname, $impl) = @_;
                my $self     ={ impl => $impl };

                return bless($self,$classname);
}

sub getChannelName{
                my ($self, $request) = @_;

                return $self->{impl}->getChannelName();
              }

sub getContentType{
                my ($self, $request) = @_;

                return $self->{impl}->getContentType();
              }

sub getDocument{
                my ($self, $request) = @_;

                return $self->{impl}->getDocument();
              }

sub getLanguage{
                my ($self, $request) = @_;

                return $self->{impl}->getLanguage();
              }

sub getSerialversionuid{
                my ($self, $request) = @_;

                return $self->{impl}->getSerialversionuid();
              }

sub getSpeechUnit{
                my ($self, $request) = @_;

                return $self->{impl}->getSpeechUnit();
              }

sub getTextValue{
                my ($self, $request) = @_;

                return $self->{impl}->getTextValue();
              }

sub getTokenizerType{
                my ($self, $request) = @_;

                return $self->{impl}->getTokenizerType();
              }

sub getTranscriptType{
                my ($self, $request) = @_;

                return $self->{impl}->getTranscriptType();
              }

sub getTranslatorName{
                my ($self, $request) = @_;

                return $self->{impl}->getTranslatorName();
              }

sub setAsrName{
                my ($self, $request) = @_;

                my $asrName = ($request->{'asrName'}) ? $request->{'asrName'} : undef;
                return $self->{impl}->setAsrName($asrName);
              }

sub setDocument{
                my ($self, $request) = @_;

                my $document = ($request->{'document'}) ? $request->{'document'} : undef;
                return $self->{impl}->setDocument($document);
              }

sub setSpeechUnit{
                my ($self, $request) = @_;

                my $speechUnit = ($request->{'speechUnit'}) ? $request->{'speechUnit'} : undef;
                return $self->{impl}->setSpeechUnit($speechUnit);
              }

sub setTranslatorName{
                my ($self, $request) = @_;

                my $translatorName = ($request->{'translatorName'}) ? $request->{'translatorName'} : undef;
                return $self->{impl}->setTranslatorName($translatorName);
              }

package thrift::adept::common::TokenStreamServiceClient;


use base qw(thrift::adept::common::TokenStreamServiceIf);
sub new {
                my ($classname, $input, $output) = @_;
                my $self      = {};
                $self->{input}  = $input;
                $self->{output} = defined $output ? $output : $input;
                $self->{seqid}  = 0;
                return bless($self,$classname);
}

sub getChannelName{
  my $self = shift;

                                $self->send_getChannelName();
                return $self->recv_getChannelName();
}

sub send_getChannelName{
  my $self = shift;

                $self->{output}->writeMessageBegin('getChannelName', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getChannelName_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getChannelName{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getChannelName_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getChannelName failed: unknown result";
}
sub getContentType{
  my $self = shift;

                                $self->send_getContentType();
                return $self->recv_getContentType();
}

sub send_getContentType{
  my $self = shift;

                $self->{output}->writeMessageBegin('getContentType', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getContentType_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getContentType{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getContentType_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getContentType failed: unknown result";
}
sub getDocument{
  my $self = shift;

                                $self->send_getDocument();
                return $self->recv_getDocument();
}

sub send_getDocument{
  my $self = shift;

                $self->{output}->writeMessageBegin('getDocument', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getDocument_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getDocument{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getDocument_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getDocument failed: unknown result";
}
sub getLanguage{
  my $self = shift;

                                $self->send_getLanguage();
                return $self->recv_getLanguage();
}

sub send_getLanguage{
  my $self = shift;

                $self->{output}->writeMessageBegin('getLanguage', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getLanguage_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getLanguage{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getLanguage_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getLanguage failed: unknown result";
}
sub getSerialversionuid{
  my $self = shift;

                                $self->send_getSerialversionuid();
                return $self->recv_getSerialversionuid();
}

sub send_getSerialversionuid{
  my $self = shift;

                $self->{output}->writeMessageBegin('getSerialversionuid', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getSerialversionuid_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getSerialversionuid{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getSerialversionuid_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getSerialversionuid failed: unknown result";
}
sub getSpeechUnit{
  my $self = shift;

                                $self->send_getSpeechUnit();
                return $self->recv_getSpeechUnit();
}

sub send_getSpeechUnit{
  my $self = shift;

                $self->{output}->writeMessageBegin('getSpeechUnit', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getSpeechUnit_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getSpeechUnit{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getSpeechUnit_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getSpeechUnit failed: unknown result";
}
sub getTextValue{
  my $self = shift;

                                $self->send_getTextValue();
                return $self->recv_getTextValue();
}

sub send_getTextValue{
  my $self = shift;

                $self->{output}->writeMessageBegin('getTextValue', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getTextValue_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getTextValue{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getTextValue_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getTextValue failed: unknown result";
}
sub getTokenizerType{
  my $self = shift;

                                $self->send_getTokenizerType();
                return $self->recv_getTokenizerType();
}

sub send_getTokenizerType{
  my $self = shift;

                $self->{output}->writeMessageBegin('getTokenizerType', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getTokenizerType_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getTokenizerType{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getTokenizerType_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getTokenizerType failed: unknown result";
}
sub getTranscriptType{
  my $self = shift;

                                $self->send_getTranscriptType();
                return $self->recv_getTranscriptType();
}

sub send_getTranscriptType{
  my $self = shift;

                $self->{output}->writeMessageBegin('getTranscriptType', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getTranscriptType_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getTranscriptType{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getTranscriptType_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getTranscriptType failed: unknown result";
}
sub getTranslatorName{
  my $self = shift;

                                $self->send_getTranslatorName();
                return $self->recv_getTranslatorName();
}

sub send_getTranslatorName{
  my $self = shift;

                $self->{output}->writeMessageBegin('getTranslatorName', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_getTranslatorName_args();
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_getTranslatorName{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_getTranslatorName_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                if (defined $result->{success} ) {
                  return $result->{success};
                }
                die "getTranslatorName failed: unknown result";
}
sub setAsrName{
  my $self = shift;
  my $asrName = shift;

                                $self->send_setAsrName($asrName);
                $self->recv_setAsrName();
}

sub send_setAsrName{
  my $self = shift;
  my $asrName = shift;

                $self->{output}->writeMessageBegin('setAsrName', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_setAsrName_args();
                $args->{asrName} = $asrName;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_setAsrName{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_setAsrName_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                return;
}
sub setDocument{
  my $self = shift;
  my $document = shift;

                                $self->send_setDocument($document);
                $self->recv_setDocument();
}

sub send_setDocument{
  my $self = shift;
  my $document = shift;

                $self->{output}->writeMessageBegin('setDocument', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_setDocument_args();
                $args->{document} = $document;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_setDocument{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_setDocument_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                return;
}
sub setSpeechUnit{
  my $self = shift;
  my $speechUnit = shift;

                                $self->send_setSpeechUnit($speechUnit);
                $self->recv_setSpeechUnit();
}

sub send_setSpeechUnit{
  my $self = shift;
  my $speechUnit = shift;

                $self->{output}->writeMessageBegin('setSpeechUnit', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_setSpeechUnit_args();
                $args->{speechUnit} = $speechUnit;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_setSpeechUnit{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_setSpeechUnit_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                return;
}
sub setTranslatorName{
  my $self = shift;
  my $translatorName = shift;

                                $self->send_setTranslatorName($translatorName);
                $self->recv_setTranslatorName();
}

sub send_setTranslatorName{
  my $self = shift;
  my $translatorName = shift;

                $self->{output}->writeMessageBegin('setTranslatorName', TMessageType::CALL, $self->{seqid});
                my $args = new thrift::adept::common::TokenStreamService_setTranslatorName_args();
                $args->{translatorName} = $translatorName;
                $args->write($self->{output});
                $self->{output}->writeMessageEnd();
                $self->{output}->getTransport()->flush();
}

sub recv_setTranslatorName{
  my $self = shift;

                my $rseqid = 0;
                my $fname;
                my $mtype = 0;

                $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                if ($mtype == TMessageType::EXCEPTION) {
                  my $x = new TApplicationException();
                  $x->read($self->{input});
                  $self->{input}->readMessageEnd();
                  die $x;
                }
                my $result = new thrift::adept::common::TokenStreamService_setTranslatorName_result();
                $result->read($self->{input});
                $self->{input}->readMessageEnd();

                return;
}
package thrift::adept::common::TokenStreamServiceProcessor;

use strict;


sub new {
                  my ($classname, $handler) = @_;
                  my $self      = {};
                  $self->{handler} = $handler;
                  return bless ($self, $classname);
}

sub process {
                  my ($self, $input, $output) = @_;
                  my $rseqid = 0;
                  my $fname  = undef;
                  my $mtype  = 0;

                  $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                  my $methodname = 'process_'.$fname;
                  if (!$self->can($methodname)) {
                    $input->skip(TType::STRUCT);
                    $input->readMessageEnd();
                    my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                    $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                    $x->write($output);
                    $output->writeMessageEnd();
                    $output->getTransport()->flush();
                    return;
                  }
                  $self->$methodname($rseqid, $input, $output);
                  return 1;
}

sub process_getChannelName {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getChannelName_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getChannelName_result();
                  $result->{success} = $self->{handler}->getChannelName();
                  $output->writeMessageBegin('getChannelName', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getContentType {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getContentType_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getContentType_result();
                  $result->{success} = $self->{handler}->getContentType();
                  $output->writeMessageBegin('getContentType', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getDocument {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getDocument_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getDocument_result();
                  $result->{success} = $self->{handler}->getDocument();
                  $output->writeMessageBegin('getDocument', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getLanguage {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getLanguage_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getLanguage_result();
                  $result->{success} = $self->{handler}->getLanguage();
                  $output->writeMessageBegin('getLanguage', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getSerialversionuid {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getSerialversionuid_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getSerialversionuid_result();
                  $result->{success} = $self->{handler}->getSerialversionuid();
                  $output->writeMessageBegin('getSerialversionuid', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getSpeechUnit {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getSpeechUnit_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getSpeechUnit_result();
                  $result->{success} = $self->{handler}->getSpeechUnit();
                  $output->writeMessageBegin('getSpeechUnit', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getTextValue {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getTextValue_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getTextValue_result();
                  $result->{success} = $self->{handler}->getTextValue();
                  $output->writeMessageBegin('getTextValue', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getTokenizerType {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getTokenizerType_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getTokenizerType_result();
                  $result->{success} = $self->{handler}->getTokenizerType();
                  $output->writeMessageBegin('getTokenizerType', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getTranscriptType {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getTranscriptType_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getTranscriptType_result();
                  $result->{success} = $self->{handler}->getTranscriptType();
                  $output->writeMessageBegin('getTranscriptType', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_getTranslatorName {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_getTranslatorName_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_getTranslatorName_result();
                  $result->{success} = $self->{handler}->getTranslatorName();
                  $output->writeMessageBegin('getTranslatorName', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_setAsrName {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_setAsrName_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_setAsrName_result();
                  $self->{handler}->setAsrName($args->asrName);
                  $output->writeMessageBegin('setAsrName', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_setDocument {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_setDocument_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_setDocument_result();
                  $self->{handler}->setDocument($args->document);
                  $output->writeMessageBegin('setDocument', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_setSpeechUnit {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_setSpeechUnit_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_setSpeechUnit_result();
                  $self->{handler}->setSpeechUnit($args->speechUnit);
                  $output->writeMessageBegin('setSpeechUnit', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

sub process_setTranslatorName {
                  my ($self, $seqid, $input, $output) = @_;
                  my $args = new thrift::adept::common::TokenStreamService_setTranslatorName_args();
                  $args->read($input);
                  $input->readMessageEnd();
                  my $result = new thrift::adept::common::TokenStreamService_setTranslatorName_result();
                  $self->{handler}->setTranslatorName($args->translatorName);
                  $output->writeMessageBegin('setTranslatorName', TMessageType::REPLY, $seqid);
                  $result->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
}

1;
