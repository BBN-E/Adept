#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;
use thrift::adept::common::ItemService;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::HltContentContainerService_getCommittedBeliefs_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getCommittedBeliefs_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getCommittedBeliefs_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getCommittedBeliefs_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getCommittedBeliefs_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getCommittedBeliefs_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size524 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype527 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype527, \$_size524);
                                                                          for (my $_i528 = 0; $_i528 < $_size524; ++$_i528)
                                                                          {
                                                                            my $elem529 = undef;
                                                                            $elem529 = new thrift::adept::common::CommittedBelief();
                                                                            $xfer += $elem529->read($input);
                                                                            push(@{$self->{success}},$elem529);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getCommittedBeliefs_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter530 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter530}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getCoreferences_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getCoreferences_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getCoreferences_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getCoreferences_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getCoreferences_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getCoreferences_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size531 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype534 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype534, \$_size531);
                                                                          for (my $_i535 = 0; $_i535 < $_size531; ++$_i535)
                                                                          {
                                                                            my $elem536 = undef;
                                                                            $elem536 = new thrift::adept::common::Coreference();
                                                                            $xfer += $elem536->read($input);
                                                                            push(@{$self->{success}},$elem536);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getCoreferences_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter537 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter537}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getDependencies_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getDependencies_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getDependencies_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getDependencies_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getDependencies_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getDependencies_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size538 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype541 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype541, \$_size538);
                                                                          for (my $_i542 = 0; $_i542 < $_size538; ++$_i542)
                                                                          {
                                                                            my $elem543 = undef;
                                                                            $elem543 = new thrift::adept::common::Dependency();
                                                                            $xfer += $elem543->read($input);
                                                                            push(@{$self->{success}},$elem543);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getDependencies_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter544 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter544}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getEntityMentions_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getEntityMentions_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getEntityMentions_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getEntityMentions_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getEntityMentions_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getEntityMentions_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size545 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype548 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype548, \$_size545);
                                                                          for (my $_i549 = 0; $_i549 < $_size545; ++$_i549)
                                                                          {
                                                                            my $elem550 = undef;
                                                                            $elem550 = new thrift::adept::common::EntityMention();
                                                                            $xfer += $elem550->read($input);
                                                                            push(@{$self->{success}},$elem550);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getEntityMentions_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter551 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter551}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getJointRelationCoreferences_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getJointRelationCoreferences_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getJointRelationCoreferences_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size552 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype555 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype555, \$_size552);
                                                                          for (my $_i556 = 0; $_i556 < $_size552; ++$_i556)
                                                                          {
                                                                            my $elem557 = undef;
                                                                            $elem557 = new thrift::adept::common::JointRelationCoreference();
                                                                            $xfer += $elem557->read($input);
                                                                            push(@{$self->{success}},$elem557);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getJointRelationCoreferences_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter558 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter558}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getMentions_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getMentions_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getMentions_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getMentions_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getMentions_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getMentions_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size559 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype562 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype562, \$_size559);
                                                                          for (my $_i563 = 0; $_i563 < $_size559; ++$_i563)
                                                                          {
                                                                            my $elem564 = undef;
                                                                            $elem564 = new thrift::adept::common::EntityMention();
                                                                            $xfer += $elem564->read($input);
                                                                            push(@{$self->{success}},$elem564);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getMentions_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter565 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter565}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getNamedEntities_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getNamedEntities_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getNamedEntities_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getNamedEntities_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getNamedEntities_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getNamedEntities_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size566 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype569 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype569, \$_size566);
                                                                          for (my $_i570 = 0; $_i570 < $_size566; ++$_i570)
                                                                          {
                                                                            my $elem571 = undef;
                                                                            $elem571 = new thrift::adept::common::EntityMention();
                                                                            $xfer += $elem571->read($input);
                                                                            push(@{$self->{success}},$elem571);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getNamedEntities_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter572 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter572}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getOpinions_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getOpinions_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getOpinions_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getOpinions_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getOpinions_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getOpinions_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size573 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype576 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype576, \$_size573);
                                                                          for (my $_i577 = 0; $_i577 < $_size573; ++$_i577)
                                                                          {
                                                                            my $elem578 = undef;
                                                                            $elem578 = new thrift::adept::common::Opinion();
                                                                            $xfer += $elem578->read($input);
                                                                            push(@{$self->{success}},$elem578);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getOpinions_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter579 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter579}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getPartOfSpeechs_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getPartOfSpeechs_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getPartOfSpeechs_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getPartOfSpeechs_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getPartOfSpeechs_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getPartOfSpeechs_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size580 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype583 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype583, \$_size580);
                                                                          for (my $_i584 = 0; $_i584 < $_size580; ++$_i584)
                                                                          {
                                                                            my $elem585 = undef;
                                                                            $elem585 = new thrift::adept::common::PartOfSpeech();
                                                                            $xfer += $elem585->read($input);
                                                                            push(@{$self->{success}},$elem585);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getPartOfSpeechs_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter586 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter586}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getPassages_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getPassages_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getPassages_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getPassages_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getPassages_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getPassages_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size587 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype590 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype590, \$_size587);
                                                                          for (my $_i591 = 0; $_i591 < $_size587; ++$_i591)
                                                                          {
                                                                            my $elem592 = undef;
                                                                            $elem592 = new thrift::adept::common::Passage();
                                                                            $xfer += $elem592->read($input);
                                                                            push(@{$self->{success}},$elem592);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getPassages_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter593 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter593}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getProsodicPhrases_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getProsodicPhrases_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getProsodicPhrases_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getProsodicPhrases_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getProsodicPhrases_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getProsodicPhrases_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size594 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype597 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype597, \$_size594);
                                                                          for (my $_i598 = 0; $_i598 < $_size594; ++$_i598)
                                                                          {
                                                                            my $elem599 = undef;
                                                                            $elem599 = new thrift::adept::common::ProsodicPhrase();
                                                                            $xfer += $elem599->read($input);
                                                                            push(@{$self->{success}},$elem599);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getProsodicPhrases_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter600 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter600}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getRelations_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getRelations_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getRelations_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getRelations_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getRelations_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getRelations_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size601 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype604 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype604, \$_size601);
                                                                          for (my $_i605 = 0; $_i605 < $_size601; ++$_i605)
                                                                          {
                                                                            my $elem606 = undef;
                                                                            $elem606 = new thrift::adept::common::Relation();
                                                                            $xfer += $elem606->read($input);
                                                                            push(@{$self->{success}},$elem606);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getRelations_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter607 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter607}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getSarcasms_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getSarcasms_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getSarcasms_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getSarcasms_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getSarcasms_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getSarcasms_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size608 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype611 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype611, \$_size608);
                                                                          for (my $_i612 = 0; $_i612 < $_size608; ++$_i612)
                                                                          {
                                                                            my $elem613 = undef;
                                                                            $elem613 = new thrift::adept::common::Sarcasm();
                                                                            $xfer += $elem613->read($input);
                                                                            push(@{$self->{success}},$elem613);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getSarcasms_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter614 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter614}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getSentences_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getSentences_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getSentences_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getSentences_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getSentences_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getSentences_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size615 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype618 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype618, \$_size615);
                                                                          for (my $_i619 = 0; $_i619 < $_size615; ++$_i619)
                                                                          {
                                                                            my $elem620 = undef;
                                                                            $elem620 = new thrift::adept::common::Sentence();
                                                                            $xfer += $elem620->read($input);
                                                                            push(@{$self->{success}},$elem620);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getSentences_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter621 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter621}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getSyntacticChunks_args;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getSyntacticChunks_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getSyntacticChunks_args');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_getSyntacticChunks_result;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_getSyntacticChunks_result->mk_accessors( qw( success ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{success} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{success}) {
                                                                      $self->{success} = $vals->{success};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_getSyntacticChunks_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^0$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size622 = 0;
                                                                          $self->{success} = [];
                                                                          my $_etype625 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype625, \$_size622);
                                                                          for (my $_i626 = 0; $_i626 < $_size622; ++$_i626)
                                                                          {
                                                                            my $elem627 = undef;
                                                                            $elem627 = new thrift::adept::common::SyntacticChunk();
                                                                            $xfer += $elem627->read($input);
                                                                            push(@{$self->{success}},$elem627);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_getSyntacticChunks_result');
                                                                  if (defined $self->{success}) {
                                                                    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                                                                      {
                                                                        foreach my $iter628 (@{$self->{success}}) 
                                                                        {
                                                                          $xfer += ${iter628}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setCommittedBeliefs_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setCommittedBeliefs_args->mk_accessors( qw( committedBeliefs ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{committedBeliefs} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{committedBeliefs}) {
                                                                      $self->{committedBeliefs} = $vals->{committedBeliefs};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setCommittedBeliefs_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size629 = 0;
                                                                          $self->{committedBeliefs} = [];
                                                                          my $_etype632 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype632, \$_size629);
                                                                          for (my $_i633 = 0; $_i633 < $_size629; ++$_i633)
                                                                          {
                                                                            my $elem634 = undef;
                                                                            $elem634 = new thrift::adept::common::CommittedBelief();
                                                                            $xfer += $elem634->read($input);
                                                                            push(@{$self->{committedBeliefs}},$elem634);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setCommittedBeliefs_args');
                                                                  if (defined $self->{committedBeliefs}) {
                                                                    $xfer += $output->writeFieldBegin('committedBeliefs', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{committedBeliefs}}));
                                                                      {
                                                                        foreach my $iter635 (@{$self->{committedBeliefs}}) 
                                                                        {
                                                                          $xfer += ${iter635}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setCommittedBeliefs_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setCommittedBeliefs_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setCommittedBeliefs_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setCoreferences_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setCoreferences_args->mk_accessors( qw( coreferences ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{coreferences} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{coreferences}) {
                                                                      $self->{coreferences} = $vals->{coreferences};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setCoreferences_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size636 = 0;
                                                                          $self->{coreferences} = [];
                                                                          my $_etype639 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype639, \$_size636);
                                                                          for (my $_i640 = 0; $_i640 < $_size636; ++$_i640)
                                                                          {
                                                                            my $elem641 = undef;
                                                                            $elem641 = new thrift::adept::common::Coreference();
                                                                            $xfer += $elem641->read($input);
                                                                            push(@{$self->{coreferences}},$elem641);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setCoreferences_args');
                                                                  if (defined $self->{coreferences}) {
                                                                    $xfer += $output->writeFieldBegin('coreferences', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{coreferences}}));
                                                                      {
                                                                        foreach my $iter642 (@{$self->{coreferences}}) 
                                                                        {
                                                                          $xfer += ${iter642}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setCoreferences_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setCoreferences_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setCoreferences_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setDependencies_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setDependencies_args->mk_accessors( qw( dependencies ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{dependencies} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{dependencies}) {
                                                                      $self->{dependencies} = $vals->{dependencies};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setDependencies_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size643 = 0;
                                                                          $self->{dependencies} = [];
                                                                          my $_etype646 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype646, \$_size643);
                                                                          for (my $_i647 = 0; $_i647 < $_size643; ++$_i647)
                                                                          {
                                                                            my $elem648 = undef;
                                                                            $elem648 = new thrift::adept::common::Dependency();
                                                                            $xfer += $elem648->read($input);
                                                                            push(@{$self->{dependencies}},$elem648);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setDependencies_args');
                                                                  if (defined $self->{dependencies}) {
                                                                    $xfer += $output->writeFieldBegin('dependencies', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{dependencies}}));
                                                                      {
                                                                        foreach my $iter649 (@{$self->{dependencies}}) 
                                                                        {
                                                                          $xfer += ${iter649}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setDependencies_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setDependencies_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setDependencies_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setEntityMentions_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setEntityMentions_args->mk_accessors( qw( entityMentions ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{entityMentions} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{entityMentions}) {
                                                                      $self->{entityMentions} = $vals->{entityMentions};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setEntityMentions_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size650 = 0;
                                                                          $self->{entityMentions} = [];
                                                                          my $_etype653 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype653, \$_size650);
                                                                          for (my $_i654 = 0; $_i654 < $_size650; ++$_i654)
                                                                          {
                                                                            my $elem655 = undef;
                                                                            $elem655 = new thrift::adept::common::EntityMention();
                                                                            $xfer += $elem655->read($input);
                                                                            push(@{$self->{entityMentions}},$elem655);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setEntityMentions_args');
                                                                  if (defined $self->{entityMentions}) {
                                                                    $xfer += $output->writeFieldBegin('entityMentions', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{entityMentions}}));
                                                                      {
                                                                        foreach my $iter656 (@{$self->{entityMentions}}) 
                                                                        {
                                                                          $xfer += ${iter656}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setEntityMentions_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setEntityMentions_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setEntityMentions_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_args->mk_accessors( qw( jointRelationCoreferences ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{jointRelationCoreferences} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{jointRelationCoreferences}) {
                                                                      $self->{jointRelationCoreferences} = $vals->{jointRelationCoreferences};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setJointRelationCoreferences_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size657 = 0;
                                                                          $self->{jointRelationCoreferences} = [];
                                                                          my $_etype660 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype660, \$_size657);
                                                                          for (my $_i661 = 0; $_i661 < $_size657; ++$_i661)
                                                                          {
                                                                            my $elem662 = undef;
                                                                            $elem662 = new thrift::adept::common::JointRelationCoreference();
                                                                            $xfer += $elem662->read($input);
                                                                            push(@{$self->{jointRelationCoreferences}},$elem662);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setJointRelationCoreferences_args');
                                                                  if (defined $self->{jointRelationCoreferences}) {
                                                                    $xfer += $output->writeFieldBegin('jointRelationCoreferences', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{jointRelationCoreferences}}));
                                                                      {
                                                                        foreach my $iter663 (@{$self->{jointRelationCoreferences}}) 
                                                                        {
                                                                          $xfer += ${iter663}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setJointRelationCoreferences_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setJointRelationCoreferences_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setMentions_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setMentions_args->mk_accessors( qw( entityMentions ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{entityMentions} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{entityMentions}) {
                                                                      $self->{entityMentions} = $vals->{entityMentions};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setMentions_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size664 = 0;
                                                                          $self->{entityMentions} = [];
                                                                          my $_etype667 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype667, \$_size664);
                                                                          for (my $_i668 = 0; $_i668 < $_size664; ++$_i668)
                                                                          {
                                                                            my $elem669 = undef;
                                                                            $elem669 = new thrift::adept::common::EntityMention();
                                                                            $xfer += $elem669->read($input);
                                                                            push(@{$self->{entityMentions}},$elem669);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setMentions_args');
                                                                  if (defined $self->{entityMentions}) {
                                                                    $xfer += $output->writeFieldBegin('entityMentions', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{entityMentions}}));
                                                                      {
                                                                        foreach my $iter670 (@{$self->{entityMentions}}) 
                                                                        {
                                                                          $xfer += ${iter670}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setMentions_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setMentions_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setMentions_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setNamedEntities_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setNamedEntities_args->mk_accessors( qw( namedEntities ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{namedEntities} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{namedEntities}) {
                                                                      $self->{namedEntities} = $vals->{namedEntities};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setNamedEntities_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size671 = 0;
                                                                          $self->{namedEntities} = [];
                                                                          my $_etype674 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype674, \$_size671);
                                                                          for (my $_i675 = 0; $_i675 < $_size671; ++$_i675)
                                                                          {
                                                                            my $elem676 = undef;
                                                                            $elem676 = new thrift::adept::common::EntityMention();
                                                                            $xfer += $elem676->read($input);
                                                                            push(@{$self->{namedEntities}},$elem676);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setNamedEntities_args');
                                                                  if (defined $self->{namedEntities}) {
                                                                    $xfer += $output->writeFieldBegin('namedEntities', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{namedEntities}}));
                                                                      {
                                                                        foreach my $iter677 (@{$self->{namedEntities}}) 
                                                                        {
                                                                          $xfer += ${iter677}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setNamedEntities_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setNamedEntities_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setNamedEntities_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setOpinions_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setOpinions_args->mk_accessors( qw( opinions ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{opinions} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{opinions}) {
                                                                      $self->{opinions} = $vals->{opinions};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setOpinions_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size678 = 0;
                                                                          $self->{opinions} = [];
                                                                          my $_etype681 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype681, \$_size678);
                                                                          for (my $_i682 = 0; $_i682 < $_size678; ++$_i682)
                                                                          {
                                                                            my $elem683 = undef;
                                                                            $elem683 = new thrift::adept::common::Opinion();
                                                                            $xfer += $elem683->read($input);
                                                                            push(@{$self->{opinions}},$elem683);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setOpinions_args');
                                                                  if (defined $self->{opinions}) {
                                                                    $xfer += $output->writeFieldBegin('opinions', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{opinions}}));
                                                                      {
                                                                        foreach my $iter684 (@{$self->{opinions}}) 
                                                                        {
                                                                          $xfer += ${iter684}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setOpinions_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setOpinions_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setOpinions_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setPartOfSpeechs_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setPartOfSpeechs_args->mk_accessors( qw( partOfSpeechs ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{partOfSpeechs} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{partOfSpeechs}) {
                                                                      $self->{partOfSpeechs} = $vals->{partOfSpeechs};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setPartOfSpeechs_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size685 = 0;
                                                                          $self->{partOfSpeechs} = [];
                                                                          my $_etype688 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype688, \$_size685);
                                                                          for (my $_i689 = 0; $_i689 < $_size685; ++$_i689)
                                                                          {
                                                                            my $elem690 = undef;
                                                                            $elem690 = new thrift::adept::common::PartOfSpeech();
                                                                            $xfer += $elem690->read($input);
                                                                            push(@{$self->{partOfSpeechs}},$elem690);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setPartOfSpeechs_args');
                                                                  if (defined $self->{partOfSpeechs}) {
                                                                    $xfer += $output->writeFieldBegin('partOfSpeechs', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{partOfSpeechs}}));
                                                                      {
                                                                        foreach my $iter691 (@{$self->{partOfSpeechs}}) 
                                                                        {
                                                                          $xfer += ${iter691}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setPartOfSpeechs_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setPartOfSpeechs_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setPartOfSpeechs_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setPassages_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setPassages_args->mk_accessors( qw( passages ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{passages} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{passages}) {
                                                                      $self->{passages} = $vals->{passages};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setPassages_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size692 = 0;
                                                                          $self->{passages} = [];
                                                                          my $_etype695 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype695, \$_size692);
                                                                          for (my $_i696 = 0; $_i696 < $_size692; ++$_i696)
                                                                          {
                                                                            my $elem697 = undef;
                                                                            $elem697 = new thrift::adept::common::Passage();
                                                                            $xfer += $elem697->read($input);
                                                                            push(@{$self->{passages}},$elem697);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setPassages_args');
                                                                  if (defined $self->{passages}) {
                                                                    $xfer += $output->writeFieldBegin('passages', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{passages}}));
                                                                      {
                                                                        foreach my $iter698 (@{$self->{passages}}) 
                                                                        {
                                                                          $xfer += ${iter698}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setPassages_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setPassages_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setPassages_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setProsodicPhrases_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setProsodicPhrases_args->mk_accessors( qw( prosodicPhrases ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{prosodicPhrases} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{prosodicPhrases}) {
                                                                      $self->{prosodicPhrases} = $vals->{prosodicPhrases};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setProsodicPhrases_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size699 = 0;
                                                                          $self->{prosodicPhrases} = [];
                                                                          my $_etype702 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype702, \$_size699);
                                                                          for (my $_i703 = 0; $_i703 < $_size699; ++$_i703)
                                                                          {
                                                                            my $elem704 = undef;
                                                                            $elem704 = new thrift::adept::common::ProsodicPhrase();
                                                                            $xfer += $elem704->read($input);
                                                                            push(@{$self->{prosodicPhrases}},$elem704);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setProsodicPhrases_args');
                                                                  if (defined $self->{prosodicPhrases}) {
                                                                    $xfer += $output->writeFieldBegin('prosodicPhrases', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{prosodicPhrases}}));
                                                                      {
                                                                        foreach my $iter705 (@{$self->{prosodicPhrases}}) 
                                                                        {
                                                                          $xfer += ${iter705}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setProsodicPhrases_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setProsodicPhrases_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setProsodicPhrases_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setRelations_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setRelations_args->mk_accessors( qw( relations ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{relations} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{relations}) {
                                                                      $self->{relations} = $vals->{relations};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setRelations_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size706 = 0;
                                                                          $self->{relations} = [];
                                                                          my $_etype709 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype709, \$_size706);
                                                                          for (my $_i710 = 0; $_i710 < $_size706; ++$_i710)
                                                                          {
                                                                            my $elem711 = undef;
                                                                            $elem711 = new thrift::adept::common::Relation();
                                                                            $xfer += $elem711->read($input);
                                                                            push(@{$self->{relations}},$elem711);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setRelations_args');
                                                                  if (defined $self->{relations}) {
                                                                    $xfer += $output->writeFieldBegin('relations', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{relations}}));
                                                                      {
                                                                        foreach my $iter712 (@{$self->{relations}}) 
                                                                        {
                                                                          $xfer += ${iter712}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setRelations_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setRelations_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setRelations_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setSarcasms_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setSarcasms_args->mk_accessors( qw( sarcasms ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{sarcasms} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{sarcasms}) {
                                                                      $self->{sarcasms} = $vals->{sarcasms};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setSarcasms_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size713 = 0;
                                                                          $self->{sarcasms} = [];
                                                                          my $_etype716 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype716, \$_size713);
                                                                          for (my $_i717 = 0; $_i717 < $_size713; ++$_i717)
                                                                          {
                                                                            my $elem718 = undef;
                                                                            $elem718 = new thrift::adept::common::Sarcasm();
                                                                            $xfer += $elem718->read($input);
                                                                            push(@{$self->{sarcasms}},$elem718);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setSarcasms_args');
                                                                  if (defined $self->{sarcasms}) {
                                                                    $xfer += $output->writeFieldBegin('sarcasms', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sarcasms}}));
                                                                      {
                                                                        foreach my $iter719 (@{$self->{sarcasms}}) 
                                                                        {
                                                                          $xfer += ${iter719}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setSarcasms_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setSarcasms_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setSarcasms_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setSentences_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setSentences_args->mk_accessors( qw( sentences ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{sentences} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{sentences}) {
                                                                      $self->{sentences} = $vals->{sentences};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setSentences_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size720 = 0;
                                                                          $self->{sentences} = [];
                                                                          my $_etype723 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype723, \$_size720);
                                                                          for (my $_i724 = 0; $_i724 < $_size720; ++$_i724)
                                                                          {
                                                                            my $elem725 = undef;
                                                                            $elem725 = new thrift::adept::common::Sentence();
                                                                            $xfer += $elem725->read($input);
                                                                            push(@{$self->{sentences}},$elem725);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setSentences_args');
                                                                  if (defined $self->{sentences}) {
                                                                    $xfer += $output->writeFieldBegin('sentences', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sentences}}));
                                                                      {
                                                                        foreach my $iter726 (@{$self->{sentences}}) 
                                                                        {
                                                                          $xfer += ${iter726}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setSentences_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setSentences_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setSentences_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setSyntacticChunks_args;
use base qw(Class::Accessor);
thrift::adept::common::HltContentContainerService_setSyntacticChunks_args->mk_accessors( qw( syntactiChunks ) );

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  $self->{syntactiChunks} = undef;
                                                                  if (UNIVERSAL::isa($vals,'HASH')) {
                                                                    if (defined $vals->{syntactiChunks}) {
                                                                      $self->{syntactiChunks} = $vals->{syntactiChunks};
                                                                    }
                                                                  }
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setSyntacticChunks_args';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                      /^1$/ && do{                                                                      if ($ftype == TType::LIST) {
                                                                        {
                                                                          my $_size727 = 0;
                                                                          $self->{syntactiChunks} = [];
                                                                          my $_etype730 = 0;
                                                                          $xfer += $input->readListBegin(\$_etype730, \$_size727);
                                                                          for (my $_i731 = 0; $_i731 < $_size727; ++$_i731)
                                                                          {
                                                                            my $elem732 = undef;
                                                                            $elem732 = new thrift::adept::common::SyntacticChunk();
                                                                            $xfer += $elem732->read($input);
                                                                            push(@{$self->{syntactiChunks}},$elem732);
                                                                          }
                                                                          $xfer += $input->readListEnd();
                                                                        }
                                                                      } else {
                                                                        $xfer += $input->skip($ftype);
                                                                      }
                                                                      last; };
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setSyntacticChunks_args');
                                                                  if (defined $self->{syntactiChunks}) {
                                                                    $xfer += $output->writeFieldBegin('syntactiChunks', TType::LIST, 1);
                                                                    {
                                                                      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{syntactiChunks}}));
                                                                      {
                                                                        foreach my $iter733 (@{$self->{syntactiChunks}}) 
                                                                        {
                                                                          $xfer += ${iter733}->write($output);
                                                                        }
                                                                      }
                                                                      $xfer += $output->writeListEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldEnd();
                                                                  }
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerService_setSyntacticChunks_result;
use base qw(Class::Accessor);

sub new {
                                                                  my $classname = shift;
                                                                  my $self      = {};
                                                                  my $vals      = shift || {};
                                                                  return bless ($self, $classname);
}

sub getName {
                                                                  return 'HltContentContainerService_setSyntacticChunks_result';
                                                                }

sub read {
                                                                  my ($self, $input) = @_;
                                                                  my $xfer  = 0;
                                                                  my $fname;
                                                                  my $ftype = 0;
                                                                  my $fid   = 0;
                                                                  $xfer += $input->readStructBegin(\$fname);
                                                                  while (1) 
                                                                  {
                                                                    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                    if ($ftype == TType::STOP) {
                                                                      last;
                                                                    }
                                                                    SWITCH: for($fid)
                                                                    {
                                                                        $xfer += $input->skip($ftype);
                                                                    }
                                                                    $xfer += $input->readFieldEnd();
                                                                  }
                                                                  $xfer += $input->readStructEnd();
                                                                  return $xfer;
                                                                }

sub write {
                                                                  my ($self, $output) = @_;
                                                                  my $xfer   = 0;
                                                                  $xfer += $output->writeStructBegin('HltContentContainerService_setSyntacticChunks_result');
                                                                  $xfer += $output->writeFieldStop();
                                                                  $xfer += $output->writeStructEnd();
                                                                  return $xfer;
                                                                }

package thrift::adept::common::HltContentContainerServiceIf;

use strict;
use base qw(thrift::adept::common::ItemServiceIf);

sub getCommittedBeliefs{
  my $self = shift;

  die 'implement interface';
}

sub getCoreferences{
  my $self = shift;

  die 'implement interface';
}

sub getDependencies{
  my $self = shift;

  die 'implement interface';
}

sub getEntityMentions{
  my $self = shift;

  die 'implement interface';
}

sub getJointRelationCoreferences{
  my $self = shift;

  die 'implement interface';
}

sub getMentions{
  my $self = shift;

  die 'implement interface';
}

sub getNamedEntities{
  my $self = shift;

  die 'implement interface';
}

sub getOpinions{
  my $self = shift;

  die 'implement interface';
}

sub getPartOfSpeechs{
  my $self = shift;

  die 'implement interface';
}

sub getPassages{
  my $self = shift;

  die 'implement interface';
}

sub getProsodicPhrases{
  my $self = shift;

  die 'implement interface';
}

sub getRelations{
  my $self = shift;

  die 'implement interface';
}

sub getSarcasms{
  my $self = shift;

  die 'implement interface';
}

sub getSentences{
  my $self = shift;

  die 'implement interface';
}

sub getSyntacticChunks{
  my $self = shift;

  die 'implement interface';
}

sub setCommittedBeliefs{
  my $self = shift;
  my $committedBeliefs = shift;

  die 'implement interface';
}

sub setCoreferences{
  my $self = shift;
  my $coreferences = shift;

  die 'implement interface';
}

sub setDependencies{
  my $self = shift;
  my $dependencies = shift;

  die 'implement interface';
}

sub setEntityMentions{
  my $self = shift;
  my $entityMentions = shift;

  die 'implement interface';
}

sub setJointRelationCoreferences{
  my $self = shift;
  my $jointRelationCoreferences = shift;

  die 'implement interface';
}

sub setMentions{
  my $self = shift;
  my $entityMentions = shift;

  die 'implement interface';
}

sub setNamedEntities{
  my $self = shift;
  my $namedEntities = shift;

  die 'implement interface';
}

sub setOpinions{
  my $self = shift;
  my $opinions = shift;

  die 'implement interface';
}

sub setPartOfSpeechs{
  my $self = shift;
  my $partOfSpeechs = shift;

  die 'implement interface';
}

sub setPassages{
  my $self = shift;
  my $passages = shift;

  die 'implement interface';
}

sub setProsodicPhrases{
  my $self = shift;
  my $prosodicPhrases = shift;

  die 'implement interface';
}

sub setRelations{
  my $self = shift;
  my $relations = shift;

  die 'implement interface';
}

sub setSarcasms{
  my $self = shift;
  my $sarcasms = shift;

  die 'implement interface';
}

sub setSentences{
  my $self = shift;
  my $sentences = shift;

  die 'implement interface';
}

sub setSyntacticChunks{
  my $self = shift;
  my $syntactiChunks = shift;

  die 'implement interface';
}

package thrift::adept::common::HltContentContainerServiceRest;

use strict;
use base qw(thrift::adept::common::ItemServiceRest);

sub getCommittedBeliefs{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getCommittedBeliefs();
                                                                }

sub getCoreferences{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getCoreferences();
                                                                }

sub getDependencies{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getDependencies();
                                                                }

sub getEntityMentions{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getEntityMentions();
                                                                }

sub getJointRelationCoreferences{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getJointRelationCoreferences();
                                                                }

sub getMentions{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getMentions();
                                                                }

sub getNamedEntities{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getNamedEntities();
                                                                }

sub getOpinions{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getOpinions();
                                                                }

sub getPartOfSpeechs{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getPartOfSpeechs();
                                                                }

sub getPassages{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getPassages();
                                                                }

sub getProsodicPhrases{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getProsodicPhrases();
                                                                }

sub getRelations{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getRelations();
                                                                }

sub getSarcasms{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getSarcasms();
                                                                }

sub getSentences{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getSentences();
                                                                }

sub getSyntacticChunks{
                                                                  my ($self, $request) = @_;

                                                                  return $self->{impl}->getSyntacticChunks();
                                                                }

sub setCommittedBeliefs{
                                                                  my ($self, $request) = @_;

                                                                  my $committedBeliefs = ($request->{'committedBeliefs'}) ? $request->{'committedBeliefs'} : undef;
                                                                  return $self->{impl}->setCommittedBeliefs($committedBeliefs);
                                                                }

sub setCoreferences{
                                                                  my ($self, $request) = @_;

                                                                  my $coreferences = ($request->{'coreferences'}) ? $request->{'coreferences'} : undef;
                                                                  return $self->{impl}->setCoreferences($coreferences);
                                                                }

sub setDependencies{
                                                                  my ($self, $request) = @_;

                                                                  my $dependencies = ($request->{'dependencies'}) ? $request->{'dependencies'} : undef;
                                                                  return $self->{impl}->setDependencies($dependencies);
                                                                }

sub setEntityMentions{
                                                                  my ($self, $request) = @_;

                                                                  my $entityMentions = ($request->{'entityMentions'}) ? $request->{'entityMentions'} : undef;
                                                                  return $self->{impl}->setEntityMentions($entityMentions);
                                                                }

sub setJointRelationCoreferences{
                                                                  my ($self, $request) = @_;

                                                                  my $jointRelationCoreferences = ($request->{'jointRelationCoreferences'}) ? $request->{'jointRelationCoreferences'} : undef;
                                                                  return $self->{impl}->setJointRelationCoreferences($jointRelationCoreferences);
                                                                }

sub setMentions{
                                                                  my ($self, $request) = @_;

                                                                  my $entityMentions = ($request->{'entityMentions'}) ? $request->{'entityMentions'} : undef;
                                                                  return $self->{impl}->setMentions($entityMentions);
                                                                }

sub setNamedEntities{
                                                                  my ($self, $request) = @_;

                                                                  my $namedEntities = ($request->{'namedEntities'}) ? $request->{'namedEntities'} : undef;
                                                                  return $self->{impl}->setNamedEntities($namedEntities);
                                                                }

sub setOpinions{
                                                                  my ($self, $request) = @_;

                                                                  my $opinions = ($request->{'opinions'}) ? $request->{'opinions'} : undef;
                                                                  return $self->{impl}->setOpinions($opinions);
                                                                }

sub setPartOfSpeechs{
                                                                  my ($self, $request) = @_;

                                                                  my $partOfSpeechs = ($request->{'partOfSpeechs'}) ? $request->{'partOfSpeechs'} : undef;
                                                                  return $self->{impl}->setPartOfSpeechs($partOfSpeechs);
                                                                }

sub setPassages{
                                                                  my ($self, $request) = @_;

                                                                  my $passages = ($request->{'passages'}) ? $request->{'passages'} : undef;
                                                                  return $self->{impl}->setPassages($passages);
                                                                }

sub setProsodicPhrases{
                                                                  my ($self, $request) = @_;

                                                                  my $prosodicPhrases = ($request->{'prosodicPhrases'}) ? $request->{'prosodicPhrases'} : undef;
                                                                  return $self->{impl}->setProsodicPhrases($prosodicPhrases);
                                                                }

sub setRelations{
                                                                  my ($self, $request) = @_;

                                                                  my $relations = ($request->{'relations'}) ? $request->{'relations'} : undef;
                                                                  return $self->{impl}->setRelations($relations);
                                                                }

sub setSarcasms{
                                                                  my ($self, $request) = @_;

                                                                  my $sarcasms = ($request->{'sarcasms'}) ? $request->{'sarcasms'} : undef;
                                                                  return $self->{impl}->setSarcasms($sarcasms);
                                                                }

sub setSentences{
                                                                  my ($self, $request) = @_;

                                                                  my $sentences = ($request->{'sentences'}) ? $request->{'sentences'} : undef;
                                                                  return $self->{impl}->setSentences($sentences);
                                                                }

sub setSyntacticChunks{
                                                                  my ($self, $request) = @_;

                                                                  my $syntactiChunks = ($request->{'syntactiChunks'}) ? $request->{'syntactiChunks'} : undef;
                                                                  return $self->{impl}->setSyntacticChunks($syntactiChunks);
                                                                }

package thrift::adept::common::HltContentContainerServiceClient;

use base qw(thrift::adept::common::ItemServiceClient);
use base qw(thrift::adept::common::HltContentContainerServiceIf);
sub new {
                                                                  my ($classname, $input, $output) = @_;
                                                                  my $self      = {};
                                                                  $self = $classname->SUPER::new($input, $output);
                                                                  return bless($self,$classname);
}

sub getCommittedBeliefs{
  my $self = shift;

                                                                                                                                    $self->send_getCommittedBeliefs();
                                                                  return $self->recv_getCommittedBeliefs();
}

sub send_getCommittedBeliefs{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getCommittedBeliefs', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getCommittedBeliefs_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getCommittedBeliefs{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getCommittedBeliefs_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getCommittedBeliefs failed: unknown result";
}
sub getCoreferences{
  my $self = shift;

                                                                                                                                    $self->send_getCoreferences();
                                                                  return $self->recv_getCoreferences();
}

sub send_getCoreferences{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getCoreferences', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getCoreferences_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getCoreferences{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getCoreferences_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getCoreferences failed: unknown result";
}
sub getDependencies{
  my $self = shift;

                                                                                                                                    $self->send_getDependencies();
                                                                  return $self->recv_getDependencies();
}

sub send_getDependencies{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getDependencies', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getDependencies_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getDependencies{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getDependencies_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getDependencies failed: unknown result";
}
sub getEntityMentions{
  my $self = shift;

                                                                                                                                    $self->send_getEntityMentions();
                                                                  return $self->recv_getEntityMentions();
}

sub send_getEntityMentions{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getEntityMentions', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getEntityMentions_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getEntityMentions{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getEntityMentions_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getEntityMentions failed: unknown result";
}
sub getJointRelationCoreferences{
  my $self = shift;

                                                                                                                                    $self->send_getJointRelationCoreferences();
                                                                  return $self->recv_getJointRelationCoreferences();
}

sub send_getJointRelationCoreferences{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getJointRelationCoreferences', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getJointRelationCoreferences{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getJointRelationCoreferences failed: unknown result";
}
sub getMentions{
  my $self = shift;

                                                                                                                                    $self->send_getMentions();
                                                                  return $self->recv_getMentions();
}

sub send_getMentions{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getMentions', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getMentions_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getMentions{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getMentions_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getMentions failed: unknown result";
}
sub getNamedEntities{
  my $self = shift;

                                                                                                                                    $self->send_getNamedEntities();
                                                                  return $self->recv_getNamedEntities();
}

sub send_getNamedEntities{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getNamedEntities', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getNamedEntities_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getNamedEntities{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getNamedEntities_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getNamedEntities failed: unknown result";
}
sub getOpinions{
  my $self = shift;

                                                                                                                                    $self->send_getOpinions();
                                                                  return $self->recv_getOpinions();
}

sub send_getOpinions{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getOpinions', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getOpinions_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getOpinions{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getOpinions_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getOpinions failed: unknown result";
}
sub getPartOfSpeechs{
  my $self = shift;

                                                                                                                                    $self->send_getPartOfSpeechs();
                                                                  return $self->recv_getPartOfSpeechs();
}

sub send_getPartOfSpeechs{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getPartOfSpeechs', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getPartOfSpeechs_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getPartOfSpeechs{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getPartOfSpeechs_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getPartOfSpeechs failed: unknown result";
}
sub getPassages{
  my $self = shift;

                                                                                                                                    $self->send_getPassages();
                                                                  return $self->recv_getPassages();
}

sub send_getPassages{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getPassages', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getPassages_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getPassages{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getPassages_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getPassages failed: unknown result";
}
sub getProsodicPhrases{
  my $self = shift;

                                                                                                                                    $self->send_getProsodicPhrases();
                                                                  return $self->recv_getProsodicPhrases();
}

sub send_getProsodicPhrases{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getProsodicPhrases', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getProsodicPhrases_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getProsodicPhrases{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getProsodicPhrases_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getProsodicPhrases failed: unknown result";
}
sub getRelations{
  my $self = shift;

                                                                                                                                    $self->send_getRelations();
                                                                  return $self->recv_getRelations();
}

sub send_getRelations{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getRelations', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getRelations_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getRelations{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getRelations_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getRelations failed: unknown result";
}
sub getSarcasms{
  my $self = shift;

                                                                                                                                    $self->send_getSarcasms();
                                                                  return $self->recv_getSarcasms();
}

sub send_getSarcasms{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getSarcasms', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getSarcasms_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getSarcasms{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getSarcasms_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getSarcasms failed: unknown result";
}
sub getSentences{
  my $self = shift;

                                                                                                                                    $self->send_getSentences();
                                                                  return $self->recv_getSentences();
}

sub send_getSentences{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getSentences', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getSentences_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getSentences{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getSentences_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getSentences failed: unknown result";
}
sub getSyntacticChunks{
  my $self = shift;

                                                                                                                                    $self->send_getSyntacticChunks();
                                                                  return $self->recv_getSyntacticChunks();
}

sub send_getSyntacticChunks{
  my $self = shift;

                                                                  $self->{output}->writeMessageBegin('getSyntacticChunks', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_getSyntacticChunks_args();
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_getSyntacticChunks{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_getSyntacticChunks_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  if (defined $result->{success} ) {
                                                                    return $result->{success};
                                                                  }
                                                                  die "getSyntacticChunks failed: unknown result";
}
sub setCommittedBeliefs{
  my $self = shift;
  my $committedBeliefs = shift;

                                                                                                                                    $self->send_setCommittedBeliefs($committedBeliefs);
                                                                  $self->recv_setCommittedBeliefs();
}

sub send_setCommittedBeliefs{
  my $self = shift;
  my $committedBeliefs = shift;

                                                                  $self->{output}->writeMessageBegin('setCommittedBeliefs', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setCommittedBeliefs_args();
                                                                  $args->{committedBeliefs} = $committedBeliefs;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setCommittedBeliefs{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setCommittedBeliefs_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setCoreferences{
  my $self = shift;
  my $coreferences = shift;

                                                                                                                                    $self->send_setCoreferences($coreferences);
                                                                  $self->recv_setCoreferences();
}

sub send_setCoreferences{
  my $self = shift;
  my $coreferences = shift;

                                                                  $self->{output}->writeMessageBegin('setCoreferences', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setCoreferences_args();
                                                                  $args->{coreferences} = $coreferences;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setCoreferences{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setCoreferences_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setDependencies{
  my $self = shift;
  my $dependencies = shift;

                                                                                                                                    $self->send_setDependencies($dependencies);
                                                                  $self->recv_setDependencies();
}

sub send_setDependencies{
  my $self = shift;
  my $dependencies = shift;

                                                                  $self->{output}->writeMessageBegin('setDependencies', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setDependencies_args();
                                                                  $args->{dependencies} = $dependencies;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setDependencies{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setDependencies_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setEntityMentions{
  my $self = shift;
  my $entityMentions = shift;

                                                                                                                                    $self->send_setEntityMentions($entityMentions);
                                                                  $self->recv_setEntityMentions();
}

sub send_setEntityMentions{
  my $self = shift;
  my $entityMentions = shift;

                                                                  $self->{output}->writeMessageBegin('setEntityMentions', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setEntityMentions_args();
                                                                  $args->{entityMentions} = $entityMentions;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setEntityMentions{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setEntityMentions_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setJointRelationCoreferences{
  my $self = shift;
  my $jointRelationCoreferences = shift;

                                                                                                                                    $self->send_setJointRelationCoreferences($jointRelationCoreferences);
                                                                  $self->recv_setJointRelationCoreferences();
}

sub send_setJointRelationCoreferences{
  my $self = shift;
  my $jointRelationCoreferences = shift;

                                                                  $self->{output}->writeMessageBegin('setJointRelationCoreferences', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_args();
                                                                  $args->{jointRelationCoreferences} = $jointRelationCoreferences;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setJointRelationCoreferences{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setMentions{
  my $self = shift;
  my $entityMentions = shift;

                                                                                                                                    $self->send_setMentions($entityMentions);
                                                                  $self->recv_setMentions();
}

sub send_setMentions{
  my $self = shift;
  my $entityMentions = shift;

                                                                  $self->{output}->writeMessageBegin('setMentions', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setMentions_args();
                                                                  $args->{entityMentions} = $entityMentions;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setMentions{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setMentions_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setNamedEntities{
  my $self = shift;
  my $namedEntities = shift;

                                                                                                                                    $self->send_setNamedEntities($namedEntities);
                                                                  $self->recv_setNamedEntities();
}

sub send_setNamedEntities{
  my $self = shift;
  my $namedEntities = shift;

                                                                  $self->{output}->writeMessageBegin('setNamedEntities', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setNamedEntities_args();
                                                                  $args->{namedEntities} = $namedEntities;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setNamedEntities{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setNamedEntities_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setOpinions{
  my $self = shift;
  my $opinions = shift;

                                                                                                                                    $self->send_setOpinions($opinions);
                                                                  $self->recv_setOpinions();
}

sub send_setOpinions{
  my $self = shift;
  my $opinions = shift;

                                                                  $self->{output}->writeMessageBegin('setOpinions', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setOpinions_args();
                                                                  $args->{opinions} = $opinions;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setOpinions{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setOpinions_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setPartOfSpeechs{
  my $self = shift;
  my $partOfSpeechs = shift;

                                                                                                                                    $self->send_setPartOfSpeechs($partOfSpeechs);
                                                                  $self->recv_setPartOfSpeechs();
}

sub send_setPartOfSpeechs{
  my $self = shift;
  my $partOfSpeechs = shift;

                                                                  $self->{output}->writeMessageBegin('setPartOfSpeechs', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setPartOfSpeechs_args();
                                                                  $args->{partOfSpeechs} = $partOfSpeechs;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setPartOfSpeechs{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setPartOfSpeechs_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setPassages{
  my $self = shift;
  my $passages = shift;

                                                                                                                                    $self->send_setPassages($passages);
                                                                  $self->recv_setPassages();
}

sub send_setPassages{
  my $self = shift;
  my $passages = shift;

                                                                  $self->{output}->writeMessageBegin('setPassages', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setPassages_args();
                                                                  $args->{passages} = $passages;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setPassages{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setPassages_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setProsodicPhrases{
  my $self = shift;
  my $prosodicPhrases = shift;

                                                                                                                                    $self->send_setProsodicPhrases($prosodicPhrases);
                                                                  $self->recv_setProsodicPhrases();
}

sub send_setProsodicPhrases{
  my $self = shift;
  my $prosodicPhrases = shift;

                                                                  $self->{output}->writeMessageBegin('setProsodicPhrases', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setProsodicPhrases_args();
                                                                  $args->{prosodicPhrases} = $prosodicPhrases;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setProsodicPhrases{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setProsodicPhrases_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setRelations{
  my $self = shift;
  my $relations = shift;

                                                                                                                                    $self->send_setRelations($relations);
                                                                  $self->recv_setRelations();
}

sub send_setRelations{
  my $self = shift;
  my $relations = shift;

                                                                  $self->{output}->writeMessageBegin('setRelations', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setRelations_args();
                                                                  $args->{relations} = $relations;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setRelations{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setRelations_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setSarcasms{
  my $self = shift;
  my $sarcasms = shift;

                                                                                                                                    $self->send_setSarcasms($sarcasms);
                                                                  $self->recv_setSarcasms();
}

sub send_setSarcasms{
  my $self = shift;
  my $sarcasms = shift;

                                                                  $self->{output}->writeMessageBegin('setSarcasms', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setSarcasms_args();
                                                                  $args->{sarcasms} = $sarcasms;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setSarcasms{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setSarcasms_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setSentences{
  my $self = shift;
  my $sentences = shift;

                                                                                                                                    $self->send_setSentences($sentences);
                                                                  $self->recv_setSentences();
}

sub send_setSentences{
  my $self = shift;
  my $sentences = shift;

                                                                  $self->{output}->writeMessageBegin('setSentences', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setSentences_args();
                                                                  $args->{sentences} = $sentences;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setSentences{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setSentences_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
sub setSyntacticChunks{
  my $self = shift;
  my $syntactiChunks = shift;

                                                                                                                                    $self->send_setSyntacticChunks($syntactiChunks);
                                                                  $self->recv_setSyntacticChunks();
}

sub send_setSyntacticChunks{
  my $self = shift;
  my $syntactiChunks = shift;

                                                                  $self->{output}->writeMessageBegin('setSyntacticChunks', TMessageType::CALL, $self->{seqid});
                                                                  my $args = new thrift::adept::common::HltContentContainerService_setSyntacticChunks_args();
                                                                  $args->{syntactiChunks} = $syntactiChunks;
                                                                  $args->write($self->{output});
                                                                  $self->{output}->writeMessageEnd();
                                                                  $self->{output}->getTransport()->flush();
}

sub recv_setSyntacticChunks{
  my $self = shift;

                                                                  my $rseqid = 0;
                                                                  my $fname;
                                                                  my $mtype = 0;

                                                                  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                  if ($mtype == TMessageType::EXCEPTION) {
                                                                    my $x = new TApplicationException();
                                                                    $x->read($self->{input});
                                                                    $self->{input}->readMessageEnd();
                                                                    die $x;
                                                                  }
                                                                  my $result = new thrift::adept::common::HltContentContainerService_setSyntacticChunks_result();
                                                                  $result->read($self->{input});
                                                                  $self->{input}->readMessageEnd();

                                                                  return;
}
package thrift::adept::common::HltContentContainerServiceProcessor;

use strict;
use base qw(thrift::adept::common::ItemServiceProcessor);

sub process {
                                                                    my ($self, $input, $output) = @_;
                                                                    my $rseqid = 0;
                                                                    my $fname  = undef;
                                                                    my $mtype  = 0;

                                                                    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    my $methodname = 'process_'.$fname;
                                                                    if (!$self->can($methodname)) {
                                                                      $input->skip(TType::STRUCT);
                                                                      $input->readMessageEnd();
                                                                      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                                                                      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                                                                      $x->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
                                                                      return;
                                                                    }
                                                                    $self->$methodname($rseqid, $input, $output);
                                                                    return 1;
}

sub process_getCommittedBeliefs {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getCommittedBeliefs_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getCommittedBeliefs_result();
                                                                    $result->{success} = $self->{handler}->getCommittedBeliefs();
                                                                    $output->writeMessageBegin('getCommittedBeliefs', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getCoreferences {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getCoreferences_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getCoreferences_result();
                                                                    $result->{success} = $self->{handler}->getCoreferences();
                                                                    $output->writeMessageBegin('getCoreferences', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getDependencies {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getDependencies_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getDependencies_result();
                                                                    $result->{success} = $self->{handler}->getDependencies();
                                                                    $output->writeMessageBegin('getDependencies', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getEntityMentions {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getEntityMentions_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getEntityMentions_result();
                                                                    $result->{success} = $self->{handler}->getEntityMentions();
                                                                    $output->writeMessageBegin('getEntityMentions', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getJointRelationCoreferences {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getJointRelationCoreferences_result();
                                                                    $result->{success} = $self->{handler}->getJointRelationCoreferences();
                                                                    $output->writeMessageBegin('getJointRelationCoreferences', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getMentions {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getMentions_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getMentions_result();
                                                                    $result->{success} = $self->{handler}->getMentions();
                                                                    $output->writeMessageBegin('getMentions', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getNamedEntities {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getNamedEntities_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getNamedEntities_result();
                                                                    $result->{success} = $self->{handler}->getNamedEntities();
                                                                    $output->writeMessageBegin('getNamedEntities', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getOpinions {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getOpinions_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getOpinions_result();
                                                                    $result->{success} = $self->{handler}->getOpinions();
                                                                    $output->writeMessageBegin('getOpinions', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getPartOfSpeechs {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getPartOfSpeechs_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getPartOfSpeechs_result();
                                                                    $result->{success} = $self->{handler}->getPartOfSpeechs();
                                                                    $output->writeMessageBegin('getPartOfSpeechs', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getPassages {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getPassages_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getPassages_result();
                                                                    $result->{success} = $self->{handler}->getPassages();
                                                                    $output->writeMessageBegin('getPassages', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getProsodicPhrases {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getProsodicPhrases_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getProsodicPhrases_result();
                                                                    $result->{success} = $self->{handler}->getProsodicPhrases();
                                                                    $output->writeMessageBegin('getProsodicPhrases', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getRelations {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getRelations_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getRelations_result();
                                                                    $result->{success} = $self->{handler}->getRelations();
                                                                    $output->writeMessageBegin('getRelations', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getSarcasms {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getSarcasms_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getSarcasms_result();
                                                                    $result->{success} = $self->{handler}->getSarcasms();
                                                                    $output->writeMessageBegin('getSarcasms', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getSentences {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getSentences_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getSentences_result();
                                                                    $result->{success} = $self->{handler}->getSentences();
                                                                    $output->writeMessageBegin('getSentences', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_getSyntacticChunks {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_getSyntacticChunks_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_getSyntacticChunks_result();
                                                                    $result->{success} = $self->{handler}->getSyntacticChunks();
                                                                    $output->writeMessageBegin('getSyntacticChunks', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setCommittedBeliefs {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setCommittedBeliefs_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setCommittedBeliefs_result();
                                                                    $self->{handler}->setCommittedBeliefs($args->committedBeliefs);
                                                                    $output->writeMessageBegin('setCommittedBeliefs', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setCoreferences {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setCoreferences_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setCoreferences_result();
                                                                    $self->{handler}->setCoreferences($args->coreferences);
                                                                    $output->writeMessageBegin('setCoreferences', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setDependencies {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setDependencies_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setDependencies_result();
                                                                    $self->{handler}->setDependencies($args->dependencies);
                                                                    $output->writeMessageBegin('setDependencies', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setEntityMentions {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setEntityMentions_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setEntityMentions_result();
                                                                    $self->{handler}->setEntityMentions($args->entityMentions);
                                                                    $output->writeMessageBegin('setEntityMentions', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setJointRelationCoreferences {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setJointRelationCoreferences_result();
                                                                    $self->{handler}->setJointRelationCoreferences($args->jointRelationCoreferences);
                                                                    $output->writeMessageBegin('setJointRelationCoreferences', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setMentions {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setMentions_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setMentions_result();
                                                                    $self->{handler}->setMentions($args->entityMentions);
                                                                    $output->writeMessageBegin('setMentions', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setNamedEntities {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setNamedEntities_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setNamedEntities_result();
                                                                    $self->{handler}->setNamedEntities($args->namedEntities);
                                                                    $output->writeMessageBegin('setNamedEntities', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setOpinions {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setOpinions_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setOpinions_result();
                                                                    $self->{handler}->setOpinions($args->opinions);
                                                                    $output->writeMessageBegin('setOpinions', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setPartOfSpeechs {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setPartOfSpeechs_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setPartOfSpeechs_result();
                                                                    $self->{handler}->setPartOfSpeechs($args->partOfSpeechs);
                                                                    $output->writeMessageBegin('setPartOfSpeechs', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setPassages {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setPassages_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setPassages_result();
                                                                    $self->{handler}->setPassages($args->passages);
                                                                    $output->writeMessageBegin('setPassages', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setProsodicPhrases {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setProsodicPhrases_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setProsodicPhrases_result();
                                                                    $self->{handler}->setProsodicPhrases($args->prosodicPhrases);
                                                                    $output->writeMessageBegin('setProsodicPhrases', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setRelations {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setRelations_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setRelations_result();
                                                                    $self->{handler}->setRelations($args->relations);
                                                                    $output->writeMessageBegin('setRelations', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setSarcasms {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setSarcasms_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setSarcasms_result();
                                                                    $self->{handler}->setSarcasms($args->sarcasms);
                                                                    $output->writeMessageBegin('setSarcasms', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setSentences {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setSentences_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setSentences_result();
                                                                    $self->{handler}->setSentences($args->sentences);
                                                                    $output->writeMessageBegin('setSentences', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

sub process_setSyntacticChunks {
                                                                    my ($self, $seqid, $input, $output) = @_;
                                                                    my $args = new thrift::adept::common::HltContentContainerService_setSyntacticChunks_args();
                                                                    $args->read($input);
                                                                    $input->readMessageEnd();
                                                                    my $result = new thrift::adept::common::HltContentContainerService_setSyntacticChunks_result();
                                                                    $self->{handler}->setSyntacticChunks($args->syntactiChunks);
                                                                    $output->writeMessageBegin('setSyntacticChunks', TMessageType::REPLY, $seqid);
                                                                    $result->write($output);
                                                                    $output->writeMessageEnd();
                                                                    $output->getTransport()->flush();
}

1;