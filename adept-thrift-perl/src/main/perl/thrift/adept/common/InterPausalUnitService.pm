#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;
use thrift::adept::common::ItemService;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::InterPausalUnitService_getAcousticFeatures_args;
use base qw(Class::Accessor);

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_getAcousticFeatures_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_getAcousticFeatures_args');
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_getAcousticFeatures_result;
use base qw(Class::Accessor);
thrift::adept::common::InterPausalUnitService_getAcousticFeatures_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_getAcousticFeatures_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == TType::MAP) {
                                    {
                                      my $_size411 = 0;
                                      $self->{success} = {};
                                      my $_ktype412 = 0;
                                      my $_vtype413 = 0;
                                      $xfer += $input->readMapBegin(\$_ktype412, \$_vtype413, \$_size411);
                                      for (my $_i415 = 0; $_i415 < $_size411; ++$_i415)
                                      {
                                        my $key416 = '';
                                        my $val417 = 0.0;
                                        $xfer += $input->readString(\$key416);
                                        $xfer += $input->readDouble(\$val417);
                                        $self->{success}->{$key416} = $val417;
                                      }
                                      $xfer += $input->readMapEnd();
                                    }
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_getAcousticFeatures_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
                                {
                                  $xfer += $output->writeMapBegin(TType::STRING, TType::DOUBLE, scalar(keys %{$self->{success}}));
                                  {
                                    while( my ($kiter418,$viter419) = each %{$self->{success}}) 
                                    {
                                      $xfer += $output->writeString($kiter418);
                                      $xfer += $output->writeDouble($viter419);
                                    }
                                  }
                                  $xfer += $output->writeMapEnd();
                                }
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_args;
use base qw(Class::Accessor);

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_getIpuAudioOffset_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_getIpuAudioOffset_args');
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_result;
use base qw(Class::Accessor);
thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_getIpuAudioOffset_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == TType::STRUCT) {
                                    $self->{success} = new thrift::adept::common::AudioOffset();
                                    $xfer += $self->{success}->read($input);
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_getIpuAudioOffset_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                $xfer += $self->{success}->write($output);
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_getSequenceId_args;
use base qw(Class::Accessor);

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_getSequenceId_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_getSequenceId_args');
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_getSequenceId_result;
use base qw(Class::Accessor);
thrift::adept::common::InterPausalUnitService_getSequenceId_result->mk_accessors( qw( success ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{success} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{success}) {
                                  $self->{success} = $vals->{success};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_getSequenceId_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^0$/ && do{                                  if ($ftype == TType::I64) {
                                    $xfer += $input->readI64(\$self->{success});
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_getSequenceId_result');
                              if (defined $self->{success}) {
                                $xfer += $output->writeFieldBegin('success', TType::I64, 0);
                                $xfer += $output->writeI64($self->{success});
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_setAcousticFeatures_args;
use base qw(Class::Accessor);
thrift::adept::common::InterPausalUnitService_setAcousticFeatures_args->mk_accessors( qw( acousticFeatures ) );

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              $self->{acousticFeatures} = undef;
                              if (UNIVERSAL::isa($vals,'HASH')) {
                                if (defined $vals->{acousticFeatures}) {
                                  $self->{acousticFeatures} = $vals->{acousticFeatures};
                                }
                              }
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_setAcousticFeatures_args';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                  /^1$/ && do{                                  if ($ftype == TType::MAP) {
                                    {
                                      my $_size420 = 0;
                                      $self->{acousticFeatures} = {};
                                      my $_ktype421 = 0;
                                      my $_vtype422 = 0;
                                      $xfer += $input->readMapBegin(\$_ktype421, \$_vtype422, \$_size420);
                                      for (my $_i424 = 0; $_i424 < $_size420; ++$_i424)
                                      {
                                        my $key425 = '';
                                        my $val426 = 0.0;
                                        $xfer += $input->readString(\$key425);
                                        $xfer += $input->readDouble(\$val426);
                                        $self->{acousticFeatures}->{$key425} = $val426;
                                      }
                                      $xfer += $input->readMapEnd();
                                    }
                                  } else {
                                    $xfer += $input->skip($ftype);
                                  }
                                  last; };
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_setAcousticFeatures_args');
                              if (defined $self->{acousticFeatures}) {
                                $xfer += $output->writeFieldBegin('acousticFeatures', TType::MAP, 1);
                                {
                                  $xfer += $output->writeMapBegin(TType::STRING, TType::DOUBLE, scalar(keys %{$self->{acousticFeatures}}));
                                  {
                                    while( my ($kiter427,$viter428) = each %{$self->{acousticFeatures}}) 
                                    {
                                      $xfer += $output->writeString($kiter427);
                                      $xfer += $output->writeDouble($viter428);
                                    }
                                  }
                                  $xfer += $output->writeMapEnd();
                                }
                                $xfer += $output->writeFieldEnd();
                              }
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitService_setAcousticFeatures_result;
use base qw(Class::Accessor);

sub new {
                              my $classname = shift;
                              my $self      = {};
                              my $vals      = shift || {};
                              return bless ($self, $classname);
}

sub getName {
                              return 'InterPausalUnitService_setAcousticFeatures_result';
                            }

sub read {
                              my ($self, $input) = @_;
                              my $xfer  = 0;
                              my $fname;
                              my $ftype = 0;
                              my $fid   = 0;
                              $xfer += $input->readStructBegin(\$fname);
                              while (1) 
                              {
                                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                if ($ftype == TType::STOP) {
                                  last;
                                }
                                SWITCH: for($fid)
                                {
                                    $xfer += $input->skip($ftype);
                                }
                                $xfer += $input->readFieldEnd();
                              }
                              $xfer += $input->readStructEnd();
                              return $xfer;
                            }

sub write {
                              my ($self, $output) = @_;
                              my $xfer   = 0;
                              $xfer += $output->writeStructBegin('InterPausalUnitService_setAcousticFeatures_result');
                              $xfer += $output->writeFieldStop();
                              $xfer += $output->writeStructEnd();
                              return $xfer;
                            }

package thrift::adept::common::InterPausalUnitServiceIf;

use strict;
use base qw(thrift::adept::common::ItemServiceIf);

sub getAcousticFeatures{
  my $self = shift;

  die 'implement interface';
}

sub getIpuAudioOffset{
  my $self = shift;

  die 'implement interface';
}

sub getSequenceId{
  my $self = shift;

  die 'implement interface';
}

sub setAcousticFeatures{
  my $self = shift;
  my $acousticFeatures = shift;

  die 'implement interface';
}

package thrift::adept::common::InterPausalUnitServiceRest;

use strict;
use base qw(thrift::adept::common::ItemServiceRest);

sub getAcousticFeatures{
                              my ($self, $request) = @_;

                              return $self->{impl}->getAcousticFeatures();
                            }

sub getIpuAudioOffset{
                              my ($self, $request) = @_;

                              return $self->{impl}->getIpuAudioOffset();
                            }

sub getSequenceId{
                              my ($self, $request) = @_;

                              return $self->{impl}->getSequenceId();
                            }

sub setAcousticFeatures{
                              my ($self, $request) = @_;

                              my $acousticFeatures = ($request->{'acousticFeatures'}) ? $request->{'acousticFeatures'} : undef;
                              return $self->{impl}->setAcousticFeatures($acousticFeatures);
                            }

package thrift::adept::common::InterPausalUnitServiceClient;

use base qw(thrift::adept::common::ItemServiceClient);
use base qw(thrift::adept::common::InterPausalUnitServiceIf);
sub new {
                              my ($classname, $input, $output) = @_;
                              my $self      = {};
                              $self = $classname->SUPER::new($input, $output);
                              return bless($self,$classname);
}

sub getAcousticFeatures{
  my $self = shift;

                                                            $self->send_getAcousticFeatures();
                              return $self->recv_getAcousticFeatures();
}

sub send_getAcousticFeatures{
  my $self = shift;

                              $self->{output}->writeMessageBegin('getAcousticFeatures', TMessageType::CALL, $self->{seqid});
                              my $args = new thrift::adept::common::InterPausalUnitService_getAcousticFeatures_args();
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_getAcousticFeatures{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == TMessageType::EXCEPTION) {
                                my $x = new TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new thrift::adept::common::InterPausalUnitService_getAcousticFeatures_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              die "getAcousticFeatures failed: unknown result";
}
sub getIpuAudioOffset{
  my $self = shift;

                                                            $self->send_getIpuAudioOffset();
                              return $self->recv_getIpuAudioOffset();
}

sub send_getIpuAudioOffset{
  my $self = shift;

                              $self->{output}->writeMessageBegin('getIpuAudioOffset', TMessageType::CALL, $self->{seqid});
                              my $args = new thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_args();
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_getIpuAudioOffset{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == TMessageType::EXCEPTION) {
                                my $x = new TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              die "getIpuAudioOffset failed: unknown result";
}
sub getSequenceId{
  my $self = shift;

                                                            $self->send_getSequenceId();
                              return $self->recv_getSequenceId();
}

sub send_getSequenceId{
  my $self = shift;

                              $self->{output}->writeMessageBegin('getSequenceId', TMessageType::CALL, $self->{seqid});
                              my $args = new thrift::adept::common::InterPausalUnitService_getSequenceId_args();
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_getSequenceId{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == TMessageType::EXCEPTION) {
                                my $x = new TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new thrift::adept::common::InterPausalUnitService_getSequenceId_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              if (defined $result->{success} ) {
                                return $result->{success};
                              }
                              die "getSequenceId failed: unknown result";
}
sub setAcousticFeatures{
  my $self = shift;
  my $acousticFeatures = shift;

                                                            $self->send_setAcousticFeatures($acousticFeatures);
                              $self->recv_setAcousticFeatures();
}

sub send_setAcousticFeatures{
  my $self = shift;
  my $acousticFeatures = shift;

                              $self->{output}->writeMessageBegin('setAcousticFeatures', TMessageType::CALL, $self->{seqid});
                              my $args = new thrift::adept::common::InterPausalUnitService_setAcousticFeatures_args();
                              $args->{acousticFeatures} = $acousticFeatures;
                              $args->write($self->{output});
                              $self->{output}->writeMessageEnd();
                              $self->{output}->getTransport()->flush();
}

sub recv_setAcousticFeatures{
  my $self = shift;

                              my $rseqid = 0;
                              my $fname;
                              my $mtype = 0;

                              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                              if ($mtype == TMessageType::EXCEPTION) {
                                my $x = new TApplicationException();
                                $x->read($self->{input});
                                $self->{input}->readMessageEnd();
                                die $x;
                              }
                              my $result = new thrift::adept::common::InterPausalUnitService_setAcousticFeatures_result();
                              $result->read($self->{input});
                              $self->{input}->readMessageEnd();

                              return;
}
package thrift::adept::common::InterPausalUnitServiceProcessor;

use strict;
use base qw(thrift::adept::common::ItemServiceProcessor);

sub process {
                                my ($self, $input, $output) = @_;
                                my $rseqid = 0;
                                my $fname  = undef;
                                my $mtype  = 0;

                                $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                my $methodname = 'process_'.$fname;
                                if (!$self->can($methodname)) {
                                  $input->skip(TType::STRUCT);
                                  $input->readMessageEnd();
                                  my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                                  $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                                  $x->write($output);
                                  $output->writeMessageEnd();
                                  $output->getTransport()->flush();
                                  return;
                                }
                                $self->$methodname($rseqid, $input, $output);
                                return 1;
}

sub process_getAcousticFeatures {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new thrift::adept::common::InterPausalUnitService_getAcousticFeatures_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new thrift::adept::common::InterPausalUnitService_getAcousticFeatures_result();
                                $result->{success} = $self->{handler}->getAcousticFeatures();
                                $output->writeMessageBegin('getAcousticFeatures', TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_getIpuAudioOffset {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new thrift::adept::common::InterPausalUnitService_getIpuAudioOffset_result();
                                $result->{success} = $self->{handler}->getIpuAudioOffset();
                                $output->writeMessageBegin('getIpuAudioOffset', TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_getSequenceId {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new thrift::adept::common::InterPausalUnitService_getSequenceId_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new thrift::adept::common::InterPausalUnitService_getSequenceId_result();
                                $result->{success} = $self->{handler}->getSequenceId();
                                $output->writeMessageBegin('getSequenceId', TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

sub process_setAcousticFeatures {
                                my ($self, $seqid, $input, $output) = @_;
                                my $args = new thrift::adept::common::InterPausalUnitService_setAcousticFeatures_args();
                                $args->read($input);
                                $input->readMessageEnd();
                                my $result = new thrift::adept::common::InterPausalUnitService_setAcousticFeatures_result();
                                $self->{handler}->setAcousticFeatures($args->acousticFeatures);
                                $output->writeMessageBegin('setAcousticFeatures', TMessageType::REPLY, $seqid);
                                $result->write($output);
                                $output->writeMessageEnd();
                                $output->getTransport()->flush();
}

1;