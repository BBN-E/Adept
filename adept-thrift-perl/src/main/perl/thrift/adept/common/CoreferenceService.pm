#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;
use thrift::adept::common::ItemService;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::CoreferenceService_getCoreferenceId_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_getCoreferenceId_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_getCoreferenceId_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_getCoreferenceId_result;
use base qw(Class::Accessor);
thrift::adept::common::CoreferenceService_getCoreferenceId_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_getCoreferenceId_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == TType::I64) {
                              $xfer += $input->readI64(\$self->{success});
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_getCoreferenceId_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', TType::I64, 0);
                          $xfer += $output->writeI64($self->{success});
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_getEntities_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_getEntities_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_getEntities_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_getEntities_result;
use base qw(Class::Accessor);
thrift::adept::common::CoreferenceService_getEntities_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_getEntities_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == TType::LIST) {
                              {
                                my $_size383 = 0;
                                $self->{success} = [];
                                my $_etype386 = 0;
                                $xfer += $input->readListBegin(\$_etype386, \$_size383);
                                for (my $_i387 = 0; $_i387 < $_size383; ++$_i387)
                                {
                                  my $elem388 = undef;
                                  $elem388 = new thrift::adept::common::Entity();
                                  $xfer += $elem388->read($input);
                                  push(@{$self->{success}},$elem388);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_getEntities_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter389 (@{$self->{success}}) 
                              {
                                $xfer += ${iter389}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_getResolvedMentions_args;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_getResolvedMentions_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_getResolvedMentions_args');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_getResolvedMentions_result;
use base qw(Class::Accessor);
thrift::adept::common::CoreferenceService_getResolvedMentions_result->mk_accessors( qw( success ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{success} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{success}) {
                            $self->{success} = $vals->{success};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_getResolvedMentions_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^0$/ && do{                            if ($ftype == TType::LIST) {
                              {
                                my $_size390 = 0;
                                $self->{success} = [];
                                my $_etype393 = 0;
                                $xfer += $input->readListBegin(\$_etype393, \$_size390);
                                for (my $_i394 = 0; $_i394 < $_size390; ++$_i394)
                                {
                                  my $elem395 = undef;
                                  $elem395 = new thrift::adept::common::EntityMention();
                                  $xfer += $elem395->read($input);
                                  push(@{$self->{success}},$elem395);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_getResolvedMentions_result');
                        if (defined $self->{success}) {
                          $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
                          {
                            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
                            {
                              foreach my $iter396 (@{$self->{success}}) 
                              {
                                $xfer += ${iter396}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_setEntities_args;
use base qw(Class::Accessor);
thrift::adept::common::CoreferenceService_setEntities_args->mk_accessors( qw( entities ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{entities} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{entities}) {
                            $self->{entities} = $vals->{entities};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_setEntities_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == TType::LIST) {
                              {
                                my $_size397 = 0;
                                $self->{entities} = [];
                                my $_etype400 = 0;
                                $xfer += $input->readListBegin(\$_etype400, \$_size397);
                                for (my $_i401 = 0; $_i401 < $_size397; ++$_i401)
                                {
                                  my $elem402 = undef;
                                  $elem402 = new thrift::adept::common::Entity();
                                  $xfer += $elem402->read($input);
                                  push(@{$self->{entities}},$elem402);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_setEntities_args');
                        if (defined $self->{entities}) {
                          $xfer += $output->writeFieldBegin('entities', TType::LIST, 1);
                          {
                            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{entities}}));
                            {
                              foreach my $iter403 (@{$self->{entities}}) 
                              {
                                $xfer += ${iter403}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_setEntities_result;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_setEntities_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_setEntities_result');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_setResolvedMentions_args;
use base qw(Class::Accessor);
thrift::adept::common::CoreferenceService_setResolvedMentions_args->mk_accessors( qw( resolvedEntityMentions ) );

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        $self->{resolvedEntityMentions} = undef;
                        if (UNIVERSAL::isa($vals,'HASH')) {
                          if (defined $vals->{resolvedEntityMentions}) {
                            $self->{resolvedEntityMentions} = $vals->{resolvedEntityMentions};
                          }
                        }
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_setResolvedMentions_args';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                            /^1$/ && do{                            if ($ftype == TType::LIST) {
                              {
                                my $_size404 = 0;
                                $self->{resolvedEntityMentions} = [];
                                my $_etype407 = 0;
                                $xfer += $input->readListBegin(\$_etype407, \$_size404);
                                for (my $_i408 = 0; $_i408 < $_size404; ++$_i408)
                                {
                                  my $elem409 = undef;
                                  $elem409 = new thrift::adept::common::EntityMention();
                                  $xfer += $elem409->read($input);
                                  push(@{$self->{resolvedEntityMentions}},$elem409);
                                }
                                $xfer += $input->readListEnd();
                              }
                            } else {
                              $xfer += $input->skip($ftype);
                            }
                            last; };
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_setResolvedMentions_args');
                        if (defined $self->{resolvedEntityMentions}) {
                          $xfer += $output->writeFieldBegin('resolvedEntityMentions', TType::LIST, 1);
                          {
                            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{resolvedEntityMentions}}));
                            {
                              foreach my $iter410 (@{$self->{resolvedEntityMentions}}) 
                              {
                                $xfer += ${iter410}->write($output);
                              }
                            }
                            $xfer += $output->writeListEnd();
                          }
                          $xfer += $output->writeFieldEnd();
                        }
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceService_setResolvedMentions_result;
use base qw(Class::Accessor);

sub new {
                        my $classname = shift;
                        my $self      = {};
                        my $vals      = shift || {};
                        return bless ($self, $classname);
}

sub getName {
                        return 'CoreferenceService_setResolvedMentions_result';
                      }

sub read {
                        my ($self, $input) = @_;
                        my $xfer  = 0;
                        my $fname;
                        my $ftype = 0;
                        my $fid   = 0;
                        $xfer += $input->readStructBegin(\$fname);
                        while (1) 
                        {
                          $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                          if ($ftype == TType::STOP) {
                            last;
                          }
                          SWITCH: for($fid)
                          {
                              $xfer += $input->skip($ftype);
                          }
                          $xfer += $input->readFieldEnd();
                        }
                        $xfer += $input->readStructEnd();
                        return $xfer;
                      }

sub write {
                        my ($self, $output) = @_;
                        my $xfer   = 0;
                        $xfer += $output->writeStructBegin('CoreferenceService_setResolvedMentions_result');
                        $xfer += $output->writeFieldStop();
                        $xfer += $output->writeStructEnd();
                        return $xfer;
                      }

package thrift::adept::common::CoreferenceServiceIf;

use strict;
use base qw(thrift::adept::common::ItemServiceIf);

sub getCoreferenceId{
  my $self = shift;

  die 'implement interface';
}

sub getEntities{
  my $self = shift;

  die 'implement interface';
}

sub getResolvedMentions{
  my $self = shift;

  die 'implement interface';
}

sub setEntities{
  my $self = shift;
  my $entities = shift;

  die 'implement interface';
}

sub setResolvedMentions{
  my $self = shift;
  my $resolvedEntityMentions = shift;

  die 'implement interface';
}

package thrift::adept::common::CoreferenceServiceRest;

use strict;
use base qw(thrift::adept::common::ItemServiceRest);

sub getCoreferenceId{
                        my ($self, $request) = @_;

                        return $self->{impl}->getCoreferenceId();
                      }

sub getEntities{
                        my ($self, $request) = @_;

                        return $self->{impl}->getEntities();
                      }

sub getResolvedMentions{
                        my ($self, $request) = @_;

                        return $self->{impl}->getResolvedMentions();
                      }

sub setEntities{
                        my ($self, $request) = @_;

                        my $entities = ($request->{'entities'}) ? $request->{'entities'} : undef;
                        return $self->{impl}->setEntities($entities);
                      }

sub setResolvedMentions{
                        my ($self, $request) = @_;

                        my $resolvedEntityMentions = ($request->{'resolvedEntityMentions'}) ? $request->{'resolvedEntityMentions'} : undef;
                        return $self->{impl}->setResolvedMentions($resolvedEntityMentions);
                      }

package thrift::adept::common::CoreferenceServiceClient;

use base qw(thrift::adept::common::ItemServiceClient);
use base qw(thrift::adept::common::CoreferenceServiceIf);
sub new {
                        my ($classname, $input, $output) = @_;
                        my $self      = {};
                        $self = $classname->SUPER::new($input, $output);
                        return bless($self,$classname);
}

sub getCoreferenceId{
  my $self = shift;

                                                $self->send_getCoreferenceId();
                        return $self->recv_getCoreferenceId();
}

sub send_getCoreferenceId{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getCoreferenceId', TMessageType::CALL, $self->{seqid});
                        my $args = new thrift::adept::common::CoreferenceService_getCoreferenceId_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getCoreferenceId{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == TMessageType::EXCEPTION) {
                          my $x = new TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new thrift::adept::common::CoreferenceService_getCoreferenceId_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        die "getCoreferenceId failed: unknown result";
}
sub getEntities{
  my $self = shift;

                                                $self->send_getEntities();
                        return $self->recv_getEntities();
}

sub send_getEntities{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getEntities', TMessageType::CALL, $self->{seqid});
                        my $args = new thrift::adept::common::CoreferenceService_getEntities_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getEntities{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == TMessageType::EXCEPTION) {
                          my $x = new TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new thrift::adept::common::CoreferenceService_getEntities_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        die "getEntities failed: unknown result";
}
sub getResolvedMentions{
  my $self = shift;

                                                $self->send_getResolvedMentions();
                        return $self->recv_getResolvedMentions();
}

sub send_getResolvedMentions{
  my $self = shift;

                        $self->{output}->writeMessageBegin('getResolvedMentions', TMessageType::CALL, $self->{seqid});
                        my $args = new thrift::adept::common::CoreferenceService_getResolvedMentions_args();
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_getResolvedMentions{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == TMessageType::EXCEPTION) {
                          my $x = new TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new thrift::adept::common::CoreferenceService_getResolvedMentions_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        if (defined $result->{success} ) {
                          return $result->{success};
                        }
                        die "getResolvedMentions failed: unknown result";
}
sub setEntities{
  my $self = shift;
  my $entities = shift;

                                                $self->send_setEntities($entities);
                        $self->recv_setEntities();
}

sub send_setEntities{
  my $self = shift;
  my $entities = shift;

                        $self->{output}->writeMessageBegin('setEntities', TMessageType::CALL, $self->{seqid});
                        my $args = new thrift::adept::common::CoreferenceService_setEntities_args();
                        $args->{entities} = $entities;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_setEntities{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == TMessageType::EXCEPTION) {
                          my $x = new TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new thrift::adept::common::CoreferenceService_setEntities_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        return;
}
sub setResolvedMentions{
  my $self = shift;
  my $resolvedEntityMentions = shift;

                                                $self->send_setResolvedMentions($resolvedEntityMentions);
                        $self->recv_setResolvedMentions();
}

sub send_setResolvedMentions{
  my $self = shift;
  my $resolvedEntityMentions = shift;

                        $self->{output}->writeMessageBegin('setResolvedMentions', TMessageType::CALL, $self->{seqid});
                        my $args = new thrift::adept::common::CoreferenceService_setResolvedMentions_args();
                        $args->{resolvedEntityMentions} = $resolvedEntityMentions;
                        $args->write($self->{output});
                        $self->{output}->writeMessageEnd();
                        $self->{output}->getTransport()->flush();
}

sub recv_setResolvedMentions{
  my $self = shift;

                        my $rseqid = 0;
                        my $fname;
                        my $mtype = 0;

                        $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                        if ($mtype == TMessageType::EXCEPTION) {
                          my $x = new TApplicationException();
                          $x->read($self->{input});
                          $self->{input}->readMessageEnd();
                          die $x;
                        }
                        my $result = new thrift::adept::common::CoreferenceService_setResolvedMentions_result();
                        $result->read($self->{input});
                        $self->{input}->readMessageEnd();

                        return;
}
package thrift::adept::common::CoreferenceServiceProcessor;

use strict;
use base qw(thrift::adept::common::ItemServiceProcessor);

sub process {
                          my ($self, $input, $output) = @_;
                          my $rseqid = 0;
                          my $fname  = undef;
                          my $mtype  = 0;

                          $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                          my $methodname = 'process_'.$fname;
                          if (!$self->can($methodname)) {
                            $input->skip(TType::STRUCT);
                            $input->readMessageEnd();
                            my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                            $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                            $x->write($output);
                            $output->writeMessageEnd();
                            $output->getTransport()->flush();
                            return;
                          }
                          $self->$methodname($rseqid, $input, $output);
                          return 1;
}

sub process_getCoreferenceId {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new thrift::adept::common::CoreferenceService_getCoreferenceId_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new thrift::adept::common::CoreferenceService_getCoreferenceId_result();
                          $result->{success} = $self->{handler}->getCoreferenceId();
                          $output->writeMessageBegin('getCoreferenceId', TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getEntities {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new thrift::adept::common::CoreferenceService_getEntities_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new thrift::adept::common::CoreferenceService_getEntities_result();
                          $result->{success} = $self->{handler}->getEntities();
                          $output->writeMessageBegin('getEntities', TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_getResolvedMentions {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new thrift::adept::common::CoreferenceService_getResolvedMentions_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new thrift::adept::common::CoreferenceService_getResolvedMentions_result();
                          $result->{success} = $self->{handler}->getResolvedMentions();
                          $output->writeMessageBegin('getResolvedMentions', TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_setEntities {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new thrift::adept::common::CoreferenceService_setEntities_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new thrift::adept::common::CoreferenceService_setEntities_result();
                          $self->{handler}->setEntities($args->entities);
                          $output->writeMessageBegin('setEntities', TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

sub process_setResolvedMentions {
                          my ($self, $seqid, $input, $output) = @_;
                          my $args = new thrift::adept::common::CoreferenceService_setResolvedMentions_args();
                          $args->read($input);
                          $input->readMessageEnd();
                          my $result = new thrift::adept::common::CoreferenceService_setResolvedMentions_result();
                          $self->{handler}->setResolvedMentions($args->resolvedEntityMentions);
                          $output->writeMessageBegin('setResolvedMentions', TMessageType::REPLY, $seqid);
                          $result->write($output);
                          $output->writeMessageEnd();
                          $output->getTransport()->flush();
}

1;