#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;
use thrift::adept::common::ItemService;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::TokenService_getAudioOffset_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getAudioOffset_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getAudioOffset_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getAudioOffset_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_getAudioOffset_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getAudioOffset_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == TType::STRUCT) {
                    $self->{success} = new thrift::adept::common::AudioOffset();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getAudioOffset_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getCharOffset_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getCharOffset_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getCharOffset_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getCharOffset_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_getCharOffset_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getCharOffset_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == TType::STRUCT) {
                    $self->{success} = new thrift::adept::common::CharOffset();
                    $xfer += $self->{success}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getCharOffset_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                $xfer += $self->{success}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getConfidence_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getConfidence_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getConfidence_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getConfidence_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_getConfidence_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getConfidence_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == TType::DOUBLE) {
                    $xfer += $input->readDouble(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getConfidence_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', TType::DOUBLE, 0);
                $xfer += $output->writeDouble($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getLemma_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getLemma_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getLemma_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getLemma_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_getLemma_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getLemma_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == TType::STRING) {
                    $xfer += $input->readString(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getLemma_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
                $xfer += $output->writeString($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getSequenceId_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getSequenceId_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getSequenceId_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getSequenceId_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_getSequenceId_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getSequenceId_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == TType::I64) {
                    $xfer += $input->readI64(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getSequenceId_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', TType::I64, 0);
                $xfer += $output->writeI64($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getTokenType_args;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getTokenType_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getTokenType_args');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_getTokenType_result;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_getTokenType_result->mk_accessors( qw( success ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{success} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{success}) {
                  $self->{success} = $vals->{success};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_getTokenType_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^0$/ && do{                  if ($ftype == TType::I32) {
                    $xfer += $input->readI32(\$self->{success});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_getTokenType_result');
              if (defined $self->{success}) {
                $xfer += $output->writeFieldBegin('success', TType::I32, 0);
                $xfer += $output->writeI32($self->{success});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setAudioOffset_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_setAudioOffset_args->mk_accessors( qw( audioOffset ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{audioOffset} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{audioOffset}) {
                  $self->{audioOffset} = $vals->{audioOffset};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setAudioOffset_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == TType::STRUCT) {
                    $self->{audioOffset} = new thrift::adept::common::AudioOffset();
                    $xfer += $self->{audioOffset}->read($input);
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setAudioOffset_args');
              if (defined $self->{audioOffset}) {
                $xfer += $output->writeFieldBegin('audioOffset', TType::STRUCT, 1);
                $xfer += $self->{audioOffset}->write($output);
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setAudioOffset_result;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setAudioOffset_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setAudioOffset_result');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setConfidence_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_setConfidence_args->mk_accessors( qw( confidence ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{confidence} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{confidence}) {
                  $self->{confidence} = $vals->{confidence};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setConfidence_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == TType::DOUBLE) {
                    $xfer += $input->readDouble(\$self->{confidence});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setConfidence_args');
              if (defined $self->{confidence}) {
                $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 1);
                $xfer += $output->writeDouble($self->{confidence});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setConfidence_result;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setConfidence_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setConfidence_result');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setLemma_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_setLemma_args->mk_accessors( qw( lemma ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{lemma} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{lemma}) {
                  $self->{lemma} = $vals->{lemma};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setLemma_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == TType::STRING) {
                    $xfer += $input->readString(\$self->{lemma});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setLemma_args');
              if (defined $self->{lemma}) {
                $xfer += $output->writeFieldBegin('lemma', TType::STRING, 1);
                $xfer += $output->writeString($self->{lemma});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setLemma_result;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setLemma_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setLemma_result');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setTokenType_args;
use base qw(Class::Accessor);
thrift::adept::common::TokenService_setTokenType_args->mk_accessors( qw( tokentype ) );

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              $self->{tokentype} = undef;
              if (UNIVERSAL::isa($vals,'HASH')) {
                if (defined $vals->{tokentype}) {
                  $self->{tokentype} = $vals->{tokentype};
                }
              }
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setTokenType_args';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                  /^1$/ && do{                  if ($ftype == TType::I32) {
                    $xfer += $input->readI32(\$self->{tokentype});
                  } else {
                    $xfer += $input->skip($ftype);
                  }
                  last; };
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setTokenType_args');
              if (defined $self->{tokentype}) {
                $xfer += $output->writeFieldBegin('tokentype', TType::I32, 1);
                $xfer += $output->writeI32($self->{tokentype});
                $xfer += $output->writeFieldEnd();
              }
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenService_setTokenType_result;
use base qw(Class::Accessor);

sub new {
              my $classname = shift;
              my $self      = {};
              my $vals      = shift || {};
              return bless ($self, $classname);
}

sub getName {
              return 'TokenService_setTokenType_result';
            }

sub read {
              my ($self, $input) = @_;
              my $xfer  = 0;
              my $fname;
              my $ftype = 0;
              my $fid   = 0;
              $xfer += $input->readStructBegin(\$fname);
              while (1) 
              {
                $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                if ($ftype == TType::STOP) {
                  last;
                }
                SWITCH: for($fid)
                {
                    $xfer += $input->skip($ftype);
                }
                $xfer += $input->readFieldEnd();
              }
              $xfer += $input->readStructEnd();
              return $xfer;
            }

sub write {
              my ($self, $output) = @_;
              my $xfer   = 0;
              $xfer += $output->writeStructBegin('TokenService_setTokenType_result');
              $xfer += $output->writeFieldStop();
              $xfer += $output->writeStructEnd();
              return $xfer;
            }

package thrift::adept::common::TokenServiceIf;

use strict;
use base qw(thrift::adept::common::ItemServiceIf);

sub getAudioOffset{
  my $self = shift;

  die 'implement interface';
}

sub getCharOffset{
  my $self = shift;

  die 'implement interface';
}

sub getConfidence{
  my $self = shift;

  die 'implement interface';
}

sub getLemma{
  my $self = shift;

  die 'implement interface';
}

sub getSequenceId{
  my $self = shift;

  die 'implement interface';
}

sub getTokenType{
  my $self = shift;

  die 'implement interface';
}

sub setAudioOffset{
  my $self = shift;
  my $audioOffset = shift;

  die 'implement interface';
}

sub setConfidence{
  my $self = shift;
  my $confidence = shift;

  die 'implement interface';
}

sub setLemma{
  my $self = shift;
  my $lemma = shift;

  die 'implement interface';
}

sub setTokenType{
  my $self = shift;
  my $tokentype = shift;

  die 'implement interface';
}

package thrift::adept::common::TokenServiceRest;

use strict;
use base qw(thrift::adept::common::ItemServiceRest);

sub getAudioOffset{
              my ($self, $request) = @_;

              return $self->{impl}->getAudioOffset();
            }

sub getCharOffset{
              my ($self, $request) = @_;

              return $self->{impl}->getCharOffset();
            }

sub getConfidence{
              my ($self, $request) = @_;

              return $self->{impl}->getConfidence();
            }

sub getLemma{
              my ($self, $request) = @_;

              return $self->{impl}->getLemma();
            }

sub getSequenceId{
              my ($self, $request) = @_;

              return $self->{impl}->getSequenceId();
            }

sub getTokenType{
              my ($self, $request) = @_;

              return $self->{impl}->getTokenType();
            }

sub setAudioOffset{
              my ($self, $request) = @_;

              my $audioOffset = ($request->{'audioOffset'}) ? $request->{'audioOffset'} : undef;
              return $self->{impl}->setAudioOffset($audioOffset);
            }

sub setConfidence{
              my ($self, $request) = @_;

              my $confidence = ($request->{'confidence'}) ? $request->{'confidence'} : undef;
              return $self->{impl}->setConfidence($confidence);
            }

sub setLemma{
              my ($self, $request) = @_;

              my $lemma = ($request->{'lemma'}) ? $request->{'lemma'} : undef;
              return $self->{impl}->setLemma($lemma);
            }

sub setTokenType{
              my ($self, $request) = @_;

              my $tokentype = ($request->{'tokentype'}) ? $request->{'tokentype'} : undef;
              return $self->{impl}->setTokenType($tokentype);
            }

package thrift::adept::common::TokenServiceClient;

use base qw(thrift::adept::common::ItemServiceClient);
use base qw(thrift::adept::common::TokenServiceIf);
sub new {
              my ($classname, $input, $output) = @_;
              my $self      = {};
              $self = $classname->SUPER::new($input, $output);
              return bless($self,$classname);
}

sub getAudioOffset{
  my $self = shift;

                            $self->send_getAudioOffset();
              return $self->recv_getAudioOffset();
}

sub send_getAudioOffset{
  my $self = shift;

              $self->{output}->writeMessageBegin('getAudioOffset', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_getAudioOffset_args();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getAudioOffset{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_getAudioOffset_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              die "getAudioOffset failed: unknown result";
}
sub getCharOffset{
  my $self = shift;

                            $self->send_getCharOffset();
              return $self->recv_getCharOffset();
}

sub send_getCharOffset{
  my $self = shift;

              $self->{output}->writeMessageBegin('getCharOffset', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_getCharOffset_args();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getCharOffset{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_getCharOffset_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              die "getCharOffset failed: unknown result";
}
sub getConfidence{
  my $self = shift;

                            $self->send_getConfidence();
              return $self->recv_getConfidence();
}

sub send_getConfidence{
  my $self = shift;

              $self->{output}->writeMessageBegin('getConfidence', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_getConfidence_args();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getConfidence{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_getConfidence_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              die "getConfidence failed: unknown result";
}
sub getLemma{
  my $self = shift;

                            $self->send_getLemma();
              return $self->recv_getLemma();
}

sub send_getLemma{
  my $self = shift;

              $self->{output}->writeMessageBegin('getLemma', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_getLemma_args();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getLemma{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_getLemma_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              die "getLemma failed: unknown result";
}
sub getSequenceId{
  my $self = shift;

                            $self->send_getSequenceId();
              return $self->recv_getSequenceId();
}

sub send_getSequenceId{
  my $self = shift;

              $self->{output}->writeMessageBegin('getSequenceId', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_getSequenceId_args();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getSequenceId{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_getSequenceId_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              die "getSequenceId failed: unknown result";
}
sub getTokenType{
  my $self = shift;

                            $self->send_getTokenType();
              return $self->recv_getTokenType();
}

sub send_getTokenType{
  my $self = shift;

              $self->{output}->writeMessageBegin('getTokenType', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_getTokenType_args();
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_getTokenType{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_getTokenType_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              if (defined $result->{success} ) {
                return $result->{success};
              }
              die "getTokenType failed: unknown result";
}
sub setAudioOffset{
  my $self = shift;
  my $audioOffset = shift;

                            $self->send_setAudioOffset($audioOffset);
              $self->recv_setAudioOffset();
}

sub send_setAudioOffset{
  my $self = shift;
  my $audioOffset = shift;

              $self->{output}->writeMessageBegin('setAudioOffset', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_setAudioOffset_args();
              $args->{audioOffset} = $audioOffset;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_setAudioOffset{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_setAudioOffset_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              return;
}
sub setConfidence{
  my $self = shift;
  my $confidence = shift;

                            $self->send_setConfidence($confidence);
              $self->recv_setConfidence();
}

sub send_setConfidence{
  my $self = shift;
  my $confidence = shift;

              $self->{output}->writeMessageBegin('setConfidence', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_setConfidence_args();
              $args->{confidence} = $confidence;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_setConfidence{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_setConfidence_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              return;
}
sub setLemma{
  my $self = shift;
  my $lemma = shift;

                            $self->send_setLemma($lemma);
              $self->recv_setLemma();
}

sub send_setLemma{
  my $self = shift;
  my $lemma = shift;

              $self->{output}->writeMessageBegin('setLemma', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_setLemma_args();
              $args->{lemma} = $lemma;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_setLemma{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_setLemma_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              return;
}
sub setTokenType{
  my $self = shift;
  my $tokentype = shift;

                            $self->send_setTokenType($tokentype);
              $self->recv_setTokenType();
}

sub send_setTokenType{
  my $self = shift;
  my $tokentype = shift;

              $self->{output}->writeMessageBegin('setTokenType', TMessageType::CALL, $self->{seqid});
              my $args = new thrift::adept::common::TokenService_setTokenType_args();
              $args->{tokentype} = $tokentype;
              $args->write($self->{output});
              $self->{output}->writeMessageEnd();
              $self->{output}->getTransport()->flush();
}

sub recv_setTokenType{
  my $self = shift;

              my $rseqid = 0;
              my $fname;
              my $mtype = 0;

              $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
              if ($mtype == TMessageType::EXCEPTION) {
                my $x = new TApplicationException();
                $x->read($self->{input});
                $self->{input}->readMessageEnd();
                die $x;
              }
              my $result = new thrift::adept::common::TokenService_setTokenType_result();
              $result->read($self->{input});
              $self->{input}->readMessageEnd();

              return;
}
package thrift::adept::common::TokenServiceProcessor;

use strict;
use base qw(thrift::adept::common::ItemServiceProcessor);

sub process {
                my ($self, $input, $output) = @_;
                my $rseqid = 0;
                my $fname  = undef;
                my $mtype  = 0;

                $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                my $methodname = 'process_'.$fname;
                if (!$self->can($methodname)) {
                  $input->skip(TType::STRUCT);
                  $input->readMessageEnd();
                  my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                  $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                  $x->write($output);
                  $output->writeMessageEnd();
                  $output->getTransport()->flush();
                  return;
                }
                $self->$methodname($rseqid, $input, $output);
                return 1;
}

sub process_getAudioOffset {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_getAudioOffset_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_getAudioOffset_result();
                $result->{success} = $self->{handler}->getAudioOffset();
                $output->writeMessageBegin('getAudioOffset', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getCharOffset {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_getCharOffset_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_getCharOffset_result();
                $result->{success} = $self->{handler}->getCharOffset();
                $output->writeMessageBegin('getCharOffset', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getConfidence {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_getConfidence_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_getConfidence_result();
                $result->{success} = $self->{handler}->getConfidence();
                $output->writeMessageBegin('getConfidence', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getLemma {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_getLemma_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_getLemma_result();
                $result->{success} = $self->{handler}->getLemma();
                $output->writeMessageBegin('getLemma', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getSequenceId {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_getSequenceId_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_getSequenceId_result();
                $result->{success} = $self->{handler}->getSequenceId();
                $output->writeMessageBegin('getSequenceId', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_getTokenType {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_getTokenType_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_getTokenType_result();
                $result->{success} = $self->{handler}->getTokenType();
                $output->writeMessageBegin('getTokenType', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_setAudioOffset {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_setAudioOffset_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_setAudioOffset_result();
                $self->{handler}->setAudioOffset($args->audioOffset);
                $output->writeMessageBegin('setAudioOffset', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_setConfidence {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_setConfidence_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_setConfidence_result();
                $self->{handler}->setConfidence($args->confidence);
                $output->writeMessageBegin('setConfidence', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_setLemma {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_setLemma_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_setLemma_result();
                $self->{handler}->setLemma($args->lemma);
                $output->writeMessageBegin('setLemma', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

sub process_setTokenType {
                my ($self, $seqid, $input, $output) = @_;
                my $args = new thrift::adept::common::TokenService_setTokenType_args();
                $args->read($input);
                $input->readMessageEnd();
                my $result = new thrift::adept::common::TokenService_setTokenType_result();
                $self->{handler}->setTokenType($args->tokentype);
                $output->writeMessageBegin('setTokenType', TMessageType::REPLY, $seqid);
                $result->write($output);
                $output->writeMessageEnd();
                $output->getTransport()->flush();
}

1;
