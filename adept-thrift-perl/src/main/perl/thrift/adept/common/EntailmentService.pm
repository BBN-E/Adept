#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use thrift::adept::common::Types;
use thrift::adept::common::ItemService;

# HELPER FUNCTIONS AND STRUCTURES

package thrift::adept::common::EntailmentService_addJudgmentConfidencePair_args;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_addJudgmentConfidencePair_args->mk_accessors( qw( judgment confidence ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{judgment} = undef;
                                                                    $self->{confidence} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{judgment}) {
                                                                        $self->{judgment} = $vals->{judgment};
                                                                      }
                                                                      if (defined $vals->{confidence}) {
                                                                        $self->{confidence} = $vals->{confidence};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_addJudgmentConfidencePair_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^1$/ && do{                                                                        if ($ftype == TType::I32) {
                                                                          $xfer += $input->readI32(\$self->{judgment});
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                        /^2$/ && do{                                                                        if ($ftype == TType::DOUBLE) {
                                                                          $xfer += $input->readDouble(\$self->{confidence});
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_addJudgmentConfidencePair_args');
                                                                    if (defined $self->{judgment}) {
                                                                      $xfer += $output->writeFieldBegin('judgment', TType::I32, 1);
                                                                      $xfer += $output->writeI32($self->{judgment});
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    if (defined $self->{confidence}) {
                                                                      $xfer += $output->writeFieldBegin('confidence', TType::DOUBLE, 2);
                                                                      $xfer += $output->writeDouble($self->{confidence});
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_addJudgmentConfidencePair_result;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_addJudgmentConfidencePair_result->mk_accessors( qw( success ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{success} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{success}) {
                                                                        $self->{success} = $vals->{success};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_addJudgmentConfidencePair_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^0$/ && do{                                                                        if ($ftype == TType::BOOL) {
                                                                          $xfer += $input->readBool(\$self->{success});
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_addJudgmentConfidencePair_result');
                                                                    if (defined $self->{success}) {
                                                                      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
                                                                      $xfer += $output->writeBool($self->{success});
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getBestJudgment_args;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getBestJudgment_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getBestJudgment_args');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getBestJudgment_result;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_getBestJudgment_result->mk_accessors( qw( success ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{success} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{success}) {
                                                                        $self->{success} = $vals->{success};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getBestJudgment_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^0$/ && do{                                                                        if ($ftype == TType::STRUCT) {
                                                                          $self->{success} = new thrift::adept::common::ChunkUnion();
                                                                          $xfer += $self->{success}->read($input);
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getBestJudgment_result');
                                                                    if (defined $self->{success}) {
                                                                      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                      $xfer += $self->{success}->write($output);
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getEntailmentId_args;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getEntailmentId_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getEntailmentId_args');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getEntailmentId_result;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_getEntailmentId_result->mk_accessors( qw( success ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{success} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{success}) {
                                                                        $self->{success} = $vals->{success};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getEntailmentId_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^0$/ && do{                                                                        if ($ftype == TType::I64) {
                                                                          $xfer += $input->readI64(\$self->{success});
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getEntailmentId_result');
                                                                    if (defined $self->{success}) {
                                                                      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
                                                                      $xfer += $output->writeI64($self->{success});
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getHypothesis_args;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getHypothesis_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getHypothesis_args');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getHypothesis_result;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_getHypothesis_result->mk_accessors( qw( success ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{success} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{success}) {
                                                                        $self->{success} = $vals->{success};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getHypothesis_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^0$/ && do{                                                                        if ($ftype == TType::STRUCT) {
                                                                          $self->{success} = new thrift::adept::common::Passage();
                                                                          $xfer += $self->{success}->read($input);
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getHypothesis_result');
                                                                    if (defined $self->{success}) {
                                                                      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                      $xfer += $self->{success}->write($output);
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getJudgmentDistribution_args;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getJudgmentDistribution_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getJudgmentDistribution_args');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getJudgmentDistribution_result;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_getJudgmentDistribution_result->mk_accessors( qw( success ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{success} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{success}) {
                                                                        $self->{success} = $vals->{success};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getJudgmentDistribution_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^0$/ && do{                                                                        if ($ftype == TType::MAP) {
                                                                          {
                                                                            my $_size734 = 0;
                                                                            $self->{success} = {};
                                                                            my $_ktype735 = 0;
                                                                            my $_vtype736 = 0;
                                                                            $xfer += $input->readMapBegin(\$_ktype735, \$_vtype736, \$_size734);
                                                                            for (my $_i738 = 0; $_i738 < $_size734; ++$_i738)
                                                                            {
                                                                              my $key739 = 0;
                                                                              my $val740 = 0.0;
                                                                              $xfer += $input->readI32(\$key739);
                                                                              $xfer += $input->readDouble(\$val740);
                                                                              $self->{success}->{$key739} = $val740;
                                                                            }
                                                                            $xfer += $input->readMapEnd();
                                                                          }
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getJudgmentDistribution_result');
                                                                    if (defined $self->{success}) {
                                                                      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
                                                                      {
                                                                        $xfer += $output->writeMapBegin(TType::I32, TType::DOUBLE, scalar(keys %{$self->{success}}));
                                                                        {
                                                                          while( my ($kiter741,$viter742) = each %{$self->{success}}) 
                                                                          {
                                                                            $xfer += $output->writeI32($kiter741);
                                                                            $xfer += $output->writeDouble($viter742);
                                                                          }
                                                                        }
                                                                        $xfer += $output->writeMapEnd();
                                                                      }
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getText_args;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getText_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getText_args');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_getText_result;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_getText_result->mk_accessors( qw( success ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{success} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{success}) {
                                                                        $self->{success} = $vals->{success};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_getText_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^0$/ && do{                                                                        if ($ftype == TType::STRUCT) {
                                                                          $self->{success} = new thrift::adept::common::Passage();
                                                                          $xfer += $self->{success}->read($input);
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_getText_result');
                                                                    if (defined $self->{success}) {
                                                                      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
                                                                      $xfer += $self->{success}->write($output);
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_setHypothesis_args;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_setHypothesis_args->mk_accessors( qw( hypothesis ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{hypothesis} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{hypothesis}) {
                                                                        $self->{hypothesis} = $vals->{hypothesis};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_setHypothesis_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^1$/ && do{                                                                        if ($ftype == TType::STRUCT) {
                                                                          $self->{hypothesis} = new thrift::adept::common::Passage();
                                                                          $xfer += $self->{hypothesis}->read($input);
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_setHypothesis_args');
                                                                    if (defined $self->{hypothesis}) {
                                                                      $xfer += $output->writeFieldBegin('hypothesis', TType::STRUCT, 1);
                                                                      $xfer += $self->{hypothesis}->write($output);
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_setHypothesis_result;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_setHypothesis_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_setHypothesis_result');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_setJudgmentDistribution_args;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_setJudgmentDistribution_args->mk_accessors( qw( judgmentDistribution ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{judgmentDistribution} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{judgmentDistribution}) {
                                                                        $self->{judgmentDistribution} = $vals->{judgmentDistribution};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_setJudgmentDistribution_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^1$/ && do{                                                                        if ($ftype == TType::MAP) {
                                                                          {
                                                                            my $_size743 = 0;
                                                                            $self->{judgmentDistribution} = {};
                                                                            my $_ktype744 = 0;
                                                                            my $_vtype745 = 0;
                                                                            $xfer += $input->readMapBegin(\$_ktype744, \$_vtype745, \$_size743);
                                                                            for (my $_i747 = 0; $_i747 < $_size743; ++$_i747)
                                                                            {
                                                                              my $key748 = 0;
                                                                              my $val749 = 0.0;
                                                                              $xfer += $input->readI32(\$key748);
                                                                              $xfer += $input->readDouble(\$val749);
                                                                              $self->{judgmentDistribution}->{$key748} = $val749;
                                                                            }
                                                                            $xfer += $input->readMapEnd();
                                                                          }
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_setJudgmentDistribution_args');
                                                                    if (defined $self->{judgmentDistribution}) {
                                                                      $xfer += $output->writeFieldBegin('judgmentDistribution', TType::MAP, 1);
                                                                      {
                                                                        $xfer += $output->writeMapBegin(TType::I32, TType::DOUBLE, scalar(keys %{$self->{judgmentDistribution}}));
                                                                        {
                                                                          while( my ($kiter750,$viter751) = each %{$self->{judgmentDistribution}}) 
                                                                          {
                                                                            $xfer += $output->writeI32($kiter750);
                                                                            $xfer += $output->writeDouble($viter751);
                                                                          }
                                                                        }
                                                                        $xfer += $output->writeMapEnd();
                                                                      }
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_setJudgmentDistribution_result;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_setJudgmentDistribution_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_setJudgmentDistribution_result');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_setText_args;
use base qw(Class::Accessor);
thrift::adept::common::EntailmentService_setText_args->mk_accessors( qw( text ) );

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    $self->{text} = undef;
                                                                    if (UNIVERSAL::isa($vals,'HASH')) {
                                                                      if (defined $vals->{text}) {
                                                                        $self->{text} = $vals->{text};
                                                                      }
                                                                    }
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_setText_args';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                        /^1$/ && do{                                                                        if ($ftype == TType::STRUCT) {
                                                                          $self->{text} = new thrift::adept::common::Passage();
                                                                          $xfer += $self->{text}->read($input);
                                                                        } else {
                                                                          $xfer += $input->skip($ftype);
                                                                        }
                                                                        last; };
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_setText_args');
                                                                    if (defined $self->{text}) {
                                                                      $xfer += $output->writeFieldBegin('text', TType::STRUCT, 1);
                                                                      $xfer += $self->{text}->write($output);
                                                                      $xfer += $output->writeFieldEnd();
                                                                    }
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentService_setText_result;
use base qw(Class::Accessor);

sub new {
                                                                    my $classname = shift;
                                                                    my $self      = {};
                                                                    my $vals      = shift || {};
                                                                    return bless ($self, $classname);
}

sub getName {
                                                                    return 'EntailmentService_setText_result';
                                                                  }

sub read {
                                                                    my ($self, $input) = @_;
                                                                    my $xfer  = 0;
                                                                    my $fname;
                                                                    my $ftype = 0;
                                                                    my $fid   = 0;
                                                                    $xfer += $input->readStructBegin(\$fname);
                                                                    while (1) 
                                                                    {
                                                                      $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
                                                                      if ($ftype == TType::STOP) {
                                                                        last;
                                                                      }
                                                                      SWITCH: for($fid)
                                                                      {
                                                                          $xfer += $input->skip($ftype);
                                                                      }
                                                                      $xfer += $input->readFieldEnd();
                                                                    }
                                                                    $xfer += $input->readStructEnd();
                                                                    return $xfer;
                                                                  }

sub write {
                                                                    my ($self, $output) = @_;
                                                                    my $xfer   = 0;
                                                                    $xfer += $output->writeStructBegin('EntailmentService_setText_result');
                                                                    $xfer += $output->writeFieldStop();
                                                                    $xfer += $output->writeStructEnd();
                                                                    return $xfer;
                                                                  }

package thrift::adept::common::EntailmentServiceIf;

use strict;
use base qw(thrift::adept::common::ItemServiceIf);

sub addJudgmentConfidencePair{
  my $self = shift;
  my $judgment = shift;
  my $confidence = shift;

  die 'implement interface';
}

sub getBestJudgment{
  my $self = shift;

  die 'implement interface';
}

sub getEntailmentId{
  my $self = shift;

  die 'implement interface';
}

sub getHypothesis{
  my $self = shift;

  die 'implement interface';
}

sub getJudgmentDistribution{
  my $self = shift;

  die 'implement interface';
}

sub getText{
  my $self = shift;

  die 'implement interface';
}

sub setHypothesis{
  my $self = shift;
  my $hypothesis = shift;

  die 'implement interface';
}

sub setJudgmentDistribution{
  my $self = shift;
  my $judgmentDistribution = shift;

  die 'implement interface';
}

sub setText{
  my $self = shift;
  my $text = shift;

  die 'implement interface';
}

package thrift::adept::common::EntailmentServiceRest;

use strict;
use base qw(thrift::adept::common::ItemServiceRest);

sub addJudgmentConfidencePair{
                                                                    my ($self, $request) = @_;

                                                                    my $judgment = ($request->{'judgment'}) ? $request->{'judgment'} : undef;
                                                                    my $confidence = ($request->{'confidence'}) ? $request->{'confidence'} : undef;
                                                                    return $self->{impl}->addJudgmentConfidencePair($judgment, $confidence);
                                                                  }

sub getBestJudgment{
                                                                    my ($self, $request) = @_;

                                                                    return $self->{impl}->getBestJudgment();
                                                                  }

sub getEntailmentId{
                                                                    my ($self, $request) = @_;

                                                                    return $self->{impl}->getEntailmentId();
                                                                  }

sub getHypothesis{
                                                                    my ($self, $request) = @_;

                                                                    return $self->{impl}->getHypothesis();
                                                                  }

sub getJudgmentDistribution{
                                                                    my ($self, $request) = @_;

                                                                    return $self->{impl}->getJudgmentDistribution();
                                                                  }

sub getText{
                                                                    my ($self, $request) = @_;

                                                                    return $self->{impl}->getText();
                                                                  }

sub setHypothesis{
                                                                    my ($self, $request) = @_;

                                                                    my $hypothesis = ($request->{'hypothesis'}) ? $request->{'hypothesis'} : undef;
                                                                    return $self->{impl}->setHypothesis($hypothesis);
                                                                  }

sub setJudgmentDistribution{
                                                                    my ($self, $request) = @_;

                                                                    my $judgmentDistribution = ($request->{'judgmentDistribution'}) ? $request->{'judgmentDistribution'} : undef;
                                                                    return $self->{impl}->setJudgmentDistribution($judgmentDistribution);
                                                                  }

sub setText{
                                                                    my ($self, $request) = @_;

                                                                    my $text = ($request->{'text'}) ? $request->{'text'} : undef;
                                                                    return $self->{impl}->setText($text);
                                                                  }

package thrift::adept::common::EntailmentServiceClient;

use base qw(thrift::adept::common::ItemServiceClient);
use base qw(thrift::adept::common::EntailmentServiceIf);
sub new {
                                                                    my ($classname, $input, $output) = @_;
                                                                    my $self      = {};
                                                                    $self = $classname->SUPER::new($input, $output);
                                                                    return bless($self,$classname);
}

sub addJudgmentConfidencePair{
  my $self = shift;
  my $judgment = shift;
  my $confidence = shift;

                                                                                                                                        $self->send_addJudgmentConfidencePair($judgment, $confidence);
                                                                    return $self->recv_addJudgmentConfidencePair();
}

sub send_addJudgmentConfidencePair{
  my $self = shift;
  my $judgment = shift;
  my $confidence = shift;

                                                                    $self->{output}->writeMessageBegin('addJudgmentConfidencePair', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_addJudgmentConfidencePair_args();
                                                                    $args->{judgment} = $judgment;
                                                                    $args->{confidence} = $confidence;
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_addJudgmentConfidencePair{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_addJudgmentConfidencePair_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    if (defined $result->{success} ) {
                                                                      return $result->{success};
                                                                    }
                                                                    die "addJudgmentConfidencePair failed: unknown result";
}
sub getBestJudgment{
  my $self = shift;

                                                                                                                                        $self->send_getBestJudgment();
                                                                    return $self->recv_getBestJudgment();
}

sub send_getBestJudgment{
  my $self = shift;

                                                                    $self->{output}->writeMessageBegin('getBestJudgment', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_getBestJudgment_args();
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_getBestJudgment{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_getBestJudgment_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    if (defined $result->{success} ) {
                                                                      return $result->{success};
                                                                    }
                                                                    die "getBestJudgment failed: unknown result";
}
sub getEntailmentId{
  my $self = shift;

                                                                                                                                        $self->send_getEntailmentId();
                                                                    return $self->recv_getEntailmentId();
}

sub send_getEntailmentId{
  my $self = shift;

                                                                    $self->{output}->writeMessageBegin('getEntailmentId', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_getEntailmentId_args();
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_getEntailmentId{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_getEntailmentId_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    if (defined $result->{success} ) {
                                                                      return $result->{success};
                                                                    }
                                                                    die "getEntailmentId failed: unknown result";
}
sub getHypothesis{
  my $self = shift;

                                                                                                                                        $self->send_getHypothesis();
                                                                    return $self->recv_getHypothesis();
}

sub send_getHypothesis{
  my $self = shift;

                                                                    $self->{output}->writeMessageBegin('getHypothesis', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_getHypothesis_args();
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_getHypothesis{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_getHypothesis_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    if (defined $result->{success} ) {
                                                                      return $result->{success};
                                                                    }
                                                                    die "getHypothesis failed: unknown result";
}
sub getJudgmentDistribution{
  my $self = shift;

                                                                                                                                        $self->send_getJudgmentDistribution();
                                                                    return $self->recv_getJudgmentDistribution();
}

sub send_getJudgmentDistribution{
  my $self = shift;

                                                                    $self->{output}->writeMessageBegin('getJudgmentDistribution', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_getJudgmentDistribution_args();
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_getJudgmentDistribution{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_getJudgmentDistribution_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    if (defined $result->{success} ) {
                                                                      return $result->{success};
                                                                    }
                                                                    die "getJudgmentDistribution failed: unknown result";
}
sub getText{
  my $self = shift;

                                                                                                                                        $self->send_getText();
                                                                    return $self->recv_getText();
}

sub send_getText{
  my $self = shift;

                                                                    $self->{output}->writeMessageBegin('getText', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_getText_args();
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_getText{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_getText_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    if (defined $result->{success} ) {
                                                                      return $result->{success};
                                                                    }
                                                                    die "getText failed: unknown result";
}
sub setHypothesis{
  my $self = shift;
  my $hypothesis = shift;

                                                                                                                                        $self->send_setHypothesis($hypothesis);
                                                                    $self->recv_setHypothesis();
}

sub send_setHypothesis{
  my $self = shift;
  my $hypothesis = shift;

                                                                    $self->{output}->writeMessageBegin('setHypothesis', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_setHypothesis_args();
                                                                    $args->{hypothesis} = $hypothesis;
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_setHypothesis{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_setHypothesis_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    return;
}
sub setJudgmentDistribution{
  my $self = shift;
  my $judgmentDistribution = shift;

                                                                                                                                        $self->send_setJudgmentDistribution($judgmentDistribution);
                                                                    $self->recv_setJudgmentDistribution();
}

sub send_setJudgmentDistribution{
  my $self = shift;
  my $judgmentDistribution = shift;

                                                                    $self->{output}->writeMessageBegin('setJudgmentDistribution', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_setJudgmentDistribution_args();
                                                                    $args->{judgmentDistribution} = $judgmentDistribution;
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_setJudgmentDistribution{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_setJudgmentDistribution_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    return;
}
sub setText{
  my $self = shift;
  my $text = shift;

                                                                                                                                        $self->send_setText($text);
                                                                    $self->recv_setText();
}

sub send_setText{
  my $self = shift;
  my $text = shift;

                                                                    $self->{output}->writeMessageBegin('setText', TMessageType::CALL, $self->{seqid});
                                                                    my $args = new thrift::adept::common::EntailmentService_setText_args();
                                                                    $args->{text} = $text;
                                                                    $args->write($self->{output});
                                                                    $self->{output}->writeMessageEnd();
                                                                    $self->{output}->getTransport()->flush();
}

sub recv_setText{
  my $self = shift;

                                                                    my $rseqid = 0;
                                                                    my $fname;
                                                                    my $mtype = 0;

                                                                    $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                    if ($mtype == TMessageType::EXCEPTION) {
                                                                      my $x = new TApplicationException();
                                                                      $x->read($self->{input});
                                                                      $self->{input}->readMessageEnd();
                                                                      die $x;
                                                                    }
                                                                    my $result = new thrift::adept::common::EntailmentService_setText_result();
                                                                    $result->read($self->{input});
                                                                    $self->{input}->readMessageEnd();

                                                                    return;
}
package thrift::adept::common::EntailmentServiceProcessor;

use strict;
use base qw(thrift::adept::common::ItemServiceProcessor);

sub process {
                                                                      my ($self, $input, $output) = @_;
                                                                      my $rseqid = 0;
                                                                      my $fname  = undef;
                                                                      my $mtype  = 0;

                                                                      $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
                                                                      my $methodname = 'process_'.$fname;
                                                                      if (!$self->can($methodname)) {
                                                                        $input->skip(TType::STRUCT);
                                                                        $input->readMessageEnd();
                                                                        my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
                                                                        $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
                                                                        $x->write($output);
                                                                        $output->writeMessageEnd();
                                                                        $output->getTransport()->flush();
                                                                        return;
                                                                      }
                                                                      $self->$methodname($rseqid, $input, $output);
                                                                      return 1;
}

sub process_addJudgmentConfidencePair {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_addJudgmentConfidencePair_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_addJudgmentConfidencePair_result();
                                                                      $result->{success} = $self->{handler}->addJudgmentConfidencePair($args->judgment, $args->confidence);
                                                                      $output->writeMessageBegin('addJudgmentConfidencePair', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_getBestJudgment {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_getBestJudgment_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_getBestJudgment_result();
                                                                      $result->{success} = $self->{handler}->getBestJudgment();
                                                                      $output->writeMessageBegin('getBestJudgment', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_getEntailmentId {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_getEntailmentId_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_getEntailmentId_result();
                                                                      $result->{success} = $self->{handler}->getEntailmentId();
                                                                      $output->writeMessageBegin('getEntailmentId', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_getHypothesis {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_getHypothesis_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_getHypothesis_result();
                                                                      $result->{success} = $self->{handler}->getHypothesis();
                                                                      $output->writeMessageBegin('getHypothesis', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_getJudgmentDistribution {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_getJudgmentDistribution_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_getJudgmentDistribution_result();
                                                                      $result->{success} = $self->{handler}->getJudgmentDistribution();
                                                                      $output->writeMessageBegin('getJudgmentDistribution', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_getText {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_getText_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_getText_result();
                                                                      $result->{success} = $self->{handler}->getText();
                                                                      $output->writeMessageBegin('getText', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_setHypothesis {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_setHypothesis_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_setHypothesis_result();
                                                                      $self->{handler}->setHypothesis($args->hypothesis);
                                                                      $output->writeMessageBegin('setHypothesis', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_setJudgmentDistribution {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_setJudgmentDistribution_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_setJudgmentDistribution_result();
                                                                      $self->{handler}->setJudgmentDistribution($args->judgmentDistribution);
                                                                      $output->writeMessageBegin('setJudgmentDistribution', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

sub process_setText {
                                                                      my ($self, $seqid, $input, $output) = @_;
                                                                      my $args = new thrift::adept::common::EntailmentService_setText_args();
                                                                      $args->read($input);
                                                                      $input->readMessageEnd();
                                                                      my $result = new thrift::adept::common::EntailmentService_setText_result();
                                                                      $self->{handler}->setText($args->text);
                                                                      $output->writeMessageBegin('setText', TMessageType::REPLY, $seqid);
                                                                      $result->write($output);
                                                                      $output->writeMessageEnd();
                                                                      $output->getTransport()->flush();
}

1;